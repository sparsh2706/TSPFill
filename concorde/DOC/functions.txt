BEGINFILE: UTIL/sortrus.c

FILENAME: UTIL/sortrus.c
FUNCTION: CCutil_linked_radixsort
DESC: radix-sort a linked list
HEADER: util.h
PROTOTYPE:
    char *CCutil_linked_radixsort (char *data, char *datanext,
        char *dataval, int valsize)
DESCRIPTION:
    USAGE:
      head = (bar *) CCutil_linked_radixsort ((char *) head,
         (char *) &(head->next), (char *) &(head->val), sizeof (int));
    Then head is the start of the linked list in increasing order of
    val, with next as the field that links the bars.
    WARNING: DOES NOT HANDLE NEGATIVE NUMBERS PROPERLY.
END_DESCRIPTION

FILENAME: UTIL/sortrus.c
FUNCTION: CCutil_int_array_quicksort
DESC: quick-sort an integer array
HEADER: util.h
PROTOTYPE:
    void CCutil_int_array_quicksort (int *len, int n)
DESCRIPTION:
    len - the array to be sorted
    n - the number of elements in len
    Uses quicksort to put len in increasing order.
END_DESCRIPTION

FILENAME: UTIL/sortrus.c
FUNCTION: CCutil_int_perm_quicksort
DESC: quick-sort a permutation of integers
HEADER: util.h
PROTOTYPE:
    void CCutil_int_perm_quicksort (int *perm, int *len, int n)
DESCRIPTION:
    perm - must be allocated and initialized by the calling routine,
           it will be arranged in increasing order of len.
    n - the number of elements in perm and len.
END_DESCRIPTION

FILENAME: UTIL/sortrus.c
FUNCTION: CCutil_double_perm_quicksort
DESC: quick-sort a permutation of doubles
HEADER: util.h
PROTOTYPE:
    void CCutil_double_perm_quicksort (int *perm, double *len, int n)
DESCRIPTION:
    perm - must be allocated and initialized by the calling routine,
           it will be arranged in increasing order of len.
    n - the number of elements in perm and len.
END_DESCRIPTION

FILENAME: UTIL/sortrus.c
FUNCTION: CCutil_rselect
DESC: divide a permutation of integers into the m smallest and the rest
HEADER: util.h
PROTOTYPE:
    void CCutil_rselect (int *arr, int l, int r, int m,
        double *coord, CCrandstate *rstate)
DESCRIPTION:
    arr - permutation that will be rearranged
    l,r - specify the range of arr that we are interested in
    m - is the index into l,r that is the break point for the perm
    coord - gives the keys that determine the ordering
END_DESCRIPTION

BEGINFILE: UTIL/zeit.c

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_zeit
DESC: measure cpu time
HEADER: util.h
PROTOTYPE:
    double CCutil_zeit (void)
DESCRIPTION:
        - To measure cpu time.
    To use this, set double t = CCutil_zeit (), run the function you
    want to time, then compute CCutil_zeit () - t.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_real_zeit
DESC: measure real time
HEADER: util.h
PROTOTYPE:
    double CCutil_real_zeit (void)
DESCRIPTION:
    - To measure wall clock time.

    To use this, set double t = CCutil_real_zeit (), run the function
    you want to time, then compute CCutil_real_zeit () - t.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_init_timer
DESC: initialize a timer
HEADER: util.h
PROTOTYPE:
    void CCutil_init_timer (CCutil_timer *t, const char *name)
DESCRIPTION:
    - Initializes a CCutil_timer, and gives it a name.
    - The name is silently truncated if it is too long.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_start_timer
DESC: start a timer running
HEADER: util.h
PROTOTYPE:
    void CCutil_start_timer (CCutil_timer *t)
DESCRIPTION:
    - Starts the timer.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_suspend_timer
DESC: suspend a timer
HEADER: util.h
PROTOTYPE:
    void CCutil_suspend_timer (CCutil_timer *t)
DESCRIPTION:
    - Suspends the timer.  Similar to CCutil_stop_timer, but doesn't
      count a call, and doesn't output.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_resume_timer
DESC: resume a suspended timer
HEADER: util.h
PROTOTYPE:
    void CCutil_resume_timer (CCutil_timer *t)
DESCRIPTION:
    - Resumes the timer after a suspend.
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_stop_timer
DESC: stop a timer
HEADER: util.h
PROTOTYPE:
    double CCutil_stop_timer (CCutil_timer *t, int printit)
DESCRIPTION:
    - Stops the timer, and returns the time since the last start.
    - if printit == 1, outputs the time spent.
    - if printit == 2, outputs the time spent only if nonzero
    - if printit == 3,4, like 1,2, except brief, table-form output
END_DESCRIPTION

FILENAME: UTIL/zeit.c
FUNCTION: CCutil_total_timer
DESC: get the total time in a timer
HEADER: util.h
PROTOTYPE:
    double CCutil_total_timer (CCutil_timer *t, int printit)
DESCRIPTION:
    - Returns the cumulative time for this timer.
    - if printit == 1, outputs the cumulative time.
    - if printit == 2, outputs the cumulative time only if nonzero
    - if printit == 3,4, like 1,2, except brief, table-form output
END_DESCRIPTION

BEGINFILE: UTIL/util.c

FILENAME: UTIL/util.c
FUNCTION: CCutil_nextprime
DESC: find the next larger prime
HEADER: util.h
PROTOTYPE:
    unsigned int CCutil_nextprime (unsigned int x)
DESCRIPTION:
    FINDS the smallest positive prime >= x
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_our_gcd
DESC: find the greatest common divisor (gcd) of two numbers
HEADER: util.h
PROTOTYPE:
    int CCutil_our_gcd (int a, int b)
DESCRIPTION:
    COMPUTES gcd(a,b)
    -gcd(a,b) is always >= 0
    -a and b can be negative, positive, or zero
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_our_lcm
DESC: find the lowest common multiple (lcm) of two numbers
HEADER: util.h
PROTOTYPE:
    int CCutil_our_lcm (int a, int b)
DESCRIPTION:
    COMPUTES lcm(a,b)
    -lcm(a,b) is always >= 0
    -a and b can be negative, positive, or zero
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strchr
DESC: search a string for a character
HEADER: util.h
PROTOTYPE:
    char *CCutil_strchr (char *s, int c)
DESCRIPTION:
    RETURNS a pointer to the first occurrence of c in s, or NULL if c
    does not occur in s
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strrchr
DESC: search a string backwards for a character
HEADER: util.h
PROTOTYPE:
    char *CCutil_strrchr (char *s, int c)
DESCRIPTION:
    RETURNS a pointer to the last occurrence of c in s, or NULL if c
    does not occur in s
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strchr_c
DESC: search a constant string for a character
HEADER: util.h
PROTOTYPE:
    const char *CCutil_strchr_c (const char *s, int c)
DESCRIPTION:
    RETURNS a pointer to the first occurrence of c in s, or NULL if c
    does not occur in s.  A variant for const strings.
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strrchr_c
DESC: search a constant string backwards for a character
HEADER: util.h
PROTOTYPE:
    const char *CCutil_strrchr_c (const char *s, int c)
DESCRIPTION:
    RETURNS a pointer to the last occurrence of c in s, or NULL if c
    does not occur in s.  A variant for const strings.
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strdup
DESC: duplicate a string, allocating space for the copy
HEADER: util.h
PROTOTYPE:
    char *CCutil_strdup (const char *s)
DESCRIPTION:
    RETURNS a pointer to a copy of s, allocated with CC_SAFE_MALLOC,
    or NULL if unable to allocate space for the string
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_strdup2
DESC: duplicate a string, stopping at the first whitespace
HEADER: util.h
PROTOTYPE:
    char *CCutil_strdup2 (const char *s)
DESCRIPTION:
    RETURNS a pointer to a copy of s up until the first whitespace,
    allocated with CC_SAFE_MALLOC, or NULL if unable to allocate space
    for the string.
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_readstr
DESC: read a string, terminated by whitespace or EOF
HEADER: util.h
PROTOTYPE:
    void CCutil_readstr (FILE *f, char *s, int len)
DESCRIPTION:
    READS a string from f into s.  The string is terminated by a
    whitespace character (space, tab, newline) or EOF.  The entire
    string including the terminating character is read, but only at
    most len characters are stored in s, including the terminating
    NULL.
END_DESCRIPTION

FILENAME: UTIL/util.c
FUNCTION: CCutil_printlabel
DESC: print information identifying the host computer
HEADER: util.h
PROTOTYPE:
    void CCutil_printlabel (void)
DESCRIPTION:
    PRINTS information identifying a machine
END_DESCRIPTION

BEGINFILE: UTIL/urandom.c

FILENAME: UTIL/urandom.c
FUNCTION: CCutil_sprand
DESC: initialize the portable random number generator
HEADER: util.h
PROTOTYPE:
    void CCutil_sprand (int seed, CCrandstate *r)
DESCRIPTION:
    - Call once to initialize the generator.
END_DESCRIPTION

FILENAME: UTIL/urandom.c
FUNCTION: CCutil_lprand
DESC: get a random integer from the portable random number generator
HEADER: util.h
PROTOTYPE:
    int CCutil_lprand (CCrandstate *r)
DESCRIPTION:
    - Returns an integer in the range 0 to CC_PRANDMAX - 1.
END_DESCRIPTION

FILENAME: UTIL/urandom.c
FUNCTION: CCutil_normrand
DESC: get a normally distributed random variable
HEADER: util.h
PROTOTYPE:
    double CCutil_normrand (CCrandstate *r)
DESCRIPTION:
    - Returns a normally-distributed random value with mean 0 and
      deviation 1.
END_DESCRIPTION

BEGINFILE: UTIL/signal.c

FILENAME: UTIL/signal.c
FUNCTION: CCutil_signal_handler
DESC: specify a handler for a signal
HEADER: util.h
PROTOTYPE:
    int CCutil_signal_handler (int ccsignum, CCutil_handler handler)
DESCRIPTION:
     -ccsignum is one of the CCutil_SIG* values defined in util.h
     -handler is the new signal handler.
    INSTALLS handler as the handler for ccsignum signals.

    CCutil_handler is just a typedef for a pointer to a signal
    handling function.  It is a void (*)(int).  The signal handler
    is called whenever the signal is raised.  The integer argument
    passed to the signal handler is the signal number, in the
    operating system's numbering.  CCutil_sig_to_ccsig can be used
    to convert this signal number into a CCutil_SIG* value.
    CCutil_handler_fatal and CCutil_handler_warn are provided as
    signal handlers for two common cases.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_signal_default
DESC: restore the default handler for a signal
HEADER: util.h
PROTOTYPE:
    int CCutil_signal_default (int ccsignum)
DESCRIPTION:
     -ccsignum is one of the CCutil_SIG* values defined in util.h
    RESTORES the default handling for ccsignum signals.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_signal_ignore
DESC: ignores (blocks) a signal
HEADER: util.h
PROTOTYPE:
    int CCutil_signal_ignore (int ccsignum)
DESCRIPTION:
     -ccsignum is one of the CCutil_SIG* values defined in util.h
    IGNORES ccsignum signals.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_sig_to_ccsig
DESC: map O/S signal numbers to concorde signal numbers
HEADER: util.h
PROTOTYPE:
    int CCutil_sig_to_ccsig (int signum)
DESCRIPTION:
    CONVERTS a signal number from the operating system's terms to
    a CCutil_SIG* value.  If there is no corresponding value, returns
    -1.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_signal_init
DESC: initialize signal handling functions to the defaults
HEADER: util.h
PROTOTYPE:
    void CCutil_signal_init (void)
DESCRIPTION:
    INITIALIZES signal handlers to CCutil_handler_fatal,
    CCutil_handler_warn or CCutil_handler_exit as appropriate.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_handler_fatal
DESC: signal handler which outputs an error message, waits, then exits
HEADER: util.h
PROTOTYPE:
    void CCutil_handler_fatal (int signum)
DESCRIPTION:
    HANDLES a signal by printing an error message, waiting a long
    time to provide an opportunity to examine the program state with
    a debugger, and then exiting.  Designed to be used as a handler
    argument to CCutil_signal_handler.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_handler_warn
DESC: signal handler which outputs a warning message
HEADER: util.h
PROTOTYPE:
    void CCutil_handler_warn (int signum)
DESCRIPTION:
    HANDLES a signal by printing a warning message and continuing.
    Designed to be used as a handler argument to CCutil_signal_handler.
END_DESCRIPTION

FILENAME: UTIL/signal.c
FUNCTION: CCutil_handler_exit
DESC: signal handler which outputs a message and exits
HEADER: util.h
PROTOTYPE:
    void CCutil_handler_exit (int signum)
DESCRIPTION:
    HANDLES a signal by printing a warning message and exiting.
    Designed to be used as a handler argument to CCutil_signal_handler.
END_DESCRIPTION

BEGINFILE: UTIL/safe_io.c

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sopen
DESC: open a file for buffered binary I/O (CC_SFILE)
HEADER: util.h
PROTOTYPE:
    CC_SFILE *CCutil_sopen (char *f, char *s)
DESCRIPTION:
      Opens a file for buffered binary I/O.  The buffered binary I/O
      routines using CC_SFILE's attempt to be machine independent,
      and only compatible with themselves.  Comparable to the stdio
      routine fopen().  If the file already exists and is being
      opened for output, the old file is renamed by prepending an O
      to is name.
    f - the filename to open.  "stdin" means descriptor 0, "stdout"
        descriptor 1, and "stderr" descriptor 2.  "-" means
        descriptor 0 or 1, depending on wither the file is opened
        for reading or writing.
    s - the mode to open, either "r" for input, or "w" for output.
    returns a pointer to the opened file, or NULL if there is an
        error.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sdopen
DESC: open a descriptor for buffered binary I/O (CC_SFILE)
HEADER: util.h
PROTOTYPE:
    CC_SFILE *CCutil_sdopen (int d, char *s)
DESCRIPTION:
      Opens a descriptor for buffered binary I/O.  The buffered binary
      I/O routines using CC_SFILE's attempt to be machine independent,
      and only compatible with themselves.  Comparable to the stdio
      routine fdopen().
    d - the descriptor to open.
    s - the mode to open, either "r" for input, "w" for output, or
        "rw" for both input and output.
    returns a pointer to the opened file, or NULL if there is an
        error.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite
DESC: write data to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite (CC_SFILE *f, char *buf, int size)
DESCRIPTION:
      writes to a buffered binary I/O file.
    f - the CC_SFILE to write to
    buf - the data to write
    size - the number of bytes to write.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_bits
DESC: write bits to a CC_FILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_bits (CC_SFILE *f, int x, int xbits)
DESCRIPTION:
      writes bits to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - an int containing the data to write
    xbits - the number of bits to write.  The lowest order xbits
            bits of x will be written.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_ubits
DESC: write unsigned bits to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_ubits (CC_SFILE *f, unsigned int x, int xbits)
DESCRIPTION:
      writes bits to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - an unsigned int int containing the data to write
    xbits - the number of bits to write.  The lowest order xbits
            bits of x will be written.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_char
DESC: write a char to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_char (CC_SFILE *f, char x)
DESCRIPTION:
      writes a char to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the char to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_string
DESC: write a string to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_string (CC_SFILE *f, const char *s)
DESCRIPTION:
      writes a string to a buffered binary I/O file.
    f - the CC_SFILE to write to
    s - the string to write.  The array of characters in s up to and
        including the first NULL are written.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_short
DESC: write a short to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_short (CC_SFILE *f, short x)
DESCRIPTION:
      writes a short to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the short to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_ushort
DESC: write an unsigned short to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_ushort (CC_SFILE *f, unsigned short x)
DESCRIPTION:
      writes an unsigned short to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the unsigned short to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_int
DESC: write an int to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_int (CC_SFILE *f, int x)
DESCRIPTION:
      writes an int to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the int to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_uint
DESC: write an unsigned int to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_uint (CC_SFILE *f, unsigned int x)
DESCRIPTION:
      writes an unsigned int to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the unsigned int to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_swrite_double
DESC: write a double to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_swrite_double (CC_SFILE *f, double x)
DESCRIPTION:
      writes a double to a buffered binary I/O file.
    f - the CC_SFILE to write to
    x - the double to write
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread
DESC: read data from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread (CC_SFILE *f, char *buf, int size)
DESCRIPTION:
      reads from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    buf - a buffer in which to store the data read.  buf should have
          space for size characters.
    size - the number of bytes to read.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_bits
DESC: read bits from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_bits (CC_SFILE *f, int *x, int xbits)
DESCRIPTION:
      reads bits from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the bits read (in the low-order
        xbits bits).
    xbits - the number of bits read.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_ubits
DESC: read unsigned bits from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_ubits (CC_SFILE *f, unsigned int *x, int xbits)
DESCRIPTION:
      reads bits from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the bits read (in the low-order
        xbits bits).
    xbits - the number of bits read.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_char
DESC: read a char from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_char (CC_SFILE *f, char *x)
DESCRIPTION:
      reads a char from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the char read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_string
DESC: read a string from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_string (CC_SFILE *f, char *x, int maxlen)
DESCRIPTION:
      reads a string from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the string read.
    maxlen - the maximum number of characters to read.
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_short
DESC: read a short from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_short (CC_SFILE *f, short *x)
DESCRIPTION:
      reads a short from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the short read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_ushort
DESC: read an unsigned short from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_ushort (CC_SFILE *f, unsigned short *x)
DESCRIPTION:
      reads an unsigned short from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the unsigned short read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_short_r
DESC: read a reversed short from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_short_r (CC_SFILE *f, short *x)
DESCRIPTION:
      reads a reversed short from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the short read
    returns 0 if succesful, nonzero if failure.
    CCutil_sread_short_r is provided for compatability with some
    binary files written by other tools which use a different byte
    order.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_int
DESC: read an int from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_int (CC_SFILE *f, int *x)
DESCRIPTION:
      reads an int from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the int read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_uint
DESC: read an unsigned int from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_uint (CC_SFILE *f, unsigned int *x)
DESCRIPTION:
      reads an unsigned int from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the unsigned int read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_int_r
DESC: read a reversed int from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_int_r (CC_SFILE *f, int *x)
DESCRIPTION:
      reads a reversed int from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the int read
    returns 0 if succesful, nonzero if failure.
    CCutil_sread_int_r is provided for compatability with some
    binary files written by other tools which use a different byte
    order.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_double
DESC: read a double from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_double (CC_SFILE *f, double *x)
DESCRIPTION:
      reads a double from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the double read
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sread_double_r
DESC: read a reversed double from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sread_double_r (CC_SFILE *f, double *x)
DESCRIPTION:
      reads a reversed double from a buffered binary I/O file.
    f - the CC_SFILE to read from.
    x - on return, will contain the double read
    returns 0 if succesful, nonzero if failure.
    CCutil_sread_double_r is provided for compatability with some
    binary files written by other tools which use a different byte
    order.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sflush
DESC: flush the buffers of a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sflush (CC_SFILE *f)
DESCRIPTION:
      flushes the buffer of a buffered binary I/O file.
    f - the CC_SFILE to flush
    returns 0 if succesful, nonzero if failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_stell
DESC: report the current location in a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_stell (CC_SFILE *f)
DESCRIPTION:
      returns the current location in a buffered binary I/O file.
      Comparable to the stdio function ftell().
    f - the CC_SFILE
    returns the current location, or -1 for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sseek
DESC: set the location in a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sseek (CC_SFILE *f, int offset)
DESCRIPTION:
      changes the current location in a buffered binary I/O file.
      Comparable to the stdio function fseek().
    f - the CC_SFILE
    offset - a value returned by CCutil_stell().
    returns 0 for success, nonzero for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_srewind
DESC: rewind a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_srewind (CC_SFILE *f)
DESCRIPTION:
      changes the current location in a buffered binary I/O file to
      the beginning.  Comparable to the stdio function rewind().
    f - the CC_SFILE
    returns 0 for success, nonzero for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sclose
DESC: close a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_sclose (CC_SFILE *f)
DESCRIPTION:
      closes a CC_SFILE.
    f - the CC_SFILE to close
    returns 0 for success, nonzero for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sbits
DESC: compute the number of bits necessary to represent an integer
HEADER: util.h
PROTOTYPE:
    int CCutil_sbits (unsigned int x)
DESCRIPTION:
      computes the number of bits necessary to represent all
      nonnegative integers <= x
    x - a number
    returns the number of bits necessary to represent x.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sdelete_file
DESC: delete a file
HEADER: util.h
PROTOTYPE:
    int CCutil_sdelete_file (const char *fname)
DESCRIPTION:
      deletes a file.
    fname - the file to delete
    returns 0 for success, nonzero for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_sdelete_file_backup
DESC: delete the backup file created by a CCutil_sopen
HEADER: util.h
PROTOTYPE:
    int CCutil_sdelete_file_backup (const char *fname)
DESCRIPTION:
      deletes the backup file for fname (created if fname was
      overwritten by CCutil_sopen).
    fname - the file name whose backup is to be deleted.
    returns 0 for success, nonzero for failure.
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_snet_open
DESC: open a network CC_SFILE connection
HEADER: util.h
PROTOTYPE:
    CC_SFILE *CCutil_snet_open (char *h, unsigned short p)
DESCRIPTION:
      Opens a network connection to a port on a remote host
    h - the name of the host to connect to
    p - the port on the host to connect to
    returns a CC_SFILE (opened for input and output) for buffered
            binary I/O to the specified port on the remote host,
            or NULL if there is a failure.
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_snet_receive
DESC: receive a network CC_SFILE connection
HEADER: util.h
PROTOTYPE:
    CC_SFILE *CCutil_snet_receive (CC_SPORT *s)
DESCRIPTION:
      Accepts a network connection on a port.
    s - the CC_SPORT to accept a connection from.  Must be the
        returned result of a successfull CCutil_snet_listen call.
    returns a CC_SFILE (opened for input and output) for buffered
        binary I/O on the specified port, or NULL if there is a
        failure.
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_snet_listen
DESC: listen for network CC_SFILE connections
HEADER: util.h
PROTOTYPE:
    CC_SPORT *CCutil_snet_listen (unsigned short p)
DESCRIPTION:
      Prepares to accept network connections on a port.
    p - the port on which to accept connections.
    returns a CC_SPORT for accepting connections on the specified
        port.  This return value is passed to CCutil_snet_receive to
        accept a connection.  Returns NULL if there is a failure.
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: UTIL/safe_io.c
FUNCTION: CCutil_snet_unlisten
DESC: quit listening for network CC_SFILE connections
HEADER: util.h
PROTOTYPE:
    void CCutil_snet_unlisten (CC_SPORT *s)
DESCRIPTION:
      Ceases accepting network connections from an CC_SPORT.
    s - the CC_SPORT to close.
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

BEGINFILE: UTIL/priority.c

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_init
DESC: initialize a priority queue
HEADER: util.h
PROTOTYPE:
    int CCutil_priority_init (CCpriority *pri, int k)
DESCRIPTION:
    -h should point to a CCpriority struct.
    -k an initial allocation for the priority queue.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_free
DESC: free a priority queue
HEADER: util.h
PROTOTYPE:
    void CCutil_priority_free (CCpriority *pri)
DESCRIPTION:
    -frees the spaces allocated for the CCpriority queue.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_findmin
DESC: find the minimum in a priority queue
HEADER: util.h
PROTOTYPE:
    void *CCutil_priority_findmin (CCpriority *pri, double *keyval)
DESCRIPTION:
    -returns the entry with least key value.
    -returns NULL if no entries in heap.
    -if (keyval != NULL), *keyval will be the minimum key value.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_insert
DESC: insert an entry into a priority queue
HEADER: util.h
PROTOTYPE:
    int CCutil_priority_insert (CCpriority *pri, void *data,
        double keyval)
DESCRIPTION:
    -adds (data, keyval) to h.
    -returns a handle (>= 0) to use when deleting or changing the entry
    -returns -1 if out of memory.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_delete
DESC: delete an entry from a priority queue
HEADER: util.h
PROTOTYPE:
    void CCutil_priority_delete (CCpriority *pri, int handle)
DESCRIPTION:
    -deletes an entry from the queue.  handle is the value returned by
     CCutil_priority_insert.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_deletemin
DESC: delete and return the minimum entry in a priority queue
HEADER: util.h
PROTOTYPE:
    void *CCutil_priority_deletemin (CCpriority *pri, double *keyval)
DESCRIPTION:
    -like CCutil_priority_findmin, but also deletes the entry.
END_DESCRIPTION

FILENAME: UTIL/priority.c
FUNCTION: CCutil_priority_changekey
DESC: change the key of an entry in a priority queue
HEADER: util.h
PROTOTYPE:
    void CCutil_priority_changekey (CCpriority *pri, int handle,
        double newkey)
DESCRIPTION:
    -changes the key of an entry in the queue.  handle is the value
     returned by CCutil_priority_insert.
END_DESCRIPTION

BEGINFILE: UTIL/getdata.c

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getdata
DESC: build (by reading or generating) a CCdatagroup for computing edge lengths
HEADER: util.h
PROTOTYPE:
    int CCutil_getdata (char *datname, int binary_in, int innorm,
        int *ncount, CCdatagroup *dat, CCrandstate *rstate)
DESCRIPTION:
    RETURNS the data to generate edge lengths in the dat structure.
            The calling routine should be sure that dat points to
            a structure. If datname is NULL then random entries will be
            generated.
     -datname is the name of the datfile or the matrix file, if NULL
      then random data will be generated, according to the norm type.
      For D2 and D3 norms, the coordinates will be uniform between 0
      and ncount -1 (GEOGRAPHIC norms have x between -90 and 90 and y
      between -180 and 180). (For D2, the points will be distinct.)
      For MATRIX norms, the entries will be
      uniform between 0 and MATRAND_SCALE * ncount - 1 (currently
      10*ncount - 1. For CRYSTAL norms, a random matrix and bounds in
      range of the TSPLIB problems is generated - the wavelength is
      chosen to be 1.0, 1.35, or 1.70 depending on the ncount (but the
      problem will not be very close to hitting ncount.).
     -binary_in should be 1 if the datname file is in binary integers.
     -innorm is the norm.
     -ncount will return the number of nodes. If datname is NULL, then
      ncount should be passed in with the number of nodes to be used in
      the random problem generation.
     -dat will contain the info to call the edgelen function.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_putmaster
DESC: write a problem master file
HEADER: util.h
PROTOTYPE:
    int CCutil_putmaster (char *mastername, int ncount, CCdatagroup *dat,
        int *perm)
DESCRIPTION:
    WRITES the dat information and the permutation into a binary file.
           This is used in the TSP, where the dat file has usually
           been permuted to put the nodes into tour order.
     -mastername is the name of the file (cannot be NULL)
     -ncount is the number of nodes
     -dat contains the edgelen info (e.g. x,y coordinates), it can be
      NULL
     -perm contains a permutation of 0 to ncount - 1 (so a tour in
      node node node format)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writemaster
DESC: write the problem master data to a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_writemaster (CC_SFILE *out, int ncount, CCdatagroup *dat,
        int *perm)
DESCRIPTION:
    WRITES the dat information and the permutation into a binary file.
           This is used in the TSP, where the dat file has usually
           been permuted to put the nodes into tour order.
     -f is the CC_SFILE to write into
     -ncount is the number of nodes
     -dat contains the edgelen info (e.g. x,y coordinates), it can be
      NULL
     -perm contains a permutation of 0 to ncount - 1 (so a tour in
      node node node format)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getmaster
DESC: read a problem master file
HEADER: util.h
PROTOTYPE:
    int CCutil_getmaster (char *mastername, int *ncount, CCdatagroup *dat,
        int **perm)
DESCRIPTION:
    RETURNS the dat information and the permutation from a binary file
            (written by a call to CCutil_writemaster). Used by the TSP
            code.
     -mastername is the name of the file (cannot be NULL)
     -ncount returns the number of nodes
     -dat returns the edgelen info (e.g. x,y coordinates), or NULL
     -perm returns a permutation of 0 to ncount - 1 (so a tour in
      node node node format)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_readmaster
DESC: read the problem master data from a CC_SFILE
HEADER: util.h
PROTOTYPE:
    int CCutil_readmaster (CC_SFILE *in, int *ncount, CCdatagroup *dat,
        int **perm)
DESCRIPTION:
    RETURNS the dat information and the permutation from a binary file
            (written by a call to CCutil_writemaster). Used by the TSP
            code.
     -f is the CC_SFILE to read from
     -ncount returns the number of nodes
     -dat returns the edgelen info (e.g. x,y coordinates), or NULL
     -perm returns a permutation of 0 to ncount - 1 (so a tour in
      node node node format)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getnodeweights
DESC: read (or generate) node weights
HEADER: util.h
PROTOTYPE:
    int CCutil_getnodeweights (char *weightname, int ncount,
        int weight_limit, double **wcoord, CCrandstate *rstate)
DESCRIPTION:
    RETURNS a list of nonnegative nodesweights (they will be translated
            if the weightname file has negative entries). If weightname
            is NULL then random entries (from 0 to ncount - 1 will be
            generated.
     -weightname is the name of a file containing nodeweights. It will
      only be read if inusenodeweights is 1. If NULL, random entries
      will be generated (between 0 and weight_limit - 1)
     -wcoord will contain the nonnegative node weights (it will be
      here in CCutil_getnodeweights)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_gettsplib
DESC: read a TSPLIB instance
HEADER: util.h
PROTOTYPE:
    int CCutil_gettsplib(char *datname, int *ncount, CCdatagroup *dat)
DESCRIPTION:
    READS an xxx.tsp TSPLIB file, and returns the dat structure to
            generate edge lengths.
     -datname should be the name of a TSPLIB xxx.tsp file.
     -ncount returns the number of nodes.
     -dat returns the data.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writetsplib
DESC: write a TSPLIB instance
HEADER: util.h
PROTOTYPE:
    int CCutil_writetsplib (const char *fname, int ncount,
        CCdatagroup *dat)
DESCRIPTION:
    WRITES a TSPLIB file for the instance specified by dat.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getedgelist
DESC: read an edgelist, verifying ncount
HEADER: util.h
PROTOTYPE:
    int CCutil_getedgelist (int ncount, char *fname, int *ecount,
        int **elist, int **elen, int binary_in)
DESCRIPTION:
    READS an edgelist in end1 end2 length format.
     -fname name of the file
     -ecount returns the number of edges
     -elist returns the edges in end1 end2 format (it will be allocated
      by CCutil_getedgelist)
     -elen returns the length of the edges in len len len format
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getedgelist_n
DESC: read an edgelist, reading ncount
HEADER: util.h
PROTOTYPE:
    int CCutil_getedgelist_n (int *ncount, char *fname, int *ecount,
        int **elist, int **elen, int binary_in)
DESCRIPTION:
    READS an edgelist in end1 end2 length format.
    Like CCutil_getedgelist (), but it also returns ncount.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_genedgelist
DESC: generate a random edge list
HEADER: util.h
PROTOTYPE:
    int CCutil_genedgelist (int ncount, int ecount, int **elist,
        int **elen, CCdatagroup *dat, int maxlen, CCrandstate *rstate)
DESCRIPTION:
    GENERATES a random graph with ncount nodes and ecount edges, with
     with edgelengths either determined by dat or random between 0 and
     maxlen-1.
     -dat specifies the function for computing the edge lengths (it can
      be NULL.
     -maxlen gives the range for random edge lengths (it is used if dat
      is NULL.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getcycle_edgelist
DESC: read a cycle in edge list format
HEADER: util.h
PROTOTYPE:
    int CCutil_getcycle_edgelist (int ncount, char *cyclename,
        int *outcycle, int binary_in)
DESCRIPTION:
    READS a cycle in end1 end2 length format, and returns the cycle in
            node node format in the array outcycle.
     -outcycle should be allocated by the calling routine (and should
      be at least ncount long)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getcycle
DESC: read a cycle in permutation format
HEADER: util.h
PROTOTYPE:
    int CCutil_getcycle (int ncount, char *cyclename, int *outcycle,
        int binary_in)
DESCRIPTION:
    READS a cycle in node node format, and returns the cycle in node
            node format in the array outcycle.
     -outcycle should be allocated by the calling routine
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_cycle_len
DESC: compute the length of a tour
HEADER: util.h
PROTOTYPE:
    void CCutil_cycle_len (int ncount, CCdatagroup *dat, int *cycle,
        double *len)
DESCRIPTION:
    COMPUTES the length of a cycle (in permutation format).
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_getedges_double
DESC: read an edgelist with floating-point lengths
HEADER: util.h
PROTOTYPE:
    int CCutil_getedges_double (int *ncount, char *fname, int *ecount,
        int **elist, double **elen, int binary_in)
DESCRIPTION:
    READS the edgelist in end1 end2 length format, where the length
            is a double (used for x-vectors)
     -returns the number of nodes
     -fname is the name of the file to read.
     -ecount returns the number of edges.
     -elist returns the list of edges in end1 end2 format (it will be
      allocated by CCutil_getedges_double).
     -elen returns the lengths of the edges.
     -binary_in indicates whether the file should be read in binary
      or in ascii (1 is binary, 0 is ascii)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writeedges
DESC: write an edgelist
HEADER: util.h
PROTOTYPE:
    int CCutil_writeedges (int ncount, char *outedgename, int ecount,
        int *elist, CCdatagroup *dat, int binary_out)
DESCRIPTION:
    WRITES the edgelist in end1 end2 length format.
     -ncount the number of nodes
     -outedgename is the name of the file to write to.
     -ecount is the number of edges.
     -elist is the list of edges in end1 end2 format.
     -dat contains the data to compute edgelengths.
     -binary_in indicates whether the file should be written in binary
      or in ascii (1 is binary, 0 is ascii)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writecycle_edgelist
DESC: write a cycle in edgelist format
HEADER: util.h
PROTOTYPE:
    int CCutil_writecycle_edgelist (int ncount, char *outedgename,
        int *cycle, CCdatagroup *dat, int binary_out)
DESCRIPTION:
    WRITES the cycle in edgelist format.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writecycle
DESC: write a cycle in permutation format
HEADER: util.h
PROTOTYPE:
    int CCutil_writecycle (int ncount, char *outcyclename, int *cycle,
        int binary_out)
DESCRIPTION:
    WRITES the cycle in node node node format.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writeedges_int
DESC: write an edgelist, specifying the lengths
HEADER: util.h
PROTOTYPE:
    int CCutil_writeedges_int (int ncount, char *outedgename, int ecount,
        int *elist, int *elen, int binary_out)
DESCRIPTION:
    WRITES the edgelist in end1 end2 length format.
    Like CCutil_writeedges, but lengths are specified in elen.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_writeedges_double
DESC: write an edgelist, specifying the lengths in floating point
HEADER: util.h
PROTOTYPE:
    int CCutil_writeedges_double (int ncount, char *outedgename,
        int ecount, int *elist, double *elen, int binary_out)
DESCRIPTION:
    WRITES the edgelist in end1 end2 length format, where the length
            is a double (used for x-vectors)
     -ncount the number of nodes
     -outedgename is the name of the file to write to.
     -ecount is the number of edges.
     -elist is the list of edges in end1 end2 format.
     -elen are the lengths of the edges.
     -binary_out indicates whether the file should be written in binary
        or in ascii (1 is binary, 0 is ascii)
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_datagroup_perm
DESC: permute a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_datagroup_perm (int ncount, CCdatagroup *dat, int *perm)
DESCRIPTION:
    reorders the nodes to match the order given in perm.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_copy_datagroup
DESC: copy a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_copy_datagroup (int ncount, CCdatagroup *indat,
        CCdatagroup *outdat)
DESCRIPTION:
    COPIES indat to outdat.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_tri2dat
DESC: convert an upper triangular matrix of edge lengths to a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_tri2dat (int ncount, int *elen, CCdatagroup *dat)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_graph2dat_matrix
DESC: convert a matrix of edge lengths to a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_graph2dat_matrix (int ncount, int ecount, int *elist,
        int *elen, int defaultlen, CCdatagroup *dat)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_graph2dat_sparse
DESC: convert a sparse edge list to a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_graph2dat_sparse (int ncount, int ecount, int *elist,
        int *elen, int defaultlen, CCdatagroup *dat)
DESCRIPTION:
    BUILDS a datagroup from the edge list using the CC_SPARSE norm.
     -dat will be filled in by the function.
     -defaultlen gives the value for the non-edges (if it is <= 0, then
      a default value of (max_edgelen + 1) * nnodes if fiven).
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_get_sparse_dat_edges
DESC: convert a CCdatagroup of norm CC_SPARSE to a sparse edge list
HEADER: util.h
PROTOTYPE:
    int CCutil_get_sparse_dat_edges (int ncount, CCdatagroup *dat,
        int *ecount, int **elist, int **elen)
DESCRIPTION:
    GRABS the enitre set of edges in a CC_SPARSE datagroup.  It returns
      an error if the datagroup norm is not CC_SPARSE.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_sparse_strip_edges
DESC: remove the artifical edges from an edge list
HEADER: util.h
PROTOTYPE:
    int CCutil_sparse_strip_edges (CCdatagroup *dat, int in_ecount,
        int *in_elist, int *in_elen, int *ecount, int **elist, int **elen)
DESCRIPTION:
    REMOVES the artifical edges from in_elist.
     -ecount, elist, and elen return the stripped edgelist.
END_DESCRIPTION

FILENAME: UTIL/getdata.c
FUNCTION: CCutil_sparse_real_tour
DESC: check to see if every edge in a cycle is in a CC_SPARSE datagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_sparse_real_tour (int ncount, CCdatagroup *dat, int *cyc,
        int *yesno)
DESCRIPTION:
    CHECKS whether each edge of cyc is in the CC_SPARSE datagroup.
     -cyc gives a tour in node node node format.
     -yesno will be set to 1 if it is a tour, and 0 otherwise.
END_DESCRIPTION

BEGINFILE: UTIL/genhash.c

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_init
DESC: initialize a generic hash table
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_init (CCgenhash *h, int size,
        int (*hcmp) (void *key1, void *key2, void *u_data),
        unsigned int (*hfunc) (void *key, void *u_data),
        void *u_data, double maxdensity, double lowdensity)
DESCRIPTION:
    -CCgenhash *h (a pointer to a CCgenhash structure to be
     initialized)
    -int size (the initial size of the hash table)
    -int (*hcmp) (void *key1, void *key2, void *u_data) (a pointer to
     a function which returns 0 if key1 == key2, nonzero otherwise.
     u_data will be the u_data passed to CCutil_genhash_init)
    -unsigned int (*hfunc) (void *key, void *u_data) (a pointer to a
     function which computes a hash function of key.  u_data will be
     the u_data passed to CCutil_genhash_init)
    -void *u_data (a pointer which will be passed into hcmp and hfunc)
    -double maxdensity (the maximum density (# elems / size) for the
     hash table.  When this density is reached the hash table is
     expanded.  0.0 means never expand the hash table)
    -double lowdensity (the density of a hash table immediately after
     expansion)
     RETURNS 0 for success, -1 if out of memory.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_free
DESC: free a generic hash table
HEADER: util.h
PROTOTYPE:
    void CCutil_genhash_free (CCgenhash *h, void (*freefunc)(void *k,
        void *d, void *u_data))
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void (*freefunc)(void *key, void *data, void *u_data) (a pointer
     to a function to be called for each (key, data) pair in the
     hashtable, or NULL)
     ACTION: deletes all entries in h, and frees the space for h.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_u_data
DESC: change the user data stored with a generic hash table
HEADER: util.h
PROTOTYPE:
    void CCutil_genhash_u_data (CCgenhash *h, void *u_data)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *u_data (a new value for u_data)
     ACTION: changes the u_data stored with the hash table, and
     passed to hcomp and hfunc)
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_insert
DESC: insert an entry into a generic hash table
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_insert (CCgenhash *h, void *key, void *data)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *key (a pointer to the key data for this entry)
    -void *data (the data to be stored)
     ACTION: h[key] = data
     COMMENT: if h[key] already has a value, this acts like a stack
              CCutil_genhash_delete(key) will reveal the old value.
     RETURNS 0 for success, -1 if out of memory.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_replace
DESC: replace an entry in a generic hash table
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_replace (CCgenhash *h, void *key, void *data)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *key (a pointer to the key data for this entry)
    -void *data (the data to be stored)
     ACTION: h[key] = data
     COMMENT: if h[key] already has a value, this replaces that
              value.
     RETURNS 0 for success, -1 if out of memory.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_delete
DESC: delete an entry from a generic hash table
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_delete (CCgenhash *h, void *key)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *key (a pointer to the key data for this entry)
     ACTION: h[key] = NULL
     RETURNS 0 for success, -1 if h[key] was already NULL
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_lookup
DESC: look up an entry in a generic hash table
HEADER: util.h
PROTOTYPE:
    void *CCutil_genhash_lookup (CCgenhash *h, void *key)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *key (a pointer to the key data for this entry)
     RETURNS h[key], or NULL if h[key] not defined
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_hash
DESC: compute the hash function of a key in a generic hash table
HEADER: util.h
PROTOTYPE:
    unsigned int CCutil_genhash_hash (CCgenhash *h, void *key)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -void *key (a pointer to key data)
     RETURNS the hash function of key (ie, h->hfunc(key))
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_insert_h
DESC: insert an entry into a generic hash table (given the hash value)
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_insert_h (CCgenhash *h, unsigned int hashval,
        void *key, void *data)
DESCRIPTION:
    alternate version of CCutil_genhash_insert, which takes an
    additional argument, hashval, which should be equal to
    CCutil_genhash_hash(key).  This provides a method to avoid
    recomputing CCutil_genhash_hash over multiple calls with the same
    key
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_replace_h
DESC: replace an entry in a generic hash table (given the hash value)
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_replace_h (CCgenhash *h, unsigned int hashval,
        void *key, void *data)
DESCRIPTION:
    alternate version of CCutil_genhash_replace, which takes an
    additional argument, hashval, which should be equal to
    CCutil_genhash_hash(key).  This provides a method to avoid
    recomputing CCutil_genhash_hash over multiple calls with the same
    key.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_delete_h
DESC: delete an entry from a generic hash table (given the hash value)
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_delete_h (CCgenhash *h, unsigned int hashval,
        void *key)
DESCRIPTION:
    alternate version of CCutil_genhash_delete, which takes an
    additional argument, hashval, which should be equal to
    CCutil_genhash_hash(key).  This provides a method to avoid
    recomputing CCutil_genhash_hash over multiple calls with the same
    key.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_lookup_h
DESC: look up an entry in a generic hash table (given the hash value)
HEADER: util.h
PROTOTYPE:
    int CCutil_genhash_lookup_h (CCgenhash *h, unsigned int hashval,
        void *key)
DESCRIPTION:
    alternate version of CCutil_genhash_lookup, which takes an
    additional argument, hashval, which should be equal to
    CCutil_genhash_hash(key).  This provides a method to avoid
    recomputing CCutil_genhash_hash over multiple calls with the same
    key.
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_start
DESC: begin iterating over the elements of a generic hash table
HEADER: util.h
PROTOTYPE:
    void CCutil_genhash_start (CCgenhash *h, CCgenhash_iter *iter)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -CCgenhash_iter *iter (a pointer to the iterator to be
     initialized)
     ACTION: initializes iter for iterating over elements of h using
             CCutil_genhash_next()
END_DESCRIPTION

FILENAME: UTIL/genhash.c
FUNCTION: CCutil_genhash_next
DESC: move the iterator over a generic hash table to the next element
HEADER: util.h
PROTOTYPE:
    void *CCutil_genhash_next (CCgenhash *h, CCgenhash_iter *iter,
        void **key, int *keysize)
DESCRIPTION:
    -CCgenhash *h (a pointer to the hash table)
    -CCgenhash_iter *iter (a pointer to an iterator)
    -void **key (a pointer to a location for the key value)
    -int *keysize (a pointer to a location for the key size)
     RETURNS: a next data value from the hash table (corresponding
              to the returned key and keysize), or NULL if there
              are no more elements.
    CCutil_genhash_next can tolerate the deletion of the current
    (last returned) element and arbitrary lookups and replaces
    between calls to CCutil_genhash_next.  However, deletion of
    elements other than the current one are not permitted, and
    insertion a table which could be expanded can result in
    elements being skipped.
END_DESCRIPTION

BEGINFILE: UTIL/fastread.c

FILENAME: UTIL/fastread.c
FUNCTION: CCutil_readint
DESC: read an integer quickly
HEADER: util.h
PROTOTYPE:
    int CCutil_readint (FILE *f)
DESCRIPTION:
      - Returns the next int in the file f.
    This is much faster that scanf. It is useful for big files and
    and for profiling.
END_DESCRIPTION

BEGINFILE: UTIL/eunion.c

FILENAME: UTIL/eunion.c
FUNCTION: CCutil_edge_file_union
DESC: read several edge lists and merge the results
HEADER: util.h
PROTOTYPE:
    int CCutil_edge_file_union (int ncount, int nfiles, char **flist,
        int *ecount, int **elist, int **elen, int *foundtour,
        int *besttourlen)
DESCRIPTION:
    MERGES a list of edge sets.
     -ncount is the number of nodes.
     -nfiles is the number of files to be read.
     -flist is the list of the files.
     -ecount, elist, elen returns the merged edge set.
     -foundtour will return a 1 if at least one of the files is the
      edgeset of a tour (it can be NULL).
     -besttour will return the length of the best tour amongst the
      edge sets (it can be NULL)
     Returns a nonzero value if there was and error.
END_DESCRIPTION

BEGINFILE: UTIL/edgeutil.c

FILENAME: UTIL/edgeutil.c
FUNCTION: CCutil_edge_to_cycle
DESC: convert an edge list to a cycle
HEADER: util.h
PROTOTYPE:
    int CCutil_edge_to_cycle (int ncount, int *elist, int *yesno,
        int *cyc)
DESCRIPTION:
    CONVERTS an edgelist to a cycle.
     -ncount is the number of nodes.
     -elist is an edgelist in end1 end2 format.
     -yesno returns 1 if elist describes a tour and 0 otherwise.
     -cyc returns the cycle in permutation format if it is not NULL
      (if cyc is not NULL, then it should point to an array of
      length at least ncount).
     Returns a nonzero value if there was an error.
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelist_init
DESC: initialize a CCelist
HEADER: util.h
PROTOTYPE:
    void CCelist_init (CCelist *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistl_init
DESC: initialize a CCelistl
HEADER: util.h
PROTOTYPE:
    void CCelistl_init (CCelistl *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistw_init
DESC: initialize a CCelistw
HEADER: util.h
PROTOTYPE:
    void CCelistw_init (CCelistw *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistlw_init
DESC: initialize a CCelistlw
HEADER: util.h
PROTOTYPE:
    void CCelistlw_init (CCelistlw *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelist_free
DESC: free a CCelist
HEADER: util.h
PROTOTYPE:
    void CCelist_free (CCelist *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistl_free
DESC: free a CCelistl
HEADER: util.h
PROTOTYPE:
    void CCelistl_free (CCelistl *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistw_free
DESC: free a CCelistw
HEADER: util.h
PROTOTYPE:
    void CCelistw_free (CCelistw *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistlw_free
DESC: free a CCelistlw
HEADER: util.h
PROTOTYPE:
    void CCelistlw_free (CCelistlw *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelist_alloc
DESC: allocate space for a CCelist
HEADER: util.h
PROTOTYPE:
    int CCelist_alloc (CCelist *elist, int ecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistl_alloc
DESC: allocate space for a CCelistl
HEADER: util.h
PROTOTYPE:
    int CCelistl_alloc (CCelistl *elist, int ecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistw_alloc
DESC: allocate space for a CCelistw
HEADER: util.h
PROTOTYPE:
    int CCelistw_alloc (CCelistw *elist, int ecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgeutil.c
FUNCTION: CCelistlw_alloc
DESC: CCelistlw
HEADER: util.h
PROTOTYPE:
    int CCelistlw_alloc (CCelistlw *elist, int ecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: UTIL/edgelen.c

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_dat_setnorm
DESC: set the norm for a CCdatagroup
HEADER: util.h
PROTOTYPE:
    int CCutil_dat_setnorm (CCdatagroup *dat, int norm)
DESCRIPTION:
     NOTES:
         Supported norms (with defs in edgelen.h) are:
             CC_MAXNORM  -  the L-infinity norm
             CC_EUCLIDEAN_CEIL - the norm for the plaXXXX problems
             CC_EUCLIDEAN - rounded L-2 norm
             CC_EUCLIDEAN_3D - rounded L-2 norm in 3 space
             CC_USER - a norm specified by the user
             CC_GEOGRAPHIC - distances on a sphere (Groetshel and
                             Holland)
             CC_ATT - pseudo-Euclidean norm for att532
             CC_MATRIXNORM - complete graph (lower + diagonal matrix)
             CC_DSJRANDNORM - random edgelengths
             CC_CRYSTAL - Bland-Shallcross xray norm
                     - The coordinates generated for CC_CRYSTAL problems
                (in CCutil_getdata.c) have been diveded by the motor
                speeds (this makes the edgelen function faster) and
                scaled by CRYSTAL_SCALE (currently 10000) and rounded to
                the nearest integer (this lets the edgelen function
                produce integer lengths without further rounding). The
                result is a closer approximation to the Bland -
                Shallcross floating point length function than that
                given in TSPLIB_1.2.
             CC_SPARSE - a sparse graph
             CC_RHMAPx - where x = 1, 2, 3, 4, 5 one of 5 RH mapping
                norms.

         If CCUTIL_EDGELEN_FUNCTIONPTR has been defined in util.h,
         then CCutil_dat_edgelen is a pointer to a function instead of
         a function.  This saves a function call and results in
         improved performance on some machines for edgelen-intensive
         routines like linkern.  The function pointer is set by
         CCutil_dat_setnorm.

         IMPORTANT: This means that if CCUTIL_EDGELEN_FUNCTIONPTR is set
         and you have more than one CCdatagroup, you must call
         CCutil_dat_setnorm whenever you switch from using one
         CCdatagroup to the other.  IF YOU DON'T DO THIS, EDGELEN WILL
         RETURN INCORRECT RESULTS.  For this reason,
         CCUTIL_EDGELEN_FUNCTIONPTR should only be set with extreme
         caution.

    To define a user norm, you must perform the following steps:
    1.  In util.h, define the struct CCdata_user to contain the data
        necessary for the computation of edge lengths.
    2.  In edgelen.c, write the init_userdat and free_userdat functions
        which initialize and free a CCdata_user structure.
    3.  In edgelen.c, write the user_edgelen function which
        computes the length of the edge for node i to node j, using the
        userdat field of the CCdatagroup argument (userdat is of type
        CCdata_user).
    4.  In getdata.c, write the build_user, read_user_text,
        read_user_binary, readmaster_user, and writemaster_user
        routines.  read_user_text reads the data file which provides
        the data for computing the edge lengths.  build_user and
        read_user_binary are optional routines which build random
        datasets and read binary datafiles.  writemaster_user writes a
        binary version of that data to the master file, and
        readmaster_user reads that same data.  See the comments before
        those routines in getdata for more details on what they should
        do.
    5.  In getdata.c, write permute_user, which permutes the data to
        reflect a permutation of the nodes.
END_DESCRIPTION

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_dat_edgelen
DESC: compute the length of an edge
HEADER: util.h
PROTOTYPE:
    int CCutil_dat_edgelen (int i, int j, CCdatagroup *dat)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_dsjrand_init
DESC: initialize the dsjrand norm
HEADER: util.h
PROTOTYPE:
    void CCutil_dsjrand_init (CCdatagroup *dat, int maxdist, int seed)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_dat_getnorm
DESC: get the norm of a CCdatagroup
HEADER: util.h
PROTOTYPE:
    void CCutil_dat_getnorm (CCdatagroup *dat, int *norm)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_init_datagroup
DESC: initialize a CCdatagroup
HEADER: util.h
PROTOTYPE:
    void CCutil_init_datagroup (CCdatagroup *dat)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgelen.c
FUNCTION: CCutil_freedatagroup
DESC: free a CCdatagroup
HEADER: util.h
PROTOTYPE:
    void CCutil_freedatagroup (CCdatagroup *dat)
DESCRIPTION:
    NONE
END_DESCRIPTION

BEGINFILE: UTIL/dheaps_i.c

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_init
DESC: initialize a d-heap
HEADER: util.h
PROTOTYPE:
    int CCutil_dheap_init (CCdheap *h, int k)
DESCRIPTION:
        -h should point to a CCdheap struct.
        -k the max number of elements in the dheap.
    NOTES:
        A k-element heap will malloc 16k bytes of memory. If memory is
    tight, using integer keys (instead of doubles), brings it down to
    12k bytes, and if arbitrary deletions are not required, with a
    little rewriting, the h->loc field can be eliminated, bring the
    space down to 8k bytes.
        These routines work with indices into the h->key array, so in
    some cases, you will need to maintain a separate names array to know
    what element belongs to index i. For an example, see the k_nearest
    code in kdnear.c.
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_free
DESC: free a d-heap
HEADER: util.h
PROTOTYPE:
    void CCutil_dheap_free (CCdheap *h)
DESCRIPTION:
    -frees the spaces allocated by CCutil_dheap_init
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_resize
DESC: resize a d-heap
HEADER: util.h
PROTOTYPE:
    int CCutil_dheap_resize (CCdheap *h, int newsize)
DESCRIPTION:
    -REALLOCs h so it can contain newsize elements.
    -returns -1 if it can't resize the heap.
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_findmin
DESC: find the minimum entry in a d-heap
HEADER: util.h
PROTOTYPE:
    int CCutil_dheap_findmin (CCdheap *h)
DESCRIPTION:
    -returns the index of the element with min value h->key[i]
    -returns -1 if no elements in heap.
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_insert
DESC: insert an entry into a d-heap
HEADER: util.h
PROTOTYPE:
    int CCutil_dheap_insert (CCdheap *h, int i)
DESCRIPTION:
    -inserts the element with index i (so its key should be loaded
     beforehand in h->key[i]).
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_delete
DESC: delete an entry from a d-heap
HEADER: util.h
PROTOTYPE:
    void CCutil_dheap_delete (CCdheap *h, int i)
DESCRIPTION:
    -deletes the element with index i.
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_deletemin
DESC: delete and return the minimum entry in a d-heap
HEADER: util.h
PROTOTYPE:
    int CCutil_dheap_deletemin (CCdheap *h)
DESCRIPTION:
    -returns the min element in the heap, and deletes the min element
    -returns -1 if no elements in heap.
END_DESCRIPTION

FILENAME: UTIL/dheaps_i.c
FUNCTION: CCutil_dheap_changekey
DESC: change the key of an entry in a d-heap
HEADER: util.h
PROTOTYPE:
    void CCutil_dheap_changekey (CCdheap *h, int i, double newkey)
DESCRIPTION:
    -changes the key of the element with index i to newkey.
END_DESCRIPTION

BEGINFILE: UTIL/bgetopt.c

FILENAME: UTIL/bgetopt.c
FUNCTION: CCutil_bix_getopt
DESC: parse an argument list
HEADER: util.h
PROTOTYPE:
    int CCutil_bix_getopt (int argc, char **argv, const char *def,
        int *p_optind, char **p_optarg)
DESCRIPTION:
    NONE
END_DESCRIPTION

BEGINFILE: UTIL/allocrus.c

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_allocrus
DESC: allocate a block of memory
HEADER: util.h
PROTOTYPE:
    void *CCutil_allocrus (size_t size)
DESCRIPTION:
    RETURNS a pointer to an allocated block of "size" memory.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_freerus
DESC: free a block of memory
HEADER: util.h
PROTOTYPE:
    void CCutil_freerus (void *ptr)
DESCRIPTION:
    FREES ptr.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_reallocrus
DESC: change the size of an allocated block of memory
HEADER: util.h
PROTOTYPE:
    void *CCutil_reallocrus (void *ptr, size_t size)
DESCRIPTION:
    REALLOCS ptr to size bytes.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_reallocrus_scale
DESC: change the size of an allocated block of memory by a scale factor
HEADER: util.h
PROTOTYPE:
    int CCutil_reallocrus_scale (void **pptr, int *pnnum, int count,
        double scale, size_t size)
DESCRIPTION:
    void **pptr (a reference to the pointer to the allocated space)
    int *pnnum (a reference to the number of objects in the
                allocated space)
    int count (a minimum value for the new nnum)
    double scale (a scale factor to apply to nnum)
    int size (the size of objects to be realloced)
    RETURNS 0 if *pptr was successfully changed to point to at
            least max(*pnnum*scale, *pnnum+1000, count) objects.
            *pnnum is changed to the new object count.
            Otherwise, prints an error message, leaves *pptr and
            *pnnum alone, and returns nonzero.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_reallocrus_count
DESC: change the size of an allocated block of memory to a specified count
HEADER: util.h
PROTOTYPE:
    int CCutil_reallocrus_count (void **pptr, int count,
        size_t size)
DESCRIPTION:
    void **pptr (a reference to the pointer to the allocated space)
    int count (number of objects to be realloced)
    int size (the size of the objects to be realloced)
    RETURNS 0 is successful, and 1 if the realloc failed.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_bigchunkalloc
DESC: allocate a CCbigchunk
HEADER: util.h
PROTOTYPE:
    CCbigchunkptr *CCutil_bigchunkalloc (void)
DESCRIPTION:
         RETURNS a CCbigchunkptr with the "this_one" field loaded with a
                 a pointer to a bigchunk of memory.
    NOTES:
       The idea is to use bigchunks (the size of a bigchunk is defined
       by CC_BIGCHUNK in util.h) to supply local routines with memory
       for ptrs, so the memory can be shared with other
       local routines.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCutil_bigchunkfree
DESC: free a CCbigchunk
HEADER: util.h
PROTOTYPE:
    CCutil_bigchunkfree (CCbigchunkptr *bp)
DESCRIPTION:
    ACTION: Frees a CCbigchunkptr.
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCptrworld_init
DESC: initialize a CCptrworld with 1 reference
HEADER: util.h
PROTOTYPE:
    void CCptrworld_init (CCptrworld *world)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCptrworld_add
DESC: add a reference to a CCptrworld
HEADER: util.h
PROTOTYPE:
    void CCptrworld_add (CCptrworld *world)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/allocrus.c
FUNCTION: CCptrworld_delete
DESC: delete a reference to a ptrworld, and free if no more references
HEADER: util.h
PROTOTYPE:
    void CCptrworld_delete (CCptrworld *world)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TSP/xtour.c

FILENAME: TSP/xtour.c
FUNCTION: CCtsp_x_greedy_tour
DESC: find a tour by adding in edges by nonincreasing x value
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_x_greedy_tour (CCdatagroup *dat, int ncount, int ecount,
        int *elist, double *x, int *cyc, double *val, int silent)
DESCRIPTION:
    FINDS a tour by adding in edges by nonincreasing x-value.
     -cyc should be an array of length at least ncount
     -val returns the length of the tour
END_DESCRIPTION

FILENAME: TSP/xtour.c
FUNCTION: CCtsp_x_greedy_tour_lk
DESC: find an x-greedy tour and then run a short Lin-Kernighan
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_x_greedy_tour_lk (CCdatagroup *dat, int ncount, int ecount,
        int *elist, double *x, int *cyc, double *val, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    FINDS the x-greedy tour then calls a short LK.
END_DESCRIPTION

BEGINFILE: TSP/tsp_lp.c

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_init_tsp_lp_struct
DESC: initialize a CCtsp_lp
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_tsp_lp_struct (CCtsp_lp *lp)
DESCRIPTION:
    INITIALIZES the CCtsp_lp struture with NULL values
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_free_tsp_lp_struct
DESC: free a CCtsp_lp
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_tsp_lp_struct (CCtsp_lp **lp)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_init_lp
DESC: build/read an initial problem in a CCtsp_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_init_lp (CCtsp_lp **lp, char *probloc, int probnum,
        char *probfilename, int ncount, CCdatagroup *dat, int ecount,
        int *elist, int *elen, int excount, int *exlist, int *exlen,
        int exvalid, int *ptour, double initial_ub,
        CCtsp_lpcuts *pool, int silent, CCrandstate *rstate)
DESCRIPTION:
    BUILDS/READS the problem, and loads it into the LP solver. If
     probnum < 0, init_lp will build an initial problem according to
     elist and elen; otherwise it will read the problem from disk. If
     the problem is read from disk, then the elist is ignored.
     -lp is a handle to the tsp lp (filled in by init_lp)
     -probname is the name for the problem
     -probnum is the number for the problem
     -ncount is the number of nodes
     -dat is a handle on the complete graph
     -ecount, elist, elen specify an initial edge set; if a prob is
      read from a file, then this list is ignored
     -excount, exlist, exlen specify an full edge set (they can be
      0, NULL, NULL); if the probfile already has an full edge set,
      then this values are ignored.
     -exvalid indicates whether or not the edges specified in exlist
      are a valid complete set of edges (0 no, 1 yes)
     -pool is a pointer to a cutpool (can be NULL)
     -silent will suppress print messages if set to a nonzero value
    NOTES: If init_lp returns 2, then the LP is infeasible (even after
     considering the full edge set).
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_bb_init_lp
DESC: short from of CCtsp_init_lp for use in branch and bound
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bb_init_lp (CCtsp_lp **lp, char *probname, int probnum,
        int ncount, CCdatagroup *dat, int *ptour, double initial_ub,
        CCtsp_lpcuts *pool, int silent, CCrandstate *rstate)
DESCRIPTION:
    SHORT form of CCtsp_init_lp for use in the branch and bound.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_get_lp_result
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_get_lp_result (CCtsp_lp *lp, double *lb, double *ub,
        int *ecount, int **elist, double **x, double **rc,
        double **node_pi, double **cut_pi)
DESCRIPTION:
    RETURNS a copy of the values cached in lp->result. However, it
     allows a single point of locking for the threaded version. Any
     return argument can be NULL.
     -lp is a pointer to the tsp lp
     -obj returns the location for the current objective value
     -ecount returns the location for the number of nonzero edges
     -elist returns the  location for the nonzero edges in end1 end2
      format
     -x returns location for the edge values
     -rc returns location for the edge values
     -node_pi returns the values on the degree constraints
     -cut_pi returns the dual values on the cuts
    NOTES: node_pi and cut_pi go to the LP to fetch the results.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_lpcut_in_nzlist
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_lpcut_in_nzlist (CCtsp_lpgraph *g, CCtsp_lpcut_in *c)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_add_cut
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_cut (CCtsp_lp *lp, CCtsp_lpcut_in *d, CCtsp_lprow *cr)
DESCRIPTION:
    ADDS cut d to the lp structure and to cr (a call to
     CCtsp_add_multiple will put the cut into the lp solver)
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_add_nzlist_to_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_nzlist_to_lp (CCtsp_lp *lp, int nzlist, int nrhs,
        char sense, CCtsp_lprow *cr)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_add_multiple_rows
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_multiple_rows (CCtsp_lp *lp, CCtsp_lprow *cr)
DESCRIPTION:
    HANDS the cuts in cr to the lp solver.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_delete_cut
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_delete_cut (CCtsp_lp *lp, int i)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_write_probfile_sav
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_probfile_sav (CCtsp_lp *lp)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_write_probfile_id
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_probfile_id (CCtsp_lp *lp)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_write_probroot_id
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_probroot_id (char *probloc, CCtsp_lp *lp)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_add_cuts_to_queue
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_add_cuts_to_queue (CCtsp_lp *lp, CCtsp_lpcut_in **clist)
DESCRIPTION:
    ADDS clist to the queue of cuts to be processed by the lp solver;
     clist will be set to NULL
     -lp is a pointer to the tsp lp
     -clist is the head of a NULL terminated linked list of cuts
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_process_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_process_cuts (CCtsp_lp *lp, int *pnadded, int tighten,
        int silent, CCrandstate *rstate)
DESCRIPTION:
     -lp is a pointer to the tsp lp
     -pnadded returns the location for the number of cuts added
     -tighten is a flag to indicate whether or not the tighten routine
      should be called for each cut before it is added to the LP
    NOTES: process_cuts runs through all the cuts in the queue;
      process_cuts also calls add_to_cutpool().  If process_cuts
      returns 2, then the LP is infeasible, even after considering
      the full edge set.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_addbad_variables
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_addbad_variables (CCtsp_lp *lp, CCtsp_edgegenerator *eg,
        double *ppenalty, int *pnadded, double rcthresh,
        double maxpenalty, int phase1, int *feasible, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    ADDS negative reduced cost edges to the LP; if phase1 is nonzero
     then the added edges attempt to make a feasible LP (in this
     case the eg variable is ignored and the edges are taked either
     from fulladj (if they are valid) or from dat)
     -lp is a pointer to the tsp lp
     -eg is a generator for the edges to check
     -ppenalty is the penalty from the last pass of pricing
     -pnadded is the number of negative reduced cost edges added
     -rcthresh is the threshold on the reduced cost of edges to be
      added (it should be something <= 0.0)
     -maxpenalty is the maximum sum of penalties that is permitted
      before the rounds of pricing stop
     -phase1 should be 0 for normal column generation, and nonzero
      to try to fix an infeasible LP
     -feasible can be NULL, otherwise it is set to 1 if phase 1
      gets to a feasible LP and 0 if the LP really is infeasible
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_eliminate_variables
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_eliminate_variables (CCtsp_lp *lp, int eliminate_sparse,
        int silent)
DESCRIPTION:
    SETS edges to 0 or 1 if possible, based on reduced costs
     -lp is a pointer to the tsp lp
     -if eliminate_sparse is nonzero and the full edge list in lp is
      present and valid, eliminate variables from that list.  Otherwise
      eliminate from the complete graph
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_cutprice
HEADER: tsp.h
PROTOTYPE:
    double CCtsp_cutprice (CCtsp_lpgraph *g, CCtsp_lpcut_in *c,
        double *x)
DESCRIPTION:
    RETURNS the slack of cut c
     -g is a pointer to an CCtsp_lpgraph that matches the vector x
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_add_vars_to_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_vars_to_lp (CCtsp_lp *lp, CCtsp_predge *prlist, int n)
DESCRIPTION:
    ADDS the columns to the lp.
     -n the number of edges listed in prlist
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_update_result
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_update_result (CCtsp_lp *lp)
DESCRIPTION:
    UPDATES the solution information in the lp structure
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_infeas_recover
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_infeas_recover (CCtsp_lp *lp, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    TRIES to add columns to lp to regain feasibiblity
    NOTES: Returns 2 if the full lp is infeasible
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_build_lpgraph
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_build_lpgraph (CCtsp_lpgraph *g, int ncount, int ecount,
        int *elist, int *elen)
DESCRIPTION:
    BUILDS the node and edge lists for the CCtsp_lpgraph pointed to by
      g.
     -elen contains the edge lengths (it can be NULL, in which case
      the lengths are set to 0).
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_build_lpadj
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_build_lpadj (CCtsp_lpgraph *g, int estart, int eend)
DESCRIPTION:
    BUILDS the incidence list for the graph *g
     -estart is the index of the first edge to include in the list
     -eend is the index of the last edge + 1
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_find_edge
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_find_edge (CCtsp_lpgraph *g, int from, int to)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_init_lpgraph_struct
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_lpgraph_struct (CCtsp_lpgraph *g)
DESCRIPTION:
    INITIALIZES the CCtsp_lpgraph struct pointed to by g.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_free_lpgraph
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_lpgraph (CCtsp_lpgraph *g)
DESCRIPTION:
    FREES the fields in the CCtsp_lpgraph pointed to by g.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_init_lprow
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_lprow (CCtsp_lprow *cr)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_free_lprow
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_lprow (CCtsp_lprow *cr)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_inspect_full_edges
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_inspect_full_edges (CCtsp_lp *lp)
DESCRIPTION:
    CHECKS that full edge set contains the current LP edge set; it
     returns 0 if it is okay and 1 if some edge is not present
     -lp is the CCtsp_lp
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_resparsify_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_resparsify_lp (CCtsp_lp *lp, int silent)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_read_probfile
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_probfile (CCtsp_lp *lp, char *fname, char *probloc,
        int *ncount, int silent)
DESCRIPTION:
    READS a tsp file and loads the results into lp
     -lp is an initialized lp (via a call to init_tsp_lp_struct; the
      results are returned in this struct
     -fname is the tsp file
     -probloc is the problem location.  If probloc == NULL, then the
      this is derived from fname.
     -ncount is a pointer to the number of nodes; if it is nonnull and
      *ncount != 0, it is used as a check to see if the tsp file
      matches.  If it is nonnull and *ncount == 0, it returns the
      from the tsp file.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_read_probfile_id
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_probfile_id (CCtsp_lp *lp, char *fname, int id,
        int *ncount, int silent)
DESCRIPTION:
    READS a tsp file and loads the results into lp, where the filename
     is obtained by using the id.
END_DESCRIPTION

FILENAME: TSP/tsp_lp.c
FUNCTION: CCtsp_dump_x
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_dump_x (CCtsp_lp *lp, char *fname)
DESCRIPTION:
    WRITES the lp solution to fname.
    NOTES: The vector contains the original node names.
END_DESCRIPTION

BEGINFILE: TSP/tsp_call.c

FILENAME: TSP/tsp_call.c
FUNCTION: CCtsp_solve_sparse
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_solve_sparse (int ncount, int ecount, int *elist,
        int *elen, int *in_tour, int *out_tour, double *in_val,
        double *optval, int *success, int *foundtour, char *name,
        double *timebound, int *hit_timebound, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    SOLVES the TSP over the graph specfied in the edgelist.
     -elist is an array giving the ends of the edges (in pairs)
     -elen is an array giving the weights of the edges.
     -in_tour gives a starting tour in node node node format (it can
      be NULL)
     -out_tour will return the optimal tour (it can be NULL, if it is
      not NULL then it should point to an array of length at least
      ncount.
     -in_val can be used to specify an initial upperbound (it can be
      NULL)
     -optval will return the value of the optimal tour.
     -success will be set to 1 if the run finished normally, and set to
      if the search was terminated early (by hitting some predefined
      limit)
     -foundtour will be set to 1 if a tour has been found (if success
      is 0, then it may not be the optimal tour)
     -name specifes a char string that will be used to name various
      files that are written during the branch and bound search (if it
      is NULL, then "noname" will be used - this will cause problems
      in a multithreaded program, so specify a distinct name in that
      case).
     -silent will suppress most output if set to a nonzero value.
END_DESCRIPTION

FILENAME: TSP/tsp_call.c
FUNCTION: CCtsp_solve_dat
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_solve_dat (int ncount, CCdatagroup *indat, int *in_tour,
        int *out_tour, double *in_val, double *optval, int *success,
        int *foundtour, char *name, double *timebound, int *hit_timebound,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    SOLVES the TSP over the graph specified in the datagroup.
    LIKE CCtsp_solve_sparse.
END_DESCRIPTION

BEGINFILE: TSP/teething.c

FILENAME: TSP/teething.c
FUNCTION: CCtsp_teething
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_teething (CCtsp_lpgraph *g, double *x,
        CCtsp_lpcut_in *cut, CCtsp_lpcut_in **newcut)
DESCRIPTION:
       CALLS teething with the handle and bigteeth of the comb given by
        cut (the code will test that it really is a comb or subtour).
        -g is the graph of the active edges in the LP
        -x is an LP solution
        -cut is the base comb
        -newcut returns the comb found after teething
    NOTES:
        The new cut may be just a subtour inequality. This code is based
    on the "Teething" section of the tsp notes.
END_DESCRIPTION

FILENAME: TSP/teething.c
FUNCTION: CCtsp_teething_list
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_teething_list (CCtsp_lpgraph *g, double *x,
        CCtsp_lpclique *handle, int nbig, CCtsp_lpclique **bigteeth,
        CCtsp_lpcut_in **newcut)
DESCRIPTION:
    CALLS teething with the given handle and bigteeth.
    NOTES: bigteeth should be filled in from 1 to nbig (not 0 to
           nbig-1). 
END_DESCRIPTION

BEGINFILE: TSP/skeleton.c

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_init_skeleton
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_skeleton (CCtsp_skeleton *skel)
DESCRIPTION:
    INITIALIZES a skeleton (to the NULL skeleton)
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_free_skeleton
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_skeleton (CCtsp_skeleton *skel)
DESCRIPTION:
    FREES the memory used by skel
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_copy_skeleton
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_copy_skeleton (CCtsp_skeleton *old, CCtsp_skeleton *new)
DESCRIPTION:
    COPIES a skeleton
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_read_skeleton
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_skeleton (CC_SFILE *f, CCtsp_skeleton *skel,
        int ncount)
DESCRIPTION:
    READS a skeleton from f
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_write_skeleton
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_skeleton (CC_SFILE *f, CCtsp_skeleton *skel,
        int ncount)
DESCRIPTION:
    WRITES a skeleton to f
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_construct_skeleton
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_construct_skeleton (CCtsp_lpcut_in *c, int nodecount)
DESCRIPTION:
    CONSTRUCTS a skeleton for c, representing all atoms in c
END_DESCRIPTION

FILENAME: TSP/skeleton.c
FUNCTION: CCtsp_compare_skeletons
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_compare_skeletons (CCtsp_skeleton *a, CCtsp_skeleton *b,
        int *diff)
DESCRIPTION:
    COMPARES two skeletons, setting *diff=0 if they are the same, and
    *diff=1 if they are not.
END_DESCRIPTION

BEGINFILE: TSP/qsparse.c

FILENAME: TSP/qsparse.c
FUNCTION: CCtsp_qsparsify
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_qsparsify (CCtsp_qsparsegroup **pqs, CCtsp_lpgraph *g,
        int *pnzlist, int *scount, CCtsp_sparser **slist,
        int *savedcount)
DESCRIPTION:
          -pqs (if *pqs is NULL, then it will be initialized)
          -g (the graph)
          -pnzlist (pointer to an int that is the start of a linked list
             of edges that is a superset of the nonzeros in the cut, it
             returns a pointer to a superset of the nonzeros in the
             sparsified cut. The links are via the coefnext field of
             CCtsp_lpedge, and the coef field gives the actual nonzero
             coefs.)
          -scount (returns the number of CCtsp_sparsers in slist)
          -slist (returns an array of CCtsp_sparsers)
          -savedcount (returns the number of nonzeros that were saved)
        RETURNS 0 is it worked and 1 if it failed (probably due to
        running out of memory). CCtsp_free_qsparsify will free the
        allocated memory (it is not freed after each call since the
        mallocs and initialization require too much time).
    NOTES:
        This functions uses priorty queues to line up the stars that
        would decrease the number of nonzeros if they were added or
        subtracted there are separate add and subtract queues).
END_DESCRIPTION

FILENAME: TSP/qsparse.c
FUNCTION: CCtsp_free_qsparsify
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_qsparsify (CCtsp_qsparsegroup **pqs)
DESCRIPTION:
    -pqs (will free the queues and arrays in the struct pointed to
         by *pqs, and sets *pqs to NULL)
END_DESCRIPTION

BEGINFILE: TSP/prob_io.c

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_read
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_read (char *f, int n)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_read_name
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_read_name (char *f)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_write
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_write (char *f, int n)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_write_name
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_write_name (char *fname)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_file_delete
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_file_delete (char *f, int n)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getname
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getname (CCtsp_PROB_FILE *p, char *name)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getid
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getid (CCtsp_PROB_FILE *p, int *id)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getparent
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getparent (CCtsp_PROB_FILE *p, int *parent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getub
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getub (CCtsp_PROB_FILE *p, double *ub)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getlb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getlb (CCtsp_PROB_FILE *p, double *lb)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getexactlb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getexactlb (CCtsp_PROB_FILE *p, CCbigguy *lb)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getnnodes
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getnnodes (CCtsp_PROB_FILE *p, int *nnodes)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getchildren
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getchildren (CCtsp_PROB_FILE *p, int *child0,
        int *child1)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getreal
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getreal (CCtsp_PROB_FILE *p, int *real)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getprocessed
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getprocessed (CCtsp_PROB_FILE *p, int *processed)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getinfeasible
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getinfeasible (CCtsp_PROB_FILE *p, int *infeasible)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_gettour
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_gettour (CCtsp_PROB_FILE *p, int ncount, int **tour,
        int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getedges
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getedges (CCtsp_PROB_FILE *p, int ncount, int *nedges,
        int **elist, int **elen, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getcuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getcuts (CCtsp_PROB_FILE *p, int *ncount,
        CCtsp_lpcuts *cuts, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getwarmstart
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getwarmstart (CCtsp_PROB_FILE *p, CClp_warmstart **w,
        int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getfulladj
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getfulladj (CCtsp_PROB_FILE *p, int ncount,
        int *fullcount, CCtsp_genadj **adj,
        CCtsp_genadjobj **adjspace, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getfixed
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getfixed (CCtsp_PROB_FILE *p, int ncount, int *ecount,
        int **elist, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_getexactdual
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_getexactdual (CCtsp_PROB_FILE *p, ncount,
        CCtsp_bigdual **d, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_gethistory
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_gethistory (CCtsp_PROB_FILE *p, int *depth,
        CCtsp_branchobj **history, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_rclose
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_rclose (CCtsp_PROB_FILE *p)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putname
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putname (CCtsp_PROB_FILE *p, char *name)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putid
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putid (CCtsp_PROB_FILE *p, int id)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putparent
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putparent (CCtsp_PROB_FILE *p, int parent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putub
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putub (CCtsp_PROB_FILE *p, double ub)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putlb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putlb (CCtsp_PROB_FILE *p, double lb)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putexactlb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putexactlb (CCtsp_PROB_FILE *p, CCbigguy lb)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putnnodes
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putnnodes (CCtsp_PROB_FILE *p, int nnodes)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putchildren
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putchildren (CCtsp_PROB_FILE *p, int child0,
        int child1)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putreal
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putreal (CCtsp_PROB_FILE *p, int real)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putprocessed
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putprocessed (CCtsp_PROB_FILE *p, int processed)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putinfeasible
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putinfeasible (CCtsp_PROB_FILE *p, int infeasible)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_puttour
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_puttour (CCtsp_PROB_FILE *p, int ncount, int *tour)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putedges
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putedges (CCtsp_PROB_FILE *p, int ncount, int nedges,
        int *elist, int *elen)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putcuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putcuts (CCtsp_PROB_FILE *p, int ncount,
        CCtsp_lpcuts *cuts)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putwarmstart
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putwarmstart (CCtsp_PROB_FILE *p, CClp_warmstart *w)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putfulladj
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putfulladj (CCtsp_PROB_FILE *p, int ncount,
        int fullcount, CCtsp_genadj *adj)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putfixed
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putfixed (CCtsp_PROB_FILE *p, int ncount,
        int ecount, int *elist)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_putexact_dual
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_putexact_dual (CCtsp_PROB_FILE *p,
        CCtsp_bigdual *exact_dual, int ncount)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_puthistory
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_puthistory (CCtsp_PROB_FILE *p, int depth,
        CCtsp_branchobj *history)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_wclose
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_wclose (CCtsp_PROB_FILE *p)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_copy_section
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_copy_section (CCtsp_PROB_FILE *f, CCtsp_PROB_FILE *t,
        char section, int silent)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_problabel
HEADER: tsp.h
PROTOTYPE:
    char *CCtsp_problabel (const char *probloc)
DESCRIPTION:
    -RETURNS a copy of the probname portion of probfile, or NULL if
     unable to allocate space for the copy.
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_read_remote
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_read_remote (char *hname, char *pname,
        int n)
DESCRIPTION:
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_write_remote
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_write_remote (char *hname, char *pname,
        int n)
DESCRIPTION:
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_server
HEADER: tsp.h
PROTOTYPE:
    CCtsp_PROB_FILE *CCtsp_prob_server (CC_SFILE *s)
DESCRIPTION:
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: TSP/prob_io.c
FUNCTION: CCtsp_prob_delete_remote
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_prob_delete_remote (char *hname, char *pname, int n)
DESCRIPTION:
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

BEGINFILE: TSP/prclique.c

FILENAME: TSP/prclique.c
FUNCTION: CCtsp_pr_cliquetree
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_pr_cliquetree (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x,
        CCtsp_tighten_info *stats)
DESCRIPTION:
    BUILDS clique trees based on the conected compenents of x-1.
     -cuts (new cutting plans will be added to front of this list)
     -cutcount will return the number of new cuts found (can be NULL)
     -ncount is the number of nodes
     -ecount is the number of edges
     -elist is the edge list in node node format
     -x is an lp solution vector
     -stats is used to monitor tighten
END_DESCRIPTION

BEGINFILE: TSP/growcomb.c

FILENAME: TSP/growcomb.c
FUNCTION: CCtsp_edge_comb_grower
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_edge_comb_grower (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x,
        CCtsp_tighten_info *stats)
DESCRIPTION:
    BUILDS combs with 1 inverted tooth using greedy cut.
     -cuts (new cutting plans will be added to front of this list)
     -cutcount will return the number of new cuts found (can be NULL)
     -ncount is the number of nodes
     -ecount is the number of edges
     -elist is the edge list in node node format
     -x is an lp solution vector
     -stats is used to monitor tighten
END_DESCRIPTION

BEGINFILE: TSP/generate.c

FILENAME: TSP/generate.c
FUNCTION: CCtsp_init_edgegenerator
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_init_edgegenerator (CCtsp_edgegenerator *eg, int ncount,
        CCdatagroup *dg, CCtsp_genadj *adj, int nneighbors,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    SETS UP the CCtsp_edgegenerator structure. Must be called before
    calls to the other CCtsp_edgegenerator functions.
      -eg must point to an CCtsp_edgegenerator struct.
      -ncount is the number of nodes.
      -dg will not be copied, only the pointer is recorded.
      -adj will be used as the edgelist if it is nonnull (in this case
       dg can be NULL).
      -nneighbors is the number of neighbors that will be considered
       from each node. To consider all edges, this should be set to
       CCtsp_PRICE_COMPLETE_GRAPH.
END_DESCRIPTION

FILENAME: TSP/generate.c
FUNCTION: CCtsp_free_edgegenerator
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_edgegenerator (CCtsp_edgegenerator *eg)
DESCRIPTION:
    FREES the space used by the structures in eg (but not eg itself).
END_DESCRIPTION

FILENAME: TSP/generate.c
FUNCTION: CCtsp_reset_edgegenerator
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_reset_edgegenerator (CCtsp_edgegenerator *eg,
        double *node_piest, int silent)
DESCRIPTION:
    ADDS the pi values to the eg and records the starting position in
    the loop through the edges (so we can determine when we have
    circled through all edges with a single set of pi values). This
    must be called before the first call to CCtsp_generate_edges.
      -eg must have been set up with a call to
       CCtsp_init_edgegenerator.
      -node_piest is pi values "estimates" on the nodes.
END_DESCRIPTION

FILENAME: TSP/generate.c
FUNCTION: CCtsp_generate_edges
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_generate_edges (CCtsp_edgegenerator *eg, int nwant,
        int *pngot, int *elist, int *elen, int *finished,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    RETURNS a list of edges that have a chance of having negative
    reduced costs in that len(i,j) - pi[i] - pi[j] is negative. If an
    entire pass has been made through the edgeset since the last call
    to CCtsp_reset_edgegenerator, then finished is set to 1
    (otherwise 0).
      -eg must have been initialized with a call to
       CCtsp_init_edgegenerator followed by a call to
       CCtsp_reset_edgegenerator.
      -nwant is the maximum number of edges that should be returned.
      -pngot returns the number of edges found.
      -elist returns the edges in node node format (this must have
       been allocated by the calling routine and should be at least
       2*nwant long.
      -elen returns the lengths of the edges in elist (this must have
       been allocated by the calling routine and have nwant entries).
      -finished is set to 1 if an entire loop through the edges has
       been made since the last call to CCtsp_reset_edgegenerator.
END_DESCRIPTION

FILENAME: TSP/generate.c
FUNCTION: CCtsp_edgelist_to_genadj
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_edgelist_to_genadj (int ncount, int ecount, int *elist,
        int *elen, CCtsp_genadj **adj, CCtsp_genadjobj **adjobjspace)
DESCRIPTION:
    RETURNS the CCtsp_genadj struct corresponding the list of edges.
      -ncount is the number of nodes.
      -ecount is the number of edges.
      -elist is the array of edges in end1 end2 format.
      -elen is the array of edge lengths.
      -adj is a pointer to an CCtsp_genadj struct address; upon return
       it will point to the filled in adj struct.
      -adjobjspace will return a pointer to the list of
       CCtsp_genadjobj's used in adj (this can be used to free the
       objects)
END_DESCRIPTION

BEGINFILE: TSP/ex_price.c

FILENAME: TSP/ex_price.c
FUNCTION: CCtsp_exact_price
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_exact_price (CCtsp_lp *lp, CCbigguy *bound,
        int complete_price, int phase1, int silent)
DESCRIPTION:
    RETURNS a bound that is valid for the entire edge set; the values
         of the dual variables will be stored in lp->exact_dual unless
         the existing lp->exact_dual's cutcount agrees with the
         cutcount for lp
      -lp is a pointer to the tsp lp
      -bound returns the LP bound
      -if complete_price is nonzero, then price over the complete
       graph, even if a valid full edge set is present
      -phase1 is either 0 or 1, with 1 indicating that the pricing
       should be to determine a Farkas' lemma bound to prove that the
       LP is infeasbile
END_DESCRIPTION

FILENAME: TSP/ex_price.c
FUNCTION: CCtsp_edge_elimination
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_edge_elimination (CCtsp_lp *lp, int eliminate_sparse,
        int  silent)
DESCRIPTION:
    USES the bound information to elimination edges and set edges to 1;
         the remaining edges are placed into lp->fulladj (the old adj
         is freed) and the fixed edges are placed on the list
         lp->fixededges; the dual values are taken from lp->exact_dual
      -lp is a pointer to the tsp lp; lp->exact_lowerbound will be used
       together with lp->upperbound to determine the cutoff to elim
       and fix edges
      -if eliminate_sparse is nonzero and lp->full_edges_valid, then
       the elimination is based on the lp->fulladj list.  Otherwise
       the elimination is based on the lp->dat.
      NOTES: this function does not alter the LP or lp->graph
END_DESCRIPTION

FILENAME: TSP/ex_price.c
FUNCTION: CCtsp_exact_dual
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_exact_dual (CCtsp_lp *lp)
DESCRIPTION:
    RETURNS the dual values as bigguys (used to store the info used
        to establish the exact lower bound); the values will be
        stored in lp->exact_dual (and the existing values freed)
     -lp is the CCtsp_lp
END_DESCRIPTION

FILENAME: TSP/ex_price.c
FUNCTION: CCtsp_verify_infeasible_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_verify_infeasible_lp (CCtsp_lp *lp, int *yesno, int silent)
DESCRIPTION:
    VERIFIES that the lp is infeasible using exact pricing.
     -yesno is set to 1 if the lp is infeasible and 0 otherwise.
END_DESCRIPTION

FILENAME: TSP/ex_price.c
FUNCTION: CCtsp_verify_lp_prune
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_verify_lp_prune (CCtsp_lp *lp, int *yesno, int silent)
DESCRIPTION:
    VERIFIES that the lp bound is less than the lp upperbound - 1.
     -yesno is set to 1 if bound < upperbound - 1 and 0 otherwise.
END_DESCRIPTION

BEGINFILE: TSP/ddecker.c

FILENAME: TSP/ddecker.c
FUNCTION: CCtsp_test_pure_double_decker
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_pure_double_decker (CCtsp_lpcut_in *c, int *yes_no,
        int *handle1, int *handle2)
DESCRIPTION:
    TESTS if cut is a pure double decker (no flips permitted)
     -yes_no will be set to either 0 or 1, with 1 meaning yes.
     -handle1 and handle2 will be set to the handles (they can be NULL)
END_DESCRIPTION

FILENAME: TSP/ddecker.c
FUNCTION: CCtsp_comb_to_double_decker
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_comb_to_double_decker (CCtsp_lpgraph *g, CC_GCgraph *h,
        double *x, CCtsp_lpcut_in *c, CCtsp_lpcut_in **d)
DESCRIPTION:
    ATTEMPTS to build a double decker from the comb by adding a second
     handle.
     -x is an lp vector (it should match the edge set of the graph g)
     -c is the comb (it will be tested)
     -d returns a NULL terminated list of any new double deckers that
      were found
END_DESCRIPTION

FILENAME: TSP/ddecker.c
FUNCTION: CCtsp_comb_to_star
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_comb_to_star (CCtsp_lpgraph *g, CC_GCgraph *h, double *x,
        CCtsp_lpcut_in *c, CCtsp_lpcut_in **d)
DESCRIPTION:
    ATTEMPTS to build a star inequalite from the comb using the
     lcm method of Naddef and Thienel.
     -x is an lp vector (it should match the edge set of the graph g)
     -c is the comb (it will be tested)
     -d returns a NULL terminated list of any new stars that were found
END_DESCRIPTION

FILENAME: TSP/ddecker.c
FUNCTION: CCtsp_comb_handling
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_comb_handling (CCtsp_lpgraph *g, CC_GCgraph *h, double *x,
        CCtsp_lpcut_in *c, CCtsp_lpcut_in **d)
DESCRIPTION:
    ATTEMPTS to build star inequalities by adding nested handles and
     possibly stretching the teeth.
     -arguments are the same as above.
END_DESCRIPTION

BEGINFILE: TSP/cutpool.c

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_init_cutpool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_init_cutpool (int *ncount, char *poolfilename,
        CCtsp_lpcuts **pool)
DESCRIPTION:
        -ncount is a pointer to the number of nodes in the problem
        -poolfilename is a file containing an cutpool (it can be NULL)
        -CCtsp_lpcuts will return the pool
        NOTES: poolfilename must be non-NULL or ncount must be
        non-NULL and *ncount nonzero.  If ncount is non-NULL but
        *ncount == zero, then *ncount will be set to the number of
        nodes in the cutpool in poolfilename
    NOTES:
        This version does not use the compressed set references.  Notes
    on the representation are given in "Chapter 4: The Linear
    Programming Problems".
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_search_cutpool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_search_cutpool (CCtsp_lpcuts *pool, CCtsp_lpcut_in **cuts,
        int *cutcount, double *maxviol, int ncount, int ecount,
        int *elist, double *x, int nthreads, CCrandstate *rstate)
DESCRIPTION:
    RETURNS an array of cuts having x(delta(C)) < rhs(C)
     -pool points to a cutpool (or cuts of an lp)
     -cuts will return the array of cuts
     -cutcount with return the length of the array
     -ncount is the number of nodes in the problem
     -ecount is the number of edges in elist
     -elist is a list of edges in end end format
     -x is an ecount-long array of weights
     -nthreads is the number of threads to use.  0 ==> sequential code
      threads are only used if CC_POSIXTHREADS is defined
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_search_remotepool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_search_remotepool (char *remotehost,
        unsigned short remoteport, CCtsp_lpcut_in **cuts,
        int *cutcount, double *maxviol, int ncount, int ecount,
        int *elist, double *x)
DESCRIPTION:
    RETURNS an array of cuts having x(delta(C)) < rhs(C) from a remote
      cutpool
     -remotehost is the host with the cuts
     -remoteport is the port on which to contact the remote server
      (if remoteport == 0, use CCtsp_CUT_PORT)
     -cuts will return the array of cuts
     -cutcount with return the length of the array
     -ncount is the number of nodes in the problem
     -ecount is the number of edges in elist
     -elist is a list of edges in end end format
     -x is an ecount-long array of weights
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_search_cutpool_cliques
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_search_cutpool_cliques (CCtsp_lpcuts *pool,
        CCtsp_lpclique **cliques, int *cliquecount, int ncount,
        int ecount, int *elist, double *x, double maxdelta,
        int maxcliques, double **cliquevals, CCrandstate *rstate)
DESCRIPTION:
    RETURNS an array of cliques having x(delta(C)) < maxdelta
     -pool points to a cutpool (or cuts of an lp)
     -cliques will return the array of cliques
     -cliquecount with return the length of the array
     -ncount is the number of nodes in the problem
     -ecount is the number of edges in elist
     -elist is a list of edges in end end format
     -x is an ecount-long array of weights
     -maxdelta is a bound on x(delta(C))
     -maxcliques is an upperbound on the number of cliques that should
      be returned
     -cliquevals will return the values of x(delta(C)) for the cliques
      (this parameter can be NULL)
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_add_cut_to_cutlist
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_cut_to_cutlist (CCtsp_lpcuts *cuts, CCtsp_lpcut *c)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_delete_cut_from_cutlist
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_delete_cut_from_cutlist (CCtsp_lpcuts *cuts, int ind)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_free_cutpool
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_cutpool (CCtsp_lpcuts **pool)
DESCRIPTION:
    FREES the pool of cuts.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_write_cutpool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_cutpool (int ncount, const char *poolfilename,
        CCtsp_lpcuts *pool)
DESCRIPTION:
    WRITES pool to poolfilename.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_branch_cutpool_cliques
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_branch_cutpool_cliques (CCtsp_lpcuts *pool,
        CCtsp_lpclique **cliques, int *cliquecount, int ncount,
        int ecount, int *elist, double *x, int nwant,
        double **cliquevals, int silent)
DESCRIPTION:
    RETURNS an array of cliques having x(delta(C)) as close to 3.0 as
     possible.
     -the parmeters are like those used by search_cutpool_cliques,
      where nwant is the number of cliques we would like to have in
      the array.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_price_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_price_cuts (CCtsp_lpcuts *pool, int ncount, int ecount,
        int *elist, double *x, double *cutval)
DESCRIPTION:
    COMPUTES the slack on each cut in the pool
     -ecount, elist, and x give an x-vector
     -cutval returns the array of slack values (it should be passed in
      as an array of length at least pool->cutcount)
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_price_cuts_threaded
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_price_cuts_threaded (CCtsp_lpcuts *pool, int ncount,
        int ecount, int *elist, double *x, double *cutval,
        int numthreads)
DESCRIPTION:
    COMPUTES the slack on each cut in the pool in parallel
     -ecount, elist, and x give an x-vector
     -cutval returns the array of slack values (it should be passed in
      as an array of length at least pool->cutcount)
     -nthreads is the number of parallel threads to use.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_get_clique_prices
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_get_clique_prices (CCtsp_lpcuts *pool, int **p_cliquenums,
        double **p_cliquevals, double mindelta, double maxdelta,
        int *p_cliquecount, int ncount, int ecount, int *elist,
        double *x)
DESCRIPTION:
    RETURNS the id's and x(delta(C)) for cliques in the pool.
     -the parameters pool, ncount, ecount, elist, and x are like those
      used by search_cutpool_cliques.
     -mindelta and maxdelta are bounds on x(delta(C))
     -cliquenums and cliquevals return id's and x(delta(C)) for
      cliques with x(delta(C)) between mindelta and maxdelta
     -cliquecount returns the number of cliques in cliquenums/vals
     -use CCtsp_get_clique to retrive specific cliques.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_get_clique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_get_clique (CCtsp_lpcuts *pool, int cliquenum,
        CCtsp_lpclique **p_clique)
DESCRIPTION:
    RETURNS p_clique, a pointer to the clique numbered clqiuenum in
      the pool.  Note that this clique is not a copy, and thus should
      not be freed.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_display_cutpool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_display_cutpool (CCtsp_lpcuts *pool)
DESCRIPTION:
    DISPLAYS the contents of a cutpool.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_add_to_cutpool
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_to_cutpool (CCtsp_lpcuts *pool, CCtsp_lpcuts *cuts,
        CCtsp_lpcut *c)
DESCRIPTION:
     -pool is the pool to add the cut to
     -cuts is the lpcuts the cut is from
     -c is the cut
    ADDS a cut to a pool
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_add_to_cutpool_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_to_cutpool_lpcut_in (CCtsp_lpcuts *pool,
        CCtsp_lpcut_in *c)
DESCRIPTION:
     -pool is the pool to add the cut to
     -c is the cut
    ADDS a cut to a pool
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_free_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_lpcut_in (CCtsp_lpcut_in *c)
DESCRIPTION:
    FREES the fields in the CCtsp_lpcut pointed to by c.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_free_lpclique
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_lpclique (CCtsp_lpclique *c)
DESCRIPTION:
    FREES the fields in the CCtsp_lpclique pointed to by c.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_read_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_cuts (CC_SFILE *f, int *ncount, CCtsp_lpcuts *cuts,
        int readmods, int buildhash)
DESCRIPTION:
    READS the cuts from f into cuts.
    -readmods indicates whether or not the file contains sparser mods
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_read_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_lpcut_in (CC_SFILE *f, CCtsp_lpcut_in *c, int ncount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_read_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_read_lpclique (CC_SFILE *f, CCtsp_lpclique *c, int ncount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_send_newcuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_send_newcuts (int ncount, CCtsp_lpcuts *pool,
        char *remotehost, unsigned short remoteport)
DESCRIPTION:
    SENDS the new cuts from pool to the remote host
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_write_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_cuts (CC_SFILE *f, int ncount, CCtsp_lpcuts *cuts,
        int writemods)
DESCRIPTION:
    WRITES the cuts from cuts to f.
    -writemods indicates whether or not the file should contain
     sparser mods
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_write_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_lpcut_in (CC_SFILE *f, CCtsp_lpcut_in *c, int ncount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_write_lpcut
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_lpcut (CC_SFILE *f, CCtsp_lpcuts *cuts,
        CCtsp_lpcut *c, int ncount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_write_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_write_lpclique (CC_SFILE *f, CCtsp_lpclique *c, int ncount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_copy_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_copy_cuts (CC_SFILE *f, CC_SFILE *t, int copymods)
DESCRIPTION:
    COPIES the cuts from f to t.
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_register_cliques
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_register_cliques (CCtsp_lpcuts *cuts, CCtsp_lpcut_in *c,
        CCtsp_lpcut *new)
DESCRIPTION:
    BUILDS the references to the cliques in c into the cut strucure
    pointed to by cuts and creates an array of the indices of the
    the cliques in CCtsp_lpcut new
     -cuts is the structure holding the set of cuts
     -c describes the cut to be added to the structure
     -new returns the array of clique indices
END_DESCRIPTION

FILENAME: TSP/cutpool.c
FUNCTION: CCtsp_unregister_cliques
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_unregister_cliques (CCtsp_lpcuts *cuts, CCtsp_lpcut *c)
DESCRIPTION:
    REMOVES the references to the cliques in cut c (and deletes the
     cliques if they have no more references) and frees the array
     of clique indices in c
     -cuts is the structure holding the set of cuts
     -c is the cut containing the cliques to be removed
END_DESCRIPTION

BEGINFILE: TSP/cutcall.c

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_connect_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_connect_cuts (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x)
DESCRIPTION:
    FINDS violated subtour inequalities via connectivity.
     -cuts will return any new cuts found (they will be added to the
      head of the linked list)
     -cutcount will return the number of new cuts added
     -ncount is the number of nodes
     -ecount is the number of edges
     -elist contains the LP edges in node node format
     -x is an LP solution
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_segment_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_segment_cuts (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x)
DESCRIPTION:
    FINDS violated subtour inequalities via linsub.
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_exact_subtours
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_exact_subtours (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x)
DESCRIPTION:
    FINDS violated subtour inequalities via a mincut algorithm.
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_tighten_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_tighten_lp (CCtsp_lpcuts *cuts, CCtsp_tighten_info *stats,
        CCtsp_lpcut_in **cutsout, int *cutcount, int ncount,
        int ecount, int *elist, double *x, double testtol,
        int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    CALLS tighten for each cut in the cuts.
     -stats contains some running statistics of tighten
     -cutsout returns the tightened cuts that are violated (they are
      added to the tail of the linked list)
     -cutcount is the number of cuts in cutsout
     -testtol is a tolerance for calling tighten (call only when the
      cut has slack value within testtol)
     -maxcuts is a bound on the number of cuts to be returned
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_double_decker_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_double_decker_lp (CCtsp_lpcuts *cuts,
        CCtsp_tighten_info *stats, CCtsp_lpcut_in **cutsout,
        int *cutcount, int ncount, int ecount, int *elist, double *x,
        double testtol, int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_cliquetree_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_cliquetree_lp (CCtsp_lpcuts *cuts,
        CCtsp_tighten_info *stats, CCtsp_lpcut_in **cutsout,
        int *cutcount, int ncount, int ecount, int *elist, double *x,
        double testtol, int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_star_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_star_lp (CCtsp_lpcuts *cuts, CCtsp_tighten_info *stats,
        CCtsp_lpcut_in **cutsout, int *cutcount, int ncount,
        int ecount, int *elist, double *x, double testtol,
        int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_handling_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_handling_lp (CCtsp_lpcuts *cuts, CCtsp_tighten_info *stats,
        CCtsp_lpcut_in **cutsout, int *cutcount, int ncount,
        int ecount, int *elist, double *x, double testtol,
        int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    CALLS CCtsp_comb_handling for each comb in cuts.
     -agruments as in CCtsp_tighten_lp.
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_handling_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_handling_lp (CCtsp_lpcuts *cuts, CCtsp_tighten_info *stats,
        CCtsp_lpcut_in **cutsout, int *cutcount, int ncount,
        int ecount, int *elist, double *x, double testtol,
        int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_teething_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_teething_lp (CCtsp_lpcuts *cuts, CCtsp_tighten_info *stats,
        CCtsp_lpcut_in **cutsout, int *cutcount, int ncount,
        int ecount, int *elist, double *x, double testtol,
        int maxcuts, double *viol, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_file_cuts
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_file_cuts (char *cutfile, CCtsp_lpcut_in **cuts,
        int *cutcount, int ncount, int *tour)
DESCRIPTION:
    READS a set of cuts from a file; the format of the cuts can be
     found by examining the code
     -cutfile is an asci file with a list of cuts
     -cuts will return any new cuts found (they will be added to the
      tail of the linked list)
     -cutcount with return the number of new cuts added
     -ncount is the number of nodes
     -tour the permutation tour (used to map the incoming nodes)
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_file_cuts_write
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_file_cuts_write (const char *cutfile, CCtsp_lpcuts *cuts,
        int *tour)
DESCRIPTION:
    WRITES a set of cuts in a text file that can be read by
     tsp_file_cuts
     -cutfile is the name of the file to be written
     -cuts is the set of cuts to be written
     -tour is a permutation tour (used to map the outgoing nodes)
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_test_pure_comb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_pure_comb (int ncount, CCtsp_lpcut_in *c, int *yes_no,
        int *handle)
DESCRIPTION:
    TEST if the cut is a comb (without flipped teeth or intersections)
     -ncount is the number of nodes in the TSP
     -yes_no will be set to either 0 or 1, with 1 meaning yes
     -handle with return the index of the handle if the cut is a comb
      (handle can be NULL)
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_test_pseudocomb
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_pseudocomb (int ncount, CCtsp_lpcut_in *c, int handle,
        int *yes_no)
DESCRIPTION:
    TEST if the cut is a pseudocomb.
     -handle gives the index of the handle of the pseudocomb
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_test_teeth_disjoint
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_teeth_disjoint (int ncount, CCtsp_lpcut_in *c,
        int handle, int *yes_no)
DESCRIPTION:
    TEST if the cliques other than handle are pairwise disjoint.
     -yes_no is 1 if disjoint and 0 otherwise.
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_find_pure_handle
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_find_pure_handle (int ncount, CCtsp_lpcut_in *c,
        int *handle)
DESCRIPTION:
    FINDS a clique that is c's handle if c is a comb; the search
     assumes that the teeth are disjoint, so if the comb has
     extra intersections then a tooth may be returned.
     -handle returns the potential handle (it will return -1 if no
      clique is a potential handle)
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_buildcut_begin
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_buildcut_begin (CCtsp_cutinfo *cuts, int init_cliquecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_buildcut_addclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_buildcut_addclique (CCtsp_cutinfo *cuts, *arr, int size)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_buildcut_finish
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_buildcut_finish (CCtsp_cutinfo *cuts, int rhs)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cutcall.c
FUNCTION: CCtsp_buildcut_abort
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_buildcut_abort (CCtsp_cutinfo *cuts)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TSP/control.c

FILENAME: TSP/control.c
FUNCTION: CCtsp_init_cutselect
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_cutselect (CCtsp_cutselect *s)
DESCRIPTION:
    INITIALIZES the cut selections
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_init_tentative_cutselect
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_tentative_cutselect (CCtsp_cutselect *s)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_cutselect_set_tols
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_cutselect_set_tols (CCtsp_cutselect *s, CCtsp_lp *lp,
        int level, int silent)
DESCRIPTION:
    SETS the tolerances for the cut selections
     -level should be set to 0 for tentative cutting
    NOTES: The lp should be solved before this call.
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_cutting_loop
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_cutting_loop (CCtsp_lp *lp, CCtsp_cutselect *sel,
        int savelp, int silent, CCrandstate *rstate)
DESCRIPTION:
    CALLS the cutting plane and pricing routines.
     -sel should be set with the desired cut selection.
     -savelp should be set to a nonzero value to write the lps to after
      rounds of cuts
     -silent turns off most output if set to a nonzero value
    NOTES: It returns a 2 if the lp becomes infeasible
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_subtour_loop
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_subtour_loop (CCtsp_lp *lp, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    CALLS the cutting and pricing to optimize over the subtour polytope.
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_blossom_loop
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_blossom_loop (CCtsp_lp *lp, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    CALLS the cutting and pricing to optimize over the blossom polytope.
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_subtour_and_blossom_loop
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_subtour_and_blossom_loop (CCtsp_lp *lp, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    CALLS the cutting and princing to optimize over subtours and
     trivial blossoms.
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_pricing_loop
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_pricing_loop (CCtsp_lp *lp, double *bnd, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    ADDS negative reduced costs edges to lp and returns the current
     lowerbound.
     -bnd can be NULL
    NOTES: The LP must have full_edges_valid.
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_call_x_heuristic
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_call_x_heuristic (CCtsp_lp *lp, double *val, int *outcyc,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    CALLS the x-greedy LK heuristic with the current LP solution.
     -val returns the length of the tour.
     -outcyc will return the tour in node-node-node format if the
      length of the tour is less than lp->upperbound; the array should
      at least of length ncount (it can be NULL)
END_DESCRIPTION

FILENAME: TSP/control.c
FUNCTION: CCtsp_bb_cutting
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bb_cutting (char *probname, int probnum, int prob_newnum,
        int ncount, CCdatagroup *dat, int *ptour, double *upbound,
        CCtsp_lpcuts *pool, CCtsp_cutselect *sel, double *val,
        int *prune, int *foundtour, int *besttour, int level,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    CALLS the cutting loop after reading the lp; writes the result to
     prob file prob_newnum; using exact price to verify pruned runs
     -upbound should be passed in as the current bound; if a better
      tour is found then upbound will be updated
     -val returns the lp bound; it is CCtsp_LP_MAXDOUBLE if infeasible
     -prune is set to 1 if bbnode can be pruned
     -foundtour is set to 1 if a better tour is found.
     -besttour (if not NULL) will return a better tour if one is found.
     -level should be set to 0 for tentative cutting
END_DESCRIPTION

BEGINFILE: TSP/combcliq.c

FILENAME: TSP/combcliq.c
FUNCTION: CCtsp_test_pure_simple_cliquetree
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_pure_simple_cliquetree (int ncount,
        CCtsp_lpcut_in *c, int *yes_no)
DESCRIPTION:
    TEST if cut is a two handled cliquetree (assumes first two cliques
     cliques in the cut are the handles).
     -ncount is the number of nodes in the graph.
     -c points  to the cut.
     -yes_no will be set to either 0 or 1, with 1 meaning yes.
END_DESCRIPTION

FILENAME: TSP/combcliq.c
FUNCTION: CCtsp_comb_to_cliquetree
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_comb_to_cliquetree (CCtsp_lpgraph *g, CC_GCgraph *h,
        double *x, CCtsp_lpcut_in *c, CCtsp_lpcut_in **d)
DESCRIPTION:
    ATTEMPTS to build a cliquetree from the comb by adding a bunny.
     -x is an lp vector (it should match the edge set of the graph g)
     -c is the comb (it will be tested)
     -d returns the double decker or NULL if none is found
END_DESCRIPTION

BEGINFILE: TSP/cliqwork.c

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_mark_clique
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_mark_clique (CCtsp_lpclique *c, int *marks, int marker)
DESCRIPTION:
    MARKS the nodes in clique c
     -marks an array of length at least ncount
     -marker an int that is used to mark the clique entries in marks
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_mark_clique_and_neighbors
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_mark_clique_and_neighbors (CCtsp_lpgraph *g,
        CCtsp_lpclique *c, int *marks, int marker)
DESCRIPTION:
    MARKS the clique and the neighbors of the clique
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_mark_clique_and_neighbors_double
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_mark_clique_and_neighbors_double (CCtsp_lpgraph *g,
        CCtsp_lpclique *c, double *marks, double marker)
DESCRIPTION:
    MARKS the clique and the neighbors of the clique in a double array.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_mark_cut
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_mark_cut (CCtsp_lpcut_in *c, int *marks, int marker)
DESCRIPTION:
    MARKS the nodes in the cut.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_mark_cut_and_neighbors
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_mark_cut_and_neighbors (CCtsp_lpgraph *g,
        CCtsp_lpcut_in *c, int *marks, int marker)
DESCRIPTION:
    MARKS the nodes in the cut and their neighbors
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_is_clique_marked
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_is_clique_marked (CCtsp_lpclique *c, int *marks,
        int marker, int *yes_no)
DESCRIPTION:
    CHECKS if a node in the clique is marked with the value marker.
     -yesno returns the result (1 is yes and 0 is no)
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_clique_count
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_clique_count (CCtsp_lpclique *c, int *count)
DESCRIPTION:
    COUNTS the nodes in the clique.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_clique_marked_count
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_clique_marked_count (CCtsp_lpclique *c, int *marks,
        int marker, int *count)
DESCRIPTION:
    COUNTS the nodes in the clique have mark equal to marker.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_clique_to_array
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_clique_to_array (CCtsp_lpclique *c, int **ar, int *count)
DESCRIPTION:
    EXPANDS a clique into an array of integers.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_clique_delta
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_clique_delta (CCtsp_lpgraph *g, double *x,
        CCtsp_lpclique *c, double *delta)
DESCRIPTION:
    COMPUTES the sum of the x-edges in the coboundary of the clique,
     that is, x(delta(c)).
     -delta returns the sum
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_segment_to_subtour
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_segment_to_subtour (CCtsp_lpcut_in **cut, int a, int b,
        int ncount)
DESCRIPTION:
    BUILDS a subtour CCtsp_lpcut_in from an the segment.
     -cut will return the subtour (it will be allocated).
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_array_to_subtour
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_array_to_subtour (CCtsp_lpcut_in **cut, int *ar,
        int acount, int ncount)
DESCRIPTION:
    BUILDS a subtour CCtsp_lpcut_in from an array.
     -cut will return the subtour (it will be allocated).
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_init_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_lpcut_in (CCtsp_lpcut_in *c)
DESCRIPTION:
    INITIALIZE the fields of the CCtsp_lpcut_in structure
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_init_lpclique
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_lpclique (CCtsp_lpclique *c)
DESCRIPTION:
    INITIALIZE the fields of the CCtsp_lpclique structure
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_array_to_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_array_to_lpclique (int *ar, int acount,
        CCtsp_lpclique *cliq)
DESCRIPTION:
    BUILDS an CCtsp_lpclique represented the nodes in an array.
     -ar is an array of node numbers
     -acount is the length of ar
     -cliq's segcount and nodes will be filled with the compressed
      version of the nodes in ar
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_seglist_to_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_seglist_to_lpclique (int nseg, int *list,
        CCtsp_lpclique *cliq)
DESCRIPTION:
    BUILDS the CCtsp_lpclique represented by a list of segments (it
     will sort the segments before it puts them into the CCtsp_segment
     structures)
     -list is an array of segments in lo-hi-lo-hi format
     -clig's segcount and nodes will be filled in (nodes will be
      allocated)
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_shrunk_set_to_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_shrunk_set_to_lpclique (int cnt, int *set, int *wset,
        CC_SRKexpinfo *expand, CCtsp_lpclique *cliq)
DESCRIPTION:
    BUILDS an lpclique by exanding a shrunk set of nodes.
     -cnt is the number of nodes in set
     -set is an array of the nodes
     -wset is a working array, it should be ncount long and the values
      may be changed by this function
     -expand contains the info to expand the nodes
     -cliq returns the clique
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_add_nodes_to_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_nodes_to_lpclique (CCtsp_lpclique *cin,
        CCtsp_lpclique *cout, int addcount, int *adda)
DESCRIPTION:
    ADDS nodes to clique cin, and returns the new clique in cout
     -addcount has number of nodes to be added.
     -adda has the indices of the addcount nodes to be added.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_delete_nodes_from_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_delete_nodes_from_lpclique (CCtsp_lpclique *cin,
        CCtsp_lpclique *cout, int delcount, int *del)
DESCRIPTION:
    DELETES nodes from clique cin, and returns the new clique in cout
     -delcount has number of nodes to be deleted.
     -del has the indices of the delcount nodes to be deleted.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_print_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_print_lpcut_in (CCtsp_lpcut_in *c)
DESCRIPTION:
    PRINTS the CCtsp_lpcut_in
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_print_lpclique
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_print_lpclique (CCtsp_lpclique *c)
DESCRIPTION:
    PRINTS the segments in the clique to stdout.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_copy_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_copy_lpcut_in (CCtsp_lpcut_in *c, CCtsp_lpcut_in *new)
DESCRIPTION:
    COPIES an CCtsp_lpcut_in
     -c is a pointer to an CCtsp_lpcut_in
     -new returns the copied CCtsp_lpcut_in
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_lpcut_to_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_lpcut_to_lpcut_in (CCtsp_lpcuts *cuts, CCtsp_lpcut *c,
        CCtsp_lpcut_in *new)
DESCRIPTION:
    COPIES an CCtsp_lpcut to an CCtsp_lpcut_in
     -cuts is a pointer to the structure holding the set of cuts
     -c is the cut to be copied
     -new returns the copied cut
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_lpclique_compare
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_lpclique_compare (CCtsp_lpclique *a, CCtsp_lpclique *b,
        int *diff)
DESCRIPTION:
    COMPARES two CCtsp_lpcliques.
     -diff is set to 1 if they differ and 0 if they are the same
      NOTES: Assumes segments are ordered.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_copy_lpclique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_copy_lpclique (CCtsp_lpclique *c, CCtsp_lpclique *new)
DESCRIPTION:
    COPIES an CCtsp_lpclique
     -c is a pointer to an CCtsp_lpclique
     -new returns the copied clique
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_create_lpcliques
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_create_lpcliques (CCtsp_lpcut_in *c, int cliquecount)
DESCRIPTION:
    ALLOCATES and INITIALIZES the cliques space for c.
END_DESCRIPTION

FILENAME: TSP/cliqwork.c
FUNCTION: CCtsp_max_node
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_max_node (CCtsp_lpcut_in *c)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TSP/cliqhash.c

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_init_cliquehash
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_init_cliquehash (CCtsp_lpcuts *cuts, int size)
DESCRIPTION:
    initializes the clique hash storage in cuts.
    int size is an estimate of the number of cliques
END_DESCRIPTION

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_register_clique
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_register_clique (CCtsp_lpcuts *cuts, CCtsp_lpclique *c)
DESCRIPTION:
    returns an integer index for c, adding c to cuts if necessary
    -1 ==> failure
END_DESCRIPTION

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_free_cliquehash
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_cliquehash (CCtsp_lpcuts *cuts)
DESCRIPTION:
    frees the clique hashtable space
END_DESCRIPTION

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_unregister_clique
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_unregister_clique (CCtsp_lpcuts *cuts, int c)
DESCRIPTION:
    deletes a reference to clique c, and deletes the clique if no
    references remain
END_DESCRIPTION

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_clique_eq
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_clique_eq (CCtsp_lpclique *c, CCtsp_lpclique *d,
        int *yes_no)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/cliqhash.c
FUNCTION: CCtsp_hashclique
HEADER: tsp.h
PROTOTYPE:
    unsigned int CCtsp_hashclique (CCtsp_lpclique *c)
DESCRIPTION:
    RETURNS a hash value for the clique.
END_DESCRIPTION

BEGINFILE: TSP/branch.c

FILENAME: TSP/branch.c
FUNCTION: CCtsp_find_branch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_find_branch (CCtsp_lp *lp, int nwant, int *ngot,
        CCtsp_branchobj **bobj, double *val, int **cyc,
        int usecliques, int longedge_branching, int silent)
DESCRIPTION:
    FINDS a set of branching edges and cliques.
     -usecliques should be set to 1 to allow branching on cliques
     -val returns the length of a tour if one is detected.
     -cyc returns the tour (it can be NULL)
     -longedge_branching if nonzero selects the alternative longedge
      branching rule.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_find_branch_edge
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_find_branch_edge (CCtsp_lp *lp, int *n0, int *n1,
        double *val, int **cyc, int branchtype, int silent)
DESCRIPTION:
    FINDS a branching edge or detects that solution is integral.
     -lp points to an optimized lp.
     -n0, n1 return the edges of the branching edge; n0 is set to -1
          if the current lp solution is a tour
     -val returns the value the tour if n0 is set to -1
     -branchtype determines the strategy for choosing the branching
          edge; choices for branchtype are given in tsp.h
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_check_integral
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_check_integral (CCtsp_lp *lp, double *val, int **cyc,
        int *yesno, int silent)
DESCRIPTION:
    TESTS if the current x-vector is a tour.
     -yesno is set to 1 if it is a tour and 0 otherwise.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_find_branch_cliques
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_find_branch_cliques (CCtsp_lp *lp, int nwant,
        int longedge_branching, int *ngot, CCtsp_lpclique **bcliques,
        double *bval, int silent)
DESCRIPTION:
    FINDS branching cliques (it may return ngot == 0)
    -bval will return the stongbranching function evaluation for
     each clique (it can be NULL)
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_test_cut_branch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_test_cut_branch (CCtsp_lp *lp, CCtsp_lpclique *c,
        double *down, double *up, int iter, int silent)
DESCRIPTION:
    ESTIMATES the bound shift from branching on clique c
    -iter is the number of dual simplex pivots to try.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_init_branchobj
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_branchobj (CCtsp_branchobj *b)
DESCRIPTION:
    INITITALIZES the fields in the CCtsp_branchobj pointed to by b.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_free_branchobj
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_free_branchobj (CCtsp_branchobj *b)
DESCRIPTION:
    FREES the fields in the CCtsp_branchobj pointed to by b.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_print_branchhistory
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_print_branchhistory (CCtsp_lp *lp)
DESCRIPTION:
    PRINT to stdout the branch history of the lp
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_execute_branch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_execute_branch (CCtsp_lp *lp, CCtsp_branchobj *b,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    SETS the lp to realize the branch described in b
    NOTES: returns 2 if the LP becomes infeasible.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_execute_unbranch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_execute_unbranch (CCtsp_lp *lp, CClp_warmstart *warmstart,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    UNDOS the changes to the lp caused by the most recent branch that
     has not yet been unbranched (used in dfs)
     -warmstart can specify a warmstart to help resolve the LP
      (it can be NULL)
    NOTES: returns 2 if the LP is infeasible.
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_add_branchhistory_to_lp
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_add_branchhistory_to_lp (CCtsp_lp *lp)
DESCRIPTION:
    SETS the lp to realize the branches in branch history
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_bb_find_branch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bb_find_branch (char *probname, int probnum, int ncount,
        CCdatagroup *dat, int *ptour, double *upperbound,
        CCtsp_lpcuts *pool, int nwant, int *ngot, CCtsp_branchobj **b,
        int usecliques, int longedge_branching, int *foundtour,
        int *besttour, int silent, CCrandstate *rstate),
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_splitprob
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_splitprob (CCtsp_lp *lp, CCtsp_branchobj *b, int child0,
        int child1, int silent, CCrandstate *rstate)
DESCRIPTION:
    EXECUTES a branch on the lp and writes to two child lps
     -b contains the branching information (the rhs side value is set
      by this function to give 0 and 1 for edge branches and 2 & 4 for
      clique branches; the sense is set by this function for clique
      branches to realize <= 2 and >= 4)
     -child0 and child1 are the ids of the children
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_bb_splitprob
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bb_splitprob (char *probname, int probnum, int ncount,
        CCdatagroup *dat, int *ptour, double initial_ub,
        CCtsp_lpcuts *pool, CCtsp_branchobj *b, int child0,
        int child1, double *val0, double *val1, int *prune0,
        int *prune1, int silent, CCranstate *rstate)
DESCRIPTION:
    CALLS splitprob after reading the lp file and building an lp; this
     function will also price the lp and attempt to verify infeasible
     lps.
     -val0 and val1 return the (priced) lp-bounds for the children; if
      an lp is infeasible then the val is set to CCtsp_LP_MAXDOUBLE and
      the lp is not written.
     -prune0 and prune1 will be set to 1 if the child can be pruned
      (in which case the lp is not written)
END_DESCRIPTION

FILENAME: TSP/branch.c
FUNCTION: CCtsp_dumptour
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_dumptour (int ncount, CCdatagroup *dat, int *perm,
        char *probname, int *tour, int silent)
DESCRIPTION:
    WRITES the tour file to probname.sol.
     -dat is used to compute the length (it can be NULL)
     -perm is a permutation tour
     -tour gives the tour (perm[tour[i]] with be printed)
END_DESCRIPTION

BEGINFILE: TSP/blossom.c

FILENAME: TSP/blossom.c
FUNCTION: CCtsp_exactblossom
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_exactblossom (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x,
        CCrandstate *rstate)
DESCRIPTION:
       RUNS Padberg-Rao to seperate over blossom inequalities.
        -cuts (new cutting plans will be added to front of this list)
        -cutcount will return the number of new cuts found (can be NULL)
        -ncount is the number of nodes
        -ecount is the number of edges
        -elist is the edge list in node node format
        -x is an lp solution vector
    NOTES:
      The exactblossom  code was written very early in our TSP project.
      In January 1999 it was updated to fit into the current concorde,
      but the guts of the code are still written in our old sloppy
      style.  This is a good candidate for a rewrite (big speedups are
      probably possible without too much effort).
END_DESCRIPTION

FILENAME: TSP/blossom.c
FUNCTION: CCtsp_fastblossom
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_fastblossom (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x)
DESCRIPTION:
    FINDS blossoms by looking at 0 < x < 1 graph for connected comps
     meeting an odd number of 1 edges.
END_DESCRIPTION

FILENAME: TSP/blossom.c
FUNCTION: CCtsp_ghfastblossom
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_ghfastblossom (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x)
DESCRIPTION:
    FINDS blossoms using a heuristic described by Groetschel and
     Holland. It works with the 0 < x < 1-EPS (with EPS = .3) graph,
     builds components, and picks a greedy set of teeth.
END_DESCRIPTION

BEGINFILE: TSP/blkcomb.c

FILENAME: TSP/blkcomb.c
FUNCTION: CCtsp_block_combs
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_block_combs (CCtsp_lpcut_in **cuts, int *cutcount,
        int ncount, int ecount, int *elist, double *x, int silent)
DESCRIPTION:
    -ncount is the number of nodes
    -ecount is the number of edges
    -elist is the edge list in node node format
    -x is an lp solution vector
    -silent turns off output if set to a nonzero value
END_DESCRIPTION

BEGINFILE: TSP/bcontrol.c

FILENAME: TSP/bcontrol.c
FUNCTION: CCtsp_bfs_brancher
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bfs_brancher (char *probloc, int id, double lowerbound,
        CCtsp_cutselect *sel, CCtsp_cutselect *tsel,
        double *upbound, int *bbcount, int usecliques,
        CCdatagroup *mydat, int *ptour, CCtsp_lpcuts *pool,
        int ncount, int *besttour, unsigned short hostport,
        double *branchzeit, int save_proof,
        int tentative_branch_num, int longedge_branching,
        double *timebound, int *hit_timebound, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    PERFORMS a best-first (best-bound) branch and cut search for
    an optimal tour.
     -tentative_branch_num specifies the number of trial children
      created (this should be set to 0 to run standard branching)
     -timebound can specify an upperbound on the time to spend in the
      bfs search (it can be NULL; does not work with netgrunts)
     -hit_timebound will return 1 if timebound is reached (it can be
      NULL)
     -if longedge_branching is nonzero, longedge branching will be used
      instead of the default branching
END_DESCRIPTION

FILENAME: TSP/bcontrol.c
FUNCTION: CCtsp_bfs_restart
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_bfs_restart (char *probloc, char *restart_name,
        CCtsp_cutselect *sel, CCtsp_cutselect *tsel,
        double *upbound, int *bbcount, int usecliques,
        CCdatagroup *dat, int *ptour, CCtsp_lpcuts *pool,
        int ncount, int *besttour,  unsigned short hostport,
        double *branchzeit, int save_proof,
        int tentative_branch_num, int longedge_branching,
        double *timebound, int *hit_timebound, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    CONTINUES a best-first (best-bound) branch and cut search for
    an optimal tour from the restart data in restart_name.
END_DESCRIPTION

FILENAME: TSP/bcontrol.c
FUNCTION: CCtsp_grunt
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_grunt (char *hostname, unsigned short hostport,
        char *poolfname, char *cutbossname, char *probloc,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    RUNS a grunt served by hostname at port hostport
    If probloc is NULL, the probloc will be received from the boss.
    Only exists if CC_NETREADY is defined
END_DESCRIPTION

FILENAME: TSP/bcontrol.c
FUNCTION: CCtsp_easy_dfs_brancher
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_easy_dfs_brancher (CCtsp_lp *lp, CCtsp_cutselect *sel,
        int depth, double *upbound, int *bbcount, int usecliques,
        int *besttour, int silent, CCrandstate *rstate)
DESCRIPTION:
    PERFORMS a depth-first branch and cut search for an optimal tour.
    NOTES: this will be very inefficient if upbound is not a good bound.
END_DESCRIPTION

FILENAME: TSP/bcontrol.c
FUNCTION: CCtsp_do_interactive_branch
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_do_interactive_branch (CCtsp_lp *lp, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    SPLITS a problem into two subproblems, prompting the user for
    information about what split to use.
END_DESCRIPTION

BEGINFILE: PQ/pq.c

FILENAME: PQ/pq.c
FUNCTION: CCpq_tree_init
HEADER: pq.h
PROTOTYPE:
    void CCpq_tree_init (CCpq_tree *T)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_tree_free
HEADER: pq.h
PROTOTYPE:
    void CCpq_tree_free (CCpq_tree *T)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_describe_solution
HEADER: pq.h
PROTOTYPE:
    void CCpq_describe_solution (CCpq_tree *T)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_dump_solution
HEADER: pq.h
PROTOTYPE:
    void CCpq_dump_solution (CCpq_tree *T)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_check
HEADER: pq.h
PROTOTYPE:
    int CCpq_check (CCpq_tree *T, int *status)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_apply
HEADER: pq.h
PROTOTYPE:
    int CCpq_apply (CCpq_tree *T, int *status)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_tree_trivial
HEADER: pq.h
PROTOTYPE:
    int CCpq_tree_trivial (CCpq_tree *T, int nodecount, int extern_node)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_cuttree_to_pq
HEADER: pq.h
PROTOTYPE:
    int CCpq_cuttree_to_pq (struct CCtsp_cuttree *ct, CCpq_tree *pqT)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: PQ/pq.c
FUNCTION: CCpq_find_root
HEADER: pq.h
PROTOTYPE:
    CCpq_node *CCpq_find_root (CCpq_tree *T)
DESCRIPTION:
    NONE
END_DESCRIPTION

BEGINFILE: PQ/necklace.c

FILENAME: PQ/necklace.c
FUNCTION: CCpq_necklaces
HEADER: necklace.h
PROTOTYPE:
    CCpq_necklaces (CCtsp_lpcut_in **cuts, int *cutcount,
        CCtsp_cuttree *ctree, int ecount, int *elist, double *x,
        CCrandstate *rstate)
DESCRIPTION:
    NONE
END_DESCRIPTION

BEGINFILE: PQ/consec1.c

FILENAME: PQ/consec1.c
FUNCTION: CCpq_consecutiveones
HEADER: consec1.h
PROTOTYPE:
    int CCpq_consecutiveones (CCtsp_lpcut_in **cuts, int *cutcount,
        CCtsp_cuttree *ctree, CCtsp_lpcuts *pool, int ecount,
        int *elist, double *x)
DESCRIPTION:
    NONE
END_DESCRIPTION

BEGINFILE: LP/lp_none.c

FILENAME: LP/lp_none.c
FUNCTION: CClp_init
HEADER: lp.h
PROTOTYPE:
    int CClp_init (CClp **lp)
DESCRIPTION:
    INITIALIZES the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_force_perturb
HEADER: lp.h
PROTOTYPE:
    int CClp_force_perturb (CClp *lp)
DESCRIPTION:
    Forces a perturbation in the LP simplex solves
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_tune_small
HEADER: lp.h
PROTOTYPE:
    int CClp_tune_small (CClp *lp)
DESCRIPTION:
    SETS solver options for tiny problems.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_disable_presolve
HEADER: lp.h
PROTOTYPE:
    int CClp_disable_presolve (CClp *lp)
DESCRIPTION:
    DISABLES the solvers presolve.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_free
HEADER: lp.h
PROTOTYPE:
    void CClp_free (CClp **lp)
DESCRIPTION:
    FREES the LP, both the allocation in CClp_init () and the
    allocation in CClp_loadlp.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_freelp
HEADER: lp.h
PROTOTYPE:
    void CClp_freelp (CClp **lp)
DESCRIPTION:
    FREES the LP loaded in CClp_loadlp (or CClp_create), but does
    not free the data allocated by CClp_init.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_loadlp
HEADER: lp.h
PROTOTYPE:
    int CClp_loadlp (CClp *lp, const char *name, int ncols, int nrows,
        int objsense, double *obj, double *rhs, char *sense,
        int *matbeg, int *matcnt,
        int *matind, double *matval,
        double *lb, double *ub)
DESCRIPTION:
    LOADS the data into the LP.
      -name attaches a name to the LP (it can be used by the LP solver
       in io routines)
      -ncols and nrows give the number of columns and rows in the LP
      -objsense should be 1 for minimize and -1 for maximize
      -obj and rhs are arrays giving the objective function and rhs
      -sense is an array specifying 'L', 'E', or 'G' for each of the
       rows
      -matbeg, matcnt, matind, and matval give the coefficients of
       the constraint matrix in column by column order. matbeg gives
       gives the index of the start of each column; matcnt gives the
       number of coefficients in each column; matind gives the indices
       of the rows where the coefficients are located in the constraint
       matrix (so for column j, the indices are given in matcnt[j]
       locations starting at matind[matbeg[j]]; and matval gives the
       actual coefficients (organized like matind).
      -lb and ub are arrays giving the upper and lower bounds of
       the variables.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_create
HEADER: lp.h
PROTOTYPE:
    int CClp_create (CClp *lp, const char *name)
DESCRIPTION:
    CREATES an empty lp.  This supports an alternative to CClp_loadlp
    for loading a problem.
      -name attaches a name to the LP (it can be used by the LP solver
       in io routines)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_new_row
HEADER: lp.h
PROTOTYPE:
    int CClp_new_row (CClp *lp, char sense, double rhs)
DESCRIPTION:
    ADDS a new empty row to the lp
      -sense is 'L', 'E', or 'G' for a <=, =, or >= constraint
      -rhs is the right-hand side of the row
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_change_sense
HEADER: lp.h
PROTOTYPE:
    int CClp_change_sense (CClp *lp, int row, char sense)
DESCRIPTION:
    CHANGES the sense of a row
      -row is the row number to change
      -sense is 'L', 'E', or 'G' to change to <=, =, or >=
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_opt
HEADER: lp.h
PROTOTYPE:
    int CClp_opt (CClp *lp, int method)
DESCRIPTION:
    CALLS designated LP solution method.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_limited_dualopt
HEADER: lp.h
PROTOTYPE:
    int CClp_limited_dualopt (CClp *lp, int lim, int *status,
        double *upperbound)
DESCRIPTION:
    CALLS the dual simplex method with a limit on the number of pivots.
      -upperbound it is used to cutoff the dual simplex method (when
       the objective value reaches upperbound); it can be NULL
      -status returns the status of the optimization (it can be NULL)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_addrows
HEADER: lp.h
PROTOTYPE:
    int CClp_addrows (CClp *lp, int newrows, int newnz, double *rhs,
        char *sense, int *rmatbeg, int *rmatind, double *rmatval)
DESCRIPTION:
    ADDS the rows to the LP.
      -newrows is the number of rows to be added
      -newnz is the number of nonzero coefficients in the new rows
      -rhs is an array of the rhs values for the new rows
      -sense is 'L', 'E', or 'G' for each of the new rows
      -rmatbeg, rmatind, and rmatval give the coefficients of the
       new rows in sparse format. The arrays can be freed after the
       call.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_addcols
HEADER: lp.h
PROTOTYPE:
    int CClp_addcols (CClp *lp, int newcols, int newnz, double *obj,
        int *cmatbeg, int *cmatind, double *cmatval,
        double *lb, double *ub)
DESCRIPTION:
    ADDS the columns to the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_delete_row
HEADER: lp.h
PROTOTYPE:
    int CClp_delete_row (CClp *lp, int i)
DESCRIPTION:
    DELETES row i of the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_delete_set_of_rows
HEADER: lp.h
PROTOTYPE:
    int CClp_delete_set_of_rows (CClp *lp, int *delstat)
DESCRIPTION:
    DELETES the rows corresponding to 1 entries in delstat.
      -delstat is a 0/1 array having an entry for each row
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_delete_column
HEADER: lp.h
PROTOTYPE:
    int CClp_delete_column (CClp *lp, int i)
DESCRIPTION:
    DELETES column i from the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_delete_set_of_columns
HEADER: lp.h
PROTOTYPE:
    int CClp_delete_set_of_columns (CClp *lp, int *delstat)
DESCRIPTION:
    DELETES the columns corresponding to the 1 entries in delstat.
      -delstat is a 0/1 array having an entry for each column
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_setbnd
HEADER: lp.h
PROTOTYPE:
    int CClp_setbnd (CClp *lp, int col, char lower_or_upper, double bnd)
DESCRIPTION:
    SETS the bound on the variable index by col.
      -lower_or_upper should be either 'L' or 'U'
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_get_warmstart
HEADER: lp.h
PROTOTYPE:
    int CClp_get_warmstart (CClp *lp, CClp_warmstart **w)
DESCRIPTION:
    SAVES information for efficiently resolving the current lp in w,
    for example, basis or norm information
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_load_warmstart
HEADER: lp.h
PROTOTYPE:
    int CClp_load_warmstart (CClp *lp, CClp_warmstart *w)
DESCRIPTION:
    RESTORES the warmstart information in w.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_build_warmstart
HEADER: lp.h
PROTOTYPE:
    int CClp_build_warmstart (CClp_warmstart **w, CClp_info *i)
DESCRIPTION:
    BUILDS some warmstart information from the row/column information
    in i.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_free_warmstart
HEADER: lp.h
PROTOTYPE:
    void CClp_free_warmstart (CClp_warmstart **w)
DESCRIPTION:
    FREES the memory used by w.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_sread_warmstart
HEADER: lp.h
PROTOTYPE:
    int CClp_sread_warmstart (CC_SFILE *f, CClp_warmstart **w)
DESCRIPTION:
    READS warmstart information from the f.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_swrite_warmstart
HEADER: lp.h
PROTOTYPE:
    int CClp_swrite_warmstart (CC_SFILE *f, CClp_warmstart *w)
DESCRIPTION:
    WRITES warmstart information from the f.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_get_info
HEADER: lp.h
PROTOTYPE:
    int CClp_get_info (CClp *lp, CClp_info **i)
DESCRIPTION:
    BUILDS information useful for efficiently answering questions
    about the status of rows and columns
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_create_info
HEADER: lp.h
PROTOTYPE:
    int CClp_create_info (CClp_info **i, int rcount, int ccount)
DESCRIPTION:
    CREATES a structure for storing information about the status of
    rows and columns.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_is_col_active
HEADER: lp.h
PROTOTYPE:
    int CClp_is_col_active (CClp_info *i, int c)
DESCRIPTION:
    returns 1 if column e is active, 0 otherwise.
    "active" means participating in the current solution (for example,
    it could mean basic or nonbasic at upper bound)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_is_row_active
HEADER: lp.h
PROTOTYPE:
    int CClp_is_row_active (CClp_info *i, int r)
DESCRIPTION:
    returns 1 if row e is active, 0 otherwise.
    "active" means participating in the current solution (for example,
    it could mean the row's slack is non-basic)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_set_col_active
HEADER: lp.h
PROTOTYPE:
    void CClp_set_col_active (CClp_info *i, int c)
DESCRIPTION:
    marks column e as active (for eventual CClp_build_warmstart)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_set_col_inactive
HEADER: lp.h
PROTOTYPE:
    void CClp_set_col_inactive (CClp_info *i, int c)
DESCRIPTION:
    marks column e as inactive (for eventual CClp_build_warmstart)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_set_col_upper
HEADER: lp.h
PROTOTYPE:
    void CClp_set_col_upper (CClp_info *i, int c)
DESCRIPTION:
    marks column e as active at upper bound (for eventual
    CClp_build_warmstart)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_set_row_active
HEADER: lp.h
PROTOTYPE:
    void CClp_set_row_active (CClp_info *i, int r)
DESCRIPTION:
    marks row r as active (for eventual CClp_build_warmstart)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_set_row_inactive
HEADER: lp.h
PROTOTYPE:
    void CClp_set_row_inactive (CClp_info *i, int r)
DESCRIPTION:
    marks row r as inactive (for eventual CClp_build_warmstart)
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_free_info
HEADER: lp.h
PROTOTYPE:
    void CClp_free_info (CClp_info **i)
DESCRIPTION:
    FREES the memory used by i.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_x
HEADER: lp.h
PROTOTYPE:
    int CClp_x (CClp *lp, double *x)
DESCRIPTION:
    RETURNS the current LP solution.
      -x should be an array of length at least ncols
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_rc
HEADER: lp.h
PROTOTYPE:
    int CClp_rc (CClp *lp, double *rc)
DESCRIPTION:
    RETURNS the current reduced costs.
      -rc should be an array of length at least ncols
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_pi
HEADER: lp.h
PROTOTYPE:
    int CClp_pi (CClp *lp, double *pi)
DESCRIPTION:
    RETURNS the dual values on the constraints.
      -pi should be an array of length at least nrows
    NOTES: If the lp and dual lp are feasible, these pi values are
      the traditional dual solution.  If the dual is unbounded, these
      pi satisfy

       pi_i <= 0  for <= constraints
       pi_i >= 0  for >= constraints

       pi'b - sum (pi'A_j * u_j: pi'A_j > 0)
            - sum (pi'A_j * l_j: pi'A_j < 0) > 0

    where b is the rhs vector, u_j is the upper bound on variable x_j,
    l_j the lower bound, and A_j the constraint matrix column for x_j.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_objval
HEADER: lp.h
PROTOTYPE:
    int CClp_objval (CClp *lp, double *obj)
DESCRIPTION:
    RETURNS the objective value of the lp.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_nrows
HEADER: lp.h
PROTOTYPE:
    int CClp_nrows (CClp *lp)
DESCRIPTION:
    RETURNS the number of rows in the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_ncols
HEADER: lp.h
PROTOTYPE:
    int CClp_ncols (CClp *lp)
DESCRIPTION:
    RETURNS the number of columns in the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_nnonzeros
HEADER: lp.h
PROTOTYPE:
    int CClp_nnonzeros (CClp *lp)
DESCRIPTION:
    RETURNS the number of nonzeros in the LP.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_status
HEADER: lp.h
PROTOTYPE:
    int CClp_status (CClp *lp, int *status)
DESCRIPTION:
    CHECKS whether the current lp is infeasible or whether an optimal
     solution has been found. It returns an error if the LP has not
     not been optimized.
      -lp is the lp
      -status returns 0 if the lp has an optimal solution and 1 if it
       is infeasible.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_getweight
HEADER: lp.h
PROTOTYPE:
    int CClp_getweight (CClp *lp, int nrows, int *rmatbeg, int *rmatind,
        double *rmatval, double *weight)
DESCRIPTION:
    COMPUTES the duals of the steepest edge norms for the n rows
     specified in rmatbeg, rmatind, and rmatval.
      -weight returns the array of weights; the array should be at
       least nrows long
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_dump_lp
HEADER: lp.h
PROTOTYPE:
    int CClp_dump_lp (CClp *lp, const char *fname)
DESCRIPTION:
    WRITES the LP to file fname.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_getgoodlist
HEADER: lp.h
PROTOTYPE:
    int CClp_getgoodlist (CClp *lp, int *goodlist, int *goodlen_p,
        double *downpen, double *uppen)
DESCRIPTION:
    RETURNS an array of the column indices corresponding to variables
     that move in both the up and down directions. This is a useful
     list of candidates for strong branching.
      -goodlist, downpen and uppen should be arrays of length at
       least ncols.
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_strongbranch
HEADER: lp.h
PROTOTYPE:
    int CClp_strongbranch (CClp *lp, int *candidatelist, int ncand,
        double *downpen, double *uppen, int iterations,
        double upperbound)
DESCRIPTION:
    RETURNS estimates of the lp values obtained by setting each of the
      ncand variables listed in candidatelist to 0 and 1. The estimates
      are obtained by performing iterations pivots of dual simplex
      method. upperbound is used to cutoff the dual simplex method.
      downpen and uppen should never be > upperbound.
       -downpen and uppen should be arrays of length at least ncand
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_pivotout
HEADER: lp.h
PROTOTYPE:
    void CClp_pivotout (CClp *lp, int j)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LP/lp_none.c
FUNCTION: CClp_pivotin
HEADER: lp.h
PROTOTYPE:
    void CClp_pivotin (CClp *lp, int i)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LINKERN/linkern.c

FILENAME: LINKERN/linkern.c
FUNCTION: CClinkern_tour
HEADER: linkern.h
PROTOTYPE:
    int CClinkern_tour (int ncount, CCdatagroup *dat, int ecount,
        int *elist, int stallcount, int repeatcount, int *incycle,
        int *outcycle, double *val
        int silent, double time_bound, double length_bound,
        char *saveit_name, int kicktype, CCrandstate *rstate)
DESCRIPTION:
    RUNS Iterated Lin-Kernighan.
    -ncount (the number of nodes int the graph)
    -dat (coordinate dat)
    -ecount (the number of good edges - should not be 0)
    -elist (the good edges in end1 end2 format)
    -stallcount (the max number of 4-swaps without progress
    -repeatcount (the number of 4-swap kicks)
    -incycle (a starting cycle, in node node node format - can be NULL)
    -outcycle (returns the cycle - can be NULL)
    -run_slightly (if nonzero, then very little info will be printed)
    -time_bound (if postive, then the search will stop after the kick
       that puts the running time above this number of seconds)
    -length_bound (if postive, then the search will stop after the kick
       that puts the tour at or below this length)
    -saveit_name (if non NULL then the tour will be saved to this file
       after every 10000 kicks - if it has improved)
    -kicktype (specifies the type of kick used - should be one of
       CC_LK_RANDOM_KICK, CC_LK_GEOMETRIC_KICK, or CC_LK_CLOSE_KICK)

    NOTES: If incycle is NULL, then a random starting cycle is used. If
     outcycle is not NULL, then it should point to an array of length
     at least ncount.
END_DESCRIPTION

BEGINFILE: LINKERN/flip_two.c

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_init
HEADER: linkern.h
PROTOTYPE:
    int CClinkern_flipper_init (CClk_flipper *f, int ncount, int *cyc)
DESCRIPTION:
    initializes flipper to an initial cycle given in cyc.
    returns 0 on success, nonzero on failure.
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_cycle
HEADER: linkern.h
PROTOTYPE:
    void CClinkern_flipper_cycle (CClk_flipper *F, int *x)
DESCRIPTION:
    places the current cycle in x.
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_finish
HEADER: linkern.h
PROTOTYPE:
    void CClinkern_flipper_finish (CClk_flipper *F)
DESCRIPTION:
    frees up space allocated by CClinkern_flipper_init.
    every CClinkern_flipper_init should lead to a
    CClinkern_flipper_finish call.
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_next
HEADER: linkern.h
PROTOTYPE:
    int CClinkern_flipper_next (CClk_flipper *f, int x)
DESCRIPTION:
    returns the successor to x in the current cycle.
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_prev
HEADER: linkern.h
PROTOTYPE:
    int CClinkern_flipper_prev (CClk_flipper *f, int x)
DESCRIPTION:
    returns the predecessor of x in the current cycle.
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_flip
HEADER: linkern.h
PROTOTYPE:
    void CClinkern_flipper_flip (CClk_flipper *F, int x, int y)
DESCRIPTION:
    flips the portion of the cycle from x to y (inclusive).
END_DESCRIPTION

FILENAME: LINKERN/flip_two.c
FUNCTION: CClinkern_flipper_sequence
HEADER: linkern.h
PROTOTYPE:
    int CClinkern_flipper_sequence (CClk_flipper *f, int * x, int y,
        int z)
DESCRIPTION:
    returns 1 if xyz occur as an increasing subsequence of the cycle,
    returns 0 otherwise.
END_DESCRIPTION

BEGINFILE: KDTREE/kdtwoopt.c

FILENAME: KDTREE/kdtwoopt.c
FUNCTION: CCkdtree_twoopt_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_twoopt_tour (CCkdtree *kt, int ncount, CCdatagroup *dat,
        int *incycle, int *outcycle, double *val,
        int run_two_and_a_half_opt, int silent, CCrandstate *rstate)
DESCRIPTION:
    RETURNS a 2-opted cycle (well, approximately 2-opted)
      -kt can be NULL.
      -Does not use node weights.
      -incycle is the starting cycle.
      -If outcycle is not NULL, then it should point to an array of
       length at least ncount (allocated by the calling routine). The
       final tour will be placed in this array.
      -The length of the tour is returned in val.
      -If in_run_two_and_a_half_opt is nonzero,  then some limited
       3-swapping is performded.
      -silent (if nonzero then very little info will be printed)
END_DESCRIPTION

FILENAME: KDTREE/kdtwoopt.c
FUNCTION: CCkdtree_3opt_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_3opt_tour (CCkdtree *kt, int ncount, CCdatagroup *dat,
        int *incycle, int *outcycle, double *val, silent,
        CCrandstate *rstate)
DESCRIPTION:
    RETURNS an approximately 3-opted tour.
      -kt can be NULL.
END_DESCRIPTION

BEGINFILE: KDTREE/kdspan.c

FILENAME: KDTREE/kdspan.c
FUNCTION: CCkdtree_prim_spanningtree
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_prim_spanningtree (CCkdtree *kt, int ncount,
        CCdatagroup *dat, double *wcoord, int *outtree, double *val,
        CCrandstate *rstate)
DESCRIPTION:
    RETURNS a min weight spanning tree.
      -kt is a pointer to a CCkdtree built by a call to CCkdtree_build.
       If kt is NULL, then CCkdtree_build will be called.
      -If wcoord is not NULL, then the array should have nonnegative
       values. The code will use Held-Karp style distances.
      -If outtree is non NULL, it should point to an array of length
       at least 2*ncount - 2. The edges in the min spanning tree will
       be returned in the array in end end format.
      -The length of the min tree is returned in val.
END_DESCRIPTION

FILENAME: KDTREE/kdspan.c
FUNCTION: CCkdtree_greedy_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_greedy_tour (CCkdtree *kt, int ncount, CCdatagroup *dat,
        int *outcycle, double *val, int silent, CCrandstate *rstate)
DESCRIPTION:
    RETURNS a greedy tour. (No randomization (expect in building the
      CCkdtree) so there is no point in calling this more than once)
     -kt can be NULL.
     -Does not use node weights.
     -If outcycle is non NUL, it should point to an array of length
      at least ncount. The cycle will be returned in node node node
      format.
END_DESCRIPTION

FILENAME: KDTREE/kdspan.c
FUNCTION: CCkdtree_far_add_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_far_add_tour (CCkdtree *kt, int ncount, int start,
        CCdatagroup *dat, int *outcycle, double *val, CCrandstate *rstate)
DESCRIPTION:
    RETURNS a farthest addition tour, beginning with node start.
     -like CCkdtree_greedy_tour.
END_DESCRIPTION

FILENAME: KDTREE/kdspan.c
FUNCTION: CCkdtree_qboruvka_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_qboruvka_tour (CCkdtree *kt, int ncount,
        CCdatagroup *dat, int *outcycle, double *val, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: KDTREE/kdspan.c
FUNCTION: CCkdtree_boruvka_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_boruvka_tour (CCkdtree *kt, int ncount,
        CCdatagroup *dat, int *outcycle, double *val, CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: KDTREE/kdnear.c

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_k_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_k_nearest (CCkdtree *kt, int ncount, int k,
        CCdatagroup *dat, double *wcoord, int wantlist, int *ocount,
        int **olist, int silent, CCrandstate *rstate)
DESCRIPTION:
    RETURNS the k-nearest neighbor graph.
      -kt can be NULL, otherwise it should point to a CCkdtree built
       by a call to kdbuild ()
      -ncount is the number of points.
      -k is the number of nearest neighbors wanted.
      -wcoord is an array of node weights (like Held-Karp), it can
       be NULL. The weights should be nonnegative.
      -wantlist is 1 if you want the function to return the edges.
      -ocount returns the number of edges (if wantlist is 1) and
       olist returns the edgelist is end1 end2 format.
      -silent will turn off print messages if set to nonzero value.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_quadrant_k_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_quadrant_k_nearest (CCkdtree *kt, int ncount, int k,
        CCdatagroup *dat, double *wcoord,
        int wantlist, int *ocount, int **olist, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    RETURNS the quadrant k-nearest neighbor graph.
      -see CCkdtree_k_nearest.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_node_k_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_node_k_nearest (CCkdtree *kt, int ncount, int n, int k,
        CCdatagroup *dat, double *wcoord, int *list, CCrandstate *rstate)
DESCRIPTION:
    RETURNS the k nearest points to point n.
      -The k points are return in list (and list must be allocated by
       calling routine.
      -kt is a pointer to a CCkdtree previously built by
       CCkdtree_build.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_node_quadrant_k_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_node_quadrant_k_nearest (CCkdtree *kt, int ncount,
        int n, int k, CCdatagroup *dat, double *wcoord, int *list,
        CCrandstate *rstate)
DESCRIPTION:
    RETURNS the quadrant k nearest point to point n.
      -see CCkdtree_node_k_nearest.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_node_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_node_nearest (ktree *kt, int n, CCdatagroup *dat,
        double *wcoord)
DESCRIPTION:
    RETURNS the nearest point to point n.
      -kt CANNOT be NULL.
      -The point is returned as the function value. kt is a pointer
       to a CCkdtree (previously buildt by a call to CCkdtree_build)
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_fixed_radius_nearest
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_fixed_radius_nearest (CCkdtree *kt, CCdatagroup *dat,
        double *wcoord, int n, double rad,
        int (*doit_fn) (int, int, void *), void *pass_param)
DESCRIPTION:
    ACTION: Calls the function doit_fn (n, a, void *), where a ranges
            over all points within distance rad of the point n. The
            void * field can be used to bundle a group of parmeters
            into pass_param that will be passed to doit_fn.
      -kt CANNOT be NULL.
      -doit_fn can also call CCkdtree_fixed_radius_nearest (no globals
       are set by the function calls)
      -pass_param can be NULL or used to point to a structure with
       with parameters for doit_fn.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_nearest_neighbor_tour
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_nearest_neighbor_tour (CCkdtree *kt, int ncount,
        int start, CCdatagroup *dat, int *outcycle, double *val,
        CCrandstate *rstate)
DESCRIPTION:
    -kt can be NULL.
    -Node weights are not used.
    -start is the starting node for the tour.
    -if outcycle is not NULL, then it should point to a array of
     length at least ncount (allocated by the calling routine). The
     cycle will be returned in the array in node node node format.
    -the length of the tour is return in val.
END_DESCRIPTION

FILENAME: KDTREE/kdnear.c
FUNCTION: CCkdtree_nearest_neighbor_2match
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_nearest_neighbor_2match (CCkdtree *kt, int ncount,
        int start, CCdatagroup *dat, int *outmatch, double *val,
        CCrandstate *rstate)
DESCRIPTION:
    -Like CCkdtree_nearest_neighbor_tour. If outmatch is not NULL
     then it should point to an array of length at least 2*ncount.

    NOTES:
       If memory is tight, use CCkdtree_node_k_nearest to get the
    edges one node at a time. (CCkdtree_k_nearest () builds a hash
    table to avoid duplicate edges, and it will use 8 * nedges
    bytes.)
       CCkdtree_node_nearest returns the nearest point as the
    function value; CCkdtree_fixed_radius_nearest returns 1 if
    doit_fn returns a nonzero value, otherwise it returns 0; all
    other routines return 0 if successful and 1 otherwise.
END_DESCRIPTION

BEGINFILE: KDTREE/kdbuild.c

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_build
HEADER: kdtree.h
PROTOTYPE:
    int CCkdtree_build (CCkdtree *kt, int ncount, CCdatagroup *dat,
        double *wcoord, CCrandstate *rstate)
DESCRIPTION:
    -When called, intree should point to a CCkdtree struct that the
     funtion will load with the tree it builds. The wcoord array
     is used for node weights (like in Held-Karp), it can be NULL.
     The node weights must be nonegative (for cutoffs).
END_DESCRIPTION

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_free
HEADER: kdtree.h
PROTOTYPE:
    void CCkdtree_free (CCkdtree *kt)
DESCRIPTION:
    -Frees the space (including the ptrs) used by kt.
END_DESCRIPTION

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_delete
HEADER: kdtree.h
PROTOTYPE:
    void CCkdtree_delete (CCkdtree *kt, int k)
DESCRIPTION:
    -Deletes the point k from the CCkdtree kt.
END_DESCRIPTION

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_undelete
HEADER: kdtree.h
PROTOTYPE:
    void CCkdtree_undelete (CCkdtree *kt, int k)
DESCRIPTION:
    -Puts the previously deleted point k back into kt.
END_DESCRIPTION

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_delete_all
HEADER: kdtree.h
PROTOTYPE:
    void CCkdtree_delete_all (CCkdtree *kt, int ncount)
DESCRIPTION:
    -Deletes all points in kt.
END_DESCRIPTION

FILENAME: KDTREE/kdbuild.c
FUNCTION: CCkdtree_undelete_all
HEADER: kdtree.h
PROTOTYPE:
    void CCkdtree_undelete_all (CCkdtree *kt, int ncount)
DESCRIPTION:
         -Puts all deleted points back in kt. Used to cleanup trees.

    NOTES:
       On a 32 bit machine, a CCkdtree on n nodes needs about 52n
     bytes of memory. CCkdtree_build will return 1 if an error
     occurs (most likely running out of memory).
       CCutil_sprand () should be called before calling
     CCkdtree_build ().
END_DESCRIPTION

BEGINFILE: HELDKARP/heldkarp.c

FILENAME: HELDKARP/heldkarp.c
FUNCTION: CCheldkarp_small
HEADER: heldkarp.h
PROTOTYPE:
    int CCheldkarp_small (int ncount, CCdatagroup *dat, double *upbound,
        double *optval, int *foundtour, int anytour, int nodelimit,
        int silent)
DESCRIPTION:
    -ncount is the number of nodes in the graph.
    -dat specifies the information needed to compute the edge lengths.
    -upbound is an upperbound on the optimal tour length (it can be
     NULL)
    -optval returns the length of an optimal tour (or the upperbound
     if no better tour is found, or the value of the first tour found
     that it better than upbound if anytour = 1 is specified)
    -foundtour will be set to 1 if a tour better than upbound is found
    -anytour should be set to 1 to cut off the search after any tour
     better than upbound is found (it may not be an optimal tour)
    -nodelimit specifies a limit on the number of search nodes (use -1
     to impose no limit)
    -silent should be set to 1 to restrict the output and 2 to
     disable all normal output
END_DESCRIPTION

FILENAME: HELDKARP/heldkarp.c
FUNCTION: CCheldkarp_small_elist
HEADER: heldkarp.h
PROTOTYPE:
    int CCheldkarp_small_elist (int ncount, int ecount, int *elist,
        int *elen, int *upbound, int *optval, int *foundtour,
        int anytour, int nodelimit, int silent)
DESCRIPTION:
     USES edgelist rather than datagroup.
      -ecount is the number of edges in the graph.
      -elist is the list of edges in end0 end1 format.
      -elen is a list of the edge lengths.

    NOTES: The upperbound will be converted to an int.
           Graph can have at most MAX_NODES with edge lengths no greater
           than  WEIGHT_MAX_EDGE
           The code was designed for problems in the range of 25 to 35
           nodes.
END_DESCRIPTION

BEGINFILE: FMATCH/fmatch.c

FILENAME: FMATCH/fmatch.c
FUNCTION: CCfmatch_fractional_2match
HEADER: fmatch.h
PROTOTYPE:
    int CCfmatch_fractional_2match (int ncount, int ecount, int *elist,
        int *elen, CCdatagroup *dat, double *val, int *thematching,
        int *thedual, int *thebasis, int wantbasic, int silent,
        CCrandstate *rstate)
DESCRIPTION:
       int ncount (the number of nodes in the graph)
       int ecount (the number of edges)
       int *elist (the edgelist in end1 end2 format)
       int *elen (the weights on the edges)
       CCdatagroup *dat (the info to price edges - NULL if no pricing)
       double *xcoord (the x-coordinates for geometric problems - this
                       field can be NULL)
       double *ycoord (the y-coordinates)
       int innorm (the NORM for pricing the complete edgeset)
       double *val (returns the optimal weight)
       int *thematching (if non-NULL, then returns the optimal matching
                         in end1 end2 value format, where value is 1 if
                         edge gets assigned 0.5 and value is 2 if edge
                         gets 1.0 - note that the array should be
                         allocated by the calling routine, and should
                         be 6 * ncount + 1 long - it is terminated by a
                         -1)
       int *thedual (if non-NULL, then returns the optimal dual solution
                     with values twice their actual value (so they will
                     be integers - the array should be alloced by the
                     calling routine, and should be ncount long)
       int *thebasis (if non-NULL, then returns the edges in the optimal
                      basis in end1 end2 format)
       int wantbasis (if nonzero, then the optimal basic solution will
                      be found)
       int silent (if nonzero, will suppress print messages)

    NOTES:
       Use to find an optimal basis for the initial tsp LP. By changing
    MATCHDEGREE to 1, it should find min-wieght fractional matchings.
       The nodes should be numbered from 0 up to ncount - 1. If dat
    is specified, then the code will use a price-repair loop to solve
    the problem over the complete graph.
END_DESCRIPTION

BEGINFILE: EDGEGEN/xnear.c

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_k_nearest (int ncount, int k, CCdatagroup *dat,
        double *wcoord, int wantlist, int *ecount, int **elist,
        int silent)
DESCRIPTION:
    RETURNS the k_nearest neighbor graph (for X-Norms)
      -ncount is the number of nodes
      -k is the number of nearest neighbors wanted
      -dat contains the info to generate edge lengths
      -wcoord are nodeweights for Held-Karp style edge lengths, using
       len[i,j] + wcoord[i] + wcoord[j] (wcoord can be NULL)
      -wantlist should be set to 0 if you don't want the edges
      -ecount returns the number of edges if wantlist is 1
      -elist returns the edges in end1 end2 format if wantlist is 1
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_quadrant_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_quadrant_k_nearest (int ncount, int k,
        CCdatagroup *dat, double *wcoord, int wantlist, int *ecount,
        int **elist, int silent)
DESCRIPTION:
    RETURNS the quadrant k_nearest_graph (for X-Norms)
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_node_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_node_k_nearest (CCxnear *xn, int n, int k,
        int ncount, int *list)
DESCRIPTION:
    RETURNS the k nearest neighbors from node n (for X-Norms
      -xn is a structure built by a call to CCedgegen_xnear_build ()
      -list returns the neighbors of n. The calling routine should
       be sure that list points to an array of length at least num.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_node_quadrant_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_node_quadrant_k_nearest (CCxnear *xn, int n, int k,
        int ncount, int *list)
DESCRIPTION:
    RETURNS the quadrant k nearest to node n (for X-Norms)
      -xn is a structure built by a call to CCedgegen_xnear_build ()
      -list returns the neighbors of n. The calling routine should
       be sure that list points to a sufficiently large array (4*num
       for D2_SIZE norms and 8*num for D3_SIZE norms)
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_node_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_node_nearest (CCxnear *xn, int ncount, int ni,
        char *marks)
DESCRIPTION:
    RETURNS the nearest unmarked node to node n (as the return value)
      -marks is an array. The entries that are nonzero correspond to
       nodes that will not be looked at in the search.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_x_nearest_neighbor_tour
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_x_nearest_neighbor_tour (int ncount, int start,
        CCdatagroup *dat, int *outcycle, double *val)
DESCRIPTION:
    RETURNS a nearest neighbor tour, starting at node start.
      -outcycle will contain the tour if it is not NULL (the calling
       routine should be sure it points to an array of length at
       least ncount if it is not set to NULL)
      -val will return the length of the tour.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_junk_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_junk_k_nearest (int ncount, int k, CCdatagroup *dat,
        double *wcoord, int wantlist, int *ecount, int **elist,
        int silent)
DESCRIPTION:
    RETURNS the k-nearest graph (for JUNK-Norms)
      -see CCedgegen_x_k_nearest (above) for the variables
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_junk_node_k_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_junk_node_k_nearest (CCdatagroup *dat, double *wcoord,
        int n, int k, int ncount, int *list)
DESCRIPTION:
    RETURNS the k nearest neighbors to node n (for JUNK-Norms)
      -list returns the neighbors of n. The calling routine should
       be sure that list points to an array of length at least num.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_junk_node_nearest
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_junk_node_nearest (CCdatagroup *dat, double *wcoord,
        int ncount, int n, char *marks)
DESCRIPTION:
    RETURNS the nearest unmarked node to node n (as the return value)
      -marks is an array, the nodes with marks[i] nonzero are ignored.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_junk_nearest_neighbor_tour
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_junk_nearest_neighbor_tour (int ncount, int start,
        CCdatagroup *dat, int *outcycle, double *val, int silent)
DESCRIPTION:
    RETURNS a nearest neighbor tour starting at node start. Note that
      this will be slow for large problems (it is a quadratic routine)
      -see the describtion of CCedgegen_x_nearest_neighbor_tour above
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_xnear_build
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_xnear_build (int ncount, CCdatagroup *dat,
        double *wcoord, CCxnear *xn)
DESCRIPTION:
    RETURNS the structure needed for calls to
      CCedgegen_x_node_k_nearest and
      CCedgegen_x_node_quadrant_k_nearest (the calling routine should
      be sure that xn points to such a structure). All this routine
      does is permute the data so that the x coordinates are in
      nonincreasing order.
END_DESCRIPTION

FILENAME: EDGEGEN/xnear.c
FUNCTION: CCedgegen_xnear_free
HEADER: edgegen.h
PROTOTYPE:
    void CCedgegen_xnear_free (CCxnear *xn)
DESCRIPTION:
        FREES the CCxnear structure pointed to by xn

    NOTES:
         All routines other than CCedgegen_xnear_free and
       CCedgegen_x_node_nearest return 0 on success and 1 on failure
       (normally due to running out of memory).
         The X-Norm functions will also work for KD-Norms, but they are
       much slower than the KD-Norm functions.
END_DESCRIPTION

BEGINFILE: EDGEGEN/mlinkern.c

FILENAME: EDGEGEN/mlinkern.c
FUNCTION: CCedgegen_mlinkern
HEADER: mlinkern.h
PROTOTYPE:
    int CCedgegen_mlinkern (int ncount, CCdatagroup *dat, int wantlist,
        int *ecount, int **elist, CCkdtree *kt, int iterations,
        CCrandstate *rstate)
DESCRIPTION:
    COMPUTES the edge set of union of Chained Lin-Kernighan matchings.
       -ncount is the number of nodes in the graph
       -dat gives the data to generate edge lengths
       -if wantlist is nonzero, then the edgeset will be returned
       -ecount will return the number of edges found (if wantlist)
       -elist will return the matching in end end format (if wantlist)
       -kt is a pointer to a kd-tree
       -iterations is the number of Chained LK kicks matchings

    NOTES:
      Code is only set up for norms of CC_KD_NORM_TYPE.
END_DESCRIPTION

BEGINFILE: EDGEGEN/edgegen.c

FILENAME: EDGEGEN/edgegen.c
FUNCTION: CCedgegen_read
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_read (char *egname, CCedgegengroup *plan)
DESCRIPTION:
    READS an edgegen description from file egname.
      -egname the name of a file
      -plan returns the description of the mix of edges (can be used
       in a call to CCedgegen_edges () to obtain the edgeset).
END_DESCRIPTION

FILENAME: EDGEGEN/edgegen.c
FUNCTION: CCedgegen_edges
HEADER: edgegen.h
PROTOTYPE:
    int CCedgegen_edges (CCedgegengroup *plan, int ncount,
        CCdatagroup *dat, double *wcoord, int *ecount, int **elist,
        int silent, CCrandstate *rstate)
DESCRIPTION:
    RETURNS the set of edges described in plan.
      -plan describes the mix of edges
      -ncount is the number of nodes
      -dat contains the info to generate edge lengths
      -wcoord are nodeweights for Held-Karp style edge lengths, using
       len[i,j] + wcoord[i] + wcoord[j] (wcoord can be NULL)
      -ecount returns the number of edges
      -elist returns the edges in end1 end2 format
      -silent will suppress print messages if set to a nonzero value.
END_DESCRIPTION

FILENAME: EDGEGEN/edgegen.c
FUNCTION: CCedgegen_init_edgegengroup
HEADER: edgegen.h
PROTOTYPE:
    void CCedgegen_init_edgegengroup (CCedgegengroup *plan)
DESCRIPTION:
        SETS the fields in plan to 0 (since there are so many fields to
          to deal with)

    NOTES:
       To use CCedgegen_edges, look at the defintion of CCedgegengroup
    in edgegen.h - you should be able to guess what the parmeters mean.
    Note that wcoord is only used by a limited number of the generating
    routines, for example nearest, but not linkern.
       The functions CCedgegen_edges and CCedgegen_read will return
    nonzero values if they fail (for example, if they run out of memory.
       The description file passed to CCedgegen_read should contain a
    list of some of the following commands:
            EDGEGEN RANDOM #
                    -find # random edges
            EDGEGEN NEAREST #
                    -find the nearest # edges
            EDGEGEN QUADNEAREST #
                    -find the quadrant-nearest # edges
            EDGEGEN FRAC_TWOMATCH_NEAREST # [PRICED] [BASIC]
                    -find the nearest # using the reduced costs of a
                     fractional 2-matching as the edgelengths. If either
                     of the optional arguments PRICED or BASIC is
                     specified then the 2-matching used will be either
                     priced against the complete edgeset or converted to
                     a basic optimal solution (or both).
            EDGEGEN GREEDY_TOUR
                    -find a greedy tour
            EDGEGEN BORUVKA_TOUR
                    -find a Boruvka tour
            EDGEGEN QBORUVKA_TOUR
                    -find a quick Boruvka tour
            EDGEGEN NN_TOUR #
                    -find # nearest-neighbor tours
            EDGEGEN RANDOM_TOUR #
                    -find # random tours
            EDGEGEN TWOOPT_TOUR #
                    -find # 2-opt tours
            EDGEGEN TWOPT5_TOUR #
                    -find # 2.5-opt tours
            EDGEGEN THREEOPT_TOUR #
                    -find # 3-opt tours
            EDGEGEN LINKERN #1 #2 [QUADNEAREST #3] [NEAREST #4]
                              [GREEDY_START | NN_START | RANDOM_START
                               | BORUVKA_START | QBORUVKA_START]
                    -find #1 Iterated Lin-Kernighan tours using #2
                     kicks.
                     The good edgeset can be specified by the optional
                     arguments QUADNEAREST and NEAREST (the two can be
                     used together). The initial tours can be specfied
                     by using one of GREEDY_START, NN_START,
                     BORUVKA_START, QBORUVKA_START, or RANDOM_START.
            EDGEGEN NN_TWOMATCH #
                    -find # nearest-neighbor 2-matchings
            EDGEGEN TREE
                    -find a minimum weight spanning tree.
            EDGEGEN FRAC_TWOMATCH [PRICED] [BASIC]
                    -find a minmum weight 2-matching (priced against the
                     complete edgeset) (that is a basic optimal
                     solution) 
            EDGEGEN DELAUNAY
                    -find the edges in the (Euclidean-norm) Delaunay
                     triangulation (using Steve Fortune's sweep2 code).
            M_LINKERN
                    -find # lin ker matchings
END_DESCRIPTION

BEGINFILE: EDGEGEN/delaunay.c

FILENAME: EDGEGEN/delaunay.c
FUNCTION: CCedgegen_delaunay
HEADER: delaunay.h
PROTOTYPE:
    int CCedgegen_delaunay (int ncount, CCdatagroup *dat, int wantlist,
        int *ecount, int **elist)
DESCRIPTION:
    RETURNS the edgeset of the (Euclidean-norm) Delaunay triangulation
    of the point set for norms of size CC_D2_NORM_SIZE (2-coordinates).
      -ncount is the number of nodes)
      -dat contains the info to generate edge lengths
      -wantlist is 1 if you want the function to return the edges.
      -ecount returns the number of edges if wantlist is 1
      -elist returns the edges in end1 end2 format if wantlist is 1
    NOTES:
      To get the triangles (rather than the edges), modify the
      function out_triple as in the comments.

      The code is NOT threadsafe and does not clean up its memory.
END_DESCRIPTION

BEGINFILE: CUT/shrink.c

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_init_graph
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_init_graph (CC_SRKgraph *G)
DESCRIPTION:
    INITIALIZES the fields of the CC_SRKgraph.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_buildgraph
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_buildgraph (CC_SRKgraph *G, int ncount, int ecount,
        int *elist, double *dlen)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_free_graph
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_free_graph (CC_SRKgraph *G)
DESCRIPTION:
    FREES the CC_SRKgraph.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_init_expinfo
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_init_expinfo (CC_SRKexpinfo *expand)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_free_expinfo
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_free_expinfo (CC_SRKexpinfo *expand)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_init_callback
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_init_callback (CC_SRKcallback *cb)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_grab_edges
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_grab_edges (CC_SRKgraph *G, int *oncount, int *oecount,
        int **olist, double **olen, CC_SRKexpinfo *expand)
DESCRIPTION:
          int **omembers)
    RETURNS the edges and member lists for the shrunk graph.
     -G is a pointer to a shrunk graph
     -oncount returns the number of nodes in the shrunk graph
     -oecount returns the number of edges in the shrunk graph
     -olist returns the edges in node node format
     -olen returns the edge lengths
     -expand will be filled in with a memindex and members array;
      memindex returns pointers into the members array, the
      members of node i will be stored in from memindex[i] to
      memindex[i+1] - 1, so memindex is ncount + 1 long; members
      returns the nodes lists corresponding to each node in the
      shrunk graph. (expand can be NULL)
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_grab_nodes
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_grab_nodes (CC_SRKgraph *G, CC_SRKexpinfo *expand)
DESCRIPTION:
    RETURNS the member lists for the shrunk graph (see above)
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_trivial
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_trivial (int ncount, CC_SRKexpinfo *expand)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_expand
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_expand (CC_SRKexpinfo *expand, int *arr, int size,
        int *pnewarr, int *pnewsize)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_paths
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_paths (CC_SRKgraph *G, int *newcount,
        int onecnt_okay)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_paths_to_edges
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_paths_to_edges (CC_SRKgraph *G, int *newcount,
        int onecnt_okay)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_ones
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_ones (CC_SRKgraph *G, int *count,
        double epsilon)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_one_triangles
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_one_triangles (CC_SRKgraph *G, int *count,
        CC_SRKnode *qstart, double epsilon, double cutoff, int unmarked)
DESCRIPTION:
    SHRINKS any one edge that sits in a tight triangle.
     -G is the current shrunk graph
     -count returns the number of shrunk triangles (can be NULL)
     -qstart can point to the start of a queue (linked by qnext)
     -epsilon is used to determine one edges (at least 1.0 - epsilon)
     -cutoff is used to determine tight triangles (weight cutoff)
     -unmarked should be nonzero if only unmarked nodes (determined
      by G->marker) should be involved in shrinks
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_tight_triangles
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_tight_triangles (CC_SRKgraph *G, int *count,
        double cutoff, int unmarked)
DESCRIPTION:
    SHRINKS any tight triangle into a single node.
     -G is the current shrunk graph
     -count returns the number of shrunk triangles (can be NULL)
     -cutoff is used to decide if a triangle is tight (shrunk any T
      with x(T) >= cutoff)
     -unmarked should be nonzero if only unmarked nodes (determined
      by G->marker) should be involved in shrinks
    NOTES: All new shrunk nodes will be marked.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_tight_squares
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_tight_squares (CC_SRKgraph *G, int *count,
        double cutoff, int unmarked)
DESCRIPTION:
    SHRINKS tight squares into a single nodes.
      -see above.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_triangle_square
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_triangle_square (CC_SRKgraph *G, int *count,
        double epsilon, int unmarked)
DESCRIPTION:
    SHRINKS tight triangles within tight squares.
      -epsilon is used to determine the tight triangle and square.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_one_square
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_one_square (CC_SRKgraph *G, int *count,
        double epsilon, double cutoff, int unmarked)
DESCRIPTION:
    SHRINKS two opposite 1-edge in a tight 4-square
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_nodes
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_identify_nodes (CC_SRKgraph *G, CC_SRKnode *n,
        CC_SRKnode *m)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_increment_marker
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_increment_marker (CC_SRKgraph *G)
DESCRIPTION:
    INCREASES the field used to mark nodes by 1.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_subtour_shrink
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_subtour_shrink (CC_SRKgraph *G, double *minval,
        double epsilon, CC_SRKcallback *cb, int **cut, int *cutcount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_identify_pr_edges
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_identify_pr_edges (CC_SRKgraph *G, double *minval,
        int *count, CC_SRKnode *qstart, double epsilon,
        CC_SRKcallback *cb, int **cut, int *cutcount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_defluff
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_defluff (CC_SRKGRAPH *G)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_set_mark
HEADER: cut.h
PROTOTYPE:
    void CCcut_SRK_set_mark (CC_SRKgraph *G, int marker)
DESCRIPTION:
    SETS the mark field of all active nodes to marker.
END_DESCRIPTION

FILENAME: CUT/shrink.c
FUNCTION: CCcut_SRK_original_ncount
HEADER: cut.h
PROTOTYPE:
    int CCcut_SRK_original_ncount (CC_SRKexpinfo *expand)
DESCRIPTION:
      RETURNS the number of nodes in the original (unshrunk) graph.

    NOTES: Cyles of 1's will be shrunk into single nodes.
END_DESCRIPTION

BEGINFILE: CUT/segments.c

FILENAME: CUT/segments.c
FUNCTION: CCcut_linsub
HEADER: cut.h
PROTOTYPE:
    int CCcut_linsub (int ncount, int ecount, int *endmark, int *elist,
        double *x, double maxval, void *u_data,
        int (*cut_callback) (double cut_val, int cut_start, int cut_end,
        void *u_data))
DESCRIPTION:
    -ncount is the number of nodes
    -ecount is the number of edges
    -endmark indicates which segments are of interest, by indicating
     whether a node can be a right or left end of a segment
    -elist contains the LP edges in node node format
    -x is an LP solution
    -maxval is the maximum cut value desired
    -u_data is user data to be passed to cut_callback
    -cut_callback is a function to be called for segments which
     define a cut of value < cutlim.  The cut is cut_start,
     cut_start+1, ..., cut_end, and has value cut_val.  cut_callback
     will be called for the minimum segment cut starting at each
     endpoint marked as a right end, provided that cut has value <
     cutlim.
END_DESCRIPTION

FILENAME: CUT/segments.c
FUNCTION: CCcut_linsub_allcuts
HEADER: cut.h
PROTOTYPE:
    int CCcut_linsub_allcuts (int ncount, int ecount, int *perm,
        int *endmark, int *elist, double *x, double maxval,
        void *u_data, int (*cut_callback) (double cut_val,
        int cut_start, int cut_end, void *u_data))
DESCRIPTION:
        -ncount is the number of nodes
        -ecount is the number of edges
        -perm is a permutation of the nodes (if perm == (int *) NULL,
         the identity permutation will be used)
        -elist contains the LP edges in node node format
        -endmark indicates which segments are of interest, by indicating
         whether a node can be a right or left end of a segment
        -x is an LP solution
        -maxval is the maximum cut value desired
        -u_data is data to be passed to the callback
        -cut_callback is a function to be called for every segment which
         defines a cut of value <= cutlim.  The cut is perm[cut_start],
         perm[cut_start+1], ..., perm[cut_end], and has value cut_val.
         if cut_callback returns a nonzero value, CCcut_linsub_allcuts
         will terminate.

    NOTES:
        CCcut_linsub runs in time O(m log n).
        CCcut_linsub_allcuts runs in time O(m log n + |C| log n) where
        |C| is the number of cuts found.
END_DESCRIPTION

BEGINFILE: CUT/mincut.c

FILENAME: CUT/mincut.c
FUNCTION: CCcut_mincut
HEADER: cut.h
PROTOTYPE:
    int CCcut_mincut (int ncount, int ecount, int *elist, double *dlen,
        double *cutval, int **cut, int *cutcount)
DESCRIPTION:
     COMPUTES the global minimum cut in an undirected graph.
      -ncount is the number of nodes in the graph.
      -ecount is the number of edges in the graph.
      -elist is the list of edges in end0 end1 format
      -dlen is a list of the edge capacities
      -cutval returns the capacity of the mincut (it can be NULL).
      -cut will return the indices of the nodes in the minimum cut;
       this variable can be passed in as NULL, otherwise it will be
       an allocated to an array of the appropriate length.
      -cutcount will return the number of nodes in the minimum cut if
       cut is not NULL (if cut is NULL, then cutcount can be NULL).
    NOTES: This function assumes graph is connected. Paths of 1's are
     are shrunk - this is valid for the tsp, but not in general.
END_DESCRIPTION

FILENAME: CUT/mincut.c
FUNCTION: CCcut_violated_cuts
HEADER: cut.h
PROTOTYPE:
    int CCcut_violated_cuts (int ncount, int ecount, int *elist,
        double *dlen, double cutoff, int (*doit_fn) (double, int,
        int *, void *), void *pass_param)
DESCRIPTION:
    COMPUTES the global minimum cut, but calls the doit_fn function
    for any cut the algorithm encounters that has capacity at most
    cutoff. 
     -doit_fn (if not NULL) will be called for each cut having capacity
       less than or equal to the cutoff value; the arguments will be the
       value of the cut, the number of nodes in the cut, the array of
       the members of the cut, and pass_param.
     -pass_param will be passed to doit_fn; it can be NULL or it can be
       used to pass information to the doit_fn function.
    NOTES: This function assumes graph is connected.

    NOTES:

    This code works with undirected graphs. The shrinking routines
    assume that we are working with the TSP and not interested in cuts
    of weight 2.0 or more.
END_DESCRIPTION

BEGINFILE: CUT/gomoryhu.c

FILENAME: CUT/gomoryhu.c
FUNCTION: CCcut_gomory_hu
HEADER: cut.h
PROTOTYPE:
    int CCcut_gomory_hu (CC_GHtree *T, int ncount, int ecount,
        int *elist, double *ecap, int markcount, int *marks,
        CCrandstate *rstate)
DESCRIPTION:
    COMPUTES the Gomory-Hu tree of the marked nodes in G.
     -T returns the tree (a description is given in the code below)
     -ncount, ecount, elist specify the input graph
     -ecap lists the capacities of the edges
     -markcount is the length of the array marks (if markcount is 0,
      then every node is a terminal)
     -marks lists the special nodes (the terminals)
END_DESCRIPTION

FILENAME: CUT/gomoryhu.c
FUNCTION: CCcut_GHtreefree
HEADER: cut.h
PROTOTYPE:
    void CCcut_GHtreefree (CC_GHtree *T)
DESCRIPTION:
    FREES the tree pointed by T.
END_DESCRIPTION

FILENAME: CUT/gomoryhu.c
FUNCTION: CCcut_GHtreeinit
HEADER: cut.h
PROTOTYPE:
    void CCcut_GHtreeinit (CC_GHtree *T)
DESCRIPTION:
    INITIALIZES the fields of T to NULL.
END_DESCRIPTION

FILENAME: CUT/gomoryhu.c
FUNCTION: CCcut_GHtreeprint
HEADER: cut.h
PROTOTYPE:
    void CCcut_GHtreeprint (CC_GHtree *T)
DESCRIPTION:
       PRINTS the Gomory-Hu tree to stdout.

    NOTES:

      This code has only been tested on the instances that arise in
      exact blossom seperation.
END_DESCRIPTION

BEGINFILE: CUT/cut_st.c

FILENAME: CUT/cut_st.c
FUNCTION: CCcut_mincut_st
HEADER: cut.h
PROTOTYPE:
    int CCcut_mincut_st (int ncount, int ecount, int *elist, double *ecap,
        int s, int t, double *value, int **cut, int *cutcount)
DESCRIPTION:
    COMPUTES the min st-cut in a directed or undirected graph.
      -ncount is the number of nodes in the graph.
      -ecount is the number of directed (undirected) edges.
      -elist gives the edges in node node format (interpreted as
           tail head when compiled for directed graphs).
      -ecap gives the capacities of the edges.
      -s is the name of the source node.
      -t is the name of the sink node.
      -value returns the capacity of the minimum cut.
      -cut (if not NULL) returns a list of nodes in a a minimum cut (it
       returns the side that contains t); it will be allocated to an
       array of the appropriate size.
      -cutcount returns the number of nodes in the listed cut, if cut
       is not NULL (if cut is NULL, then cutcount can be NULL).

    NOTES:
      Returns 0 if it worked and 1 otherwise (for example, when one
      of the mallocs failed). The nodes in the graph should be named
      0 through #nodes - 1.

      Define UNDIRECTED_GRAPH to compile the code for undirected
      graphs. (This appears to be the way to go for tsp instances.)

      Two node selection rules are implemented: queue and highest
      label. One of QUEUE_PRF and HIGHEST_LABEL_PRF must be defined
      (but not both).

      The code can carry out global relabelings via a backwards
      breadth-first-search from the sink. The frequency of the
      relabelings is controlled by the defined constant
      GLOBAL_RELABEL_FREQUENCY. A relabling will occur after each
      #nodes * GLOBAL_RELABEL_FREQUENCY nodes have been processed.
      A resonable choice for the constant is 1.

      Defining USE_GAP turns on the gap heuristic of Derigs and
      Meyer for determing nodes that can be labeled to ncount.
      This can be used with either the queue or highest label
      variants.

      To use this code for maxflows, allow nodes with labels up to
      2*ncount to become active, or implement an algorithm to
      decompose the preflow to create a flow.
END_DESCRIPTION

BEGINFILE: CUT/connect.c

FILENAME: CUT/connect.c
FUNCTION: CCcut_connect_components
HEADER: cut.h
PROTOTYPE:
    int CCcut_connect_components (int ncount, int ecount, int *elist,
        double *x, int *ncomp, int **compscount, int **comps)
DESCRIPTION:
    RETURNS the connected components of the graph given by the edgeset
     -ncount is the number of nodes
     -ecount is the number of edges
     -elist is the edge list in node node format
     -x is an vector of length ecount (it can be NULL); is it is not
      NULL, then the connected components will be for the graph
      consisting of the positive edges
     -ncomp will return the number of connected components
     -compscount will return the number of nodes in each of the
      components (it will be an ncomp long array)
     -comps will return the nodes in the components (it will be an
      ncount array, with the first compscount[0] elements making up
      the first component, etc.)
END_DESCRIPTION

BEGINFILE: COMBS/dngreedy.c

FILENAME: COMBS/dngreedy.c
FUNCTION: CCcombs_greedy_cut
HEADER: combs.h
PROTOTYPE:
    int CCcombs_greedy_cut (CC_GCgraph *g, int *setsize, int *set,
        int mark_fixed, int forced_moves, int bad_moves,
        int fixed_moves, int *moves_done, double *cut_val)
DESCRIPTION:
    RETURNS a set of nodes of having a small coboundary.
     -g is the graph to grow in, including marks
     -setsize is the size of the set (modified by greedy)
     -set is the set of vertices (modified by greedy). This should
      point to an array of size g->ncount (to handle any size set).
     -mark_fixed, nodes with this mark are fixed (forbidden from
      entering or leaving the set)
     -forced_moves, make at least this many moves, even if they make
      the cut worse.  If a move is forced (ie, would not have happened
      otherwise) then the result is fixed.
     -bad_moves, make at least this many moves that make the cut worse.
      The result of the bad move is fixed.
     -fixed_moves, make at least this many moves, even if they make
      the cut worse.  Fix the result of each of these moves.
     -moves_done, if non-NULL, should point to an int which will be
      set to 1 if all of the forced moves, bad moves, and fixed moves
      were made, and 0 if the cut ran out of available nodes before
      making the required moves.
     -cut_val is the set's cut value (set by greedy)
    NOTES:
     -assumes that status is 0 for every node in g, and restores
      this condition on successful exit
     -modifies the node fields qhandle, flow, setloc, setdeg, status
END_DESCRIPTION

FILENAME: COMBS/dngreedy.c
FUNCTION: CCcombs_GC_build_graph
HEADER: combs.h
PROTOTYPE:
    int CCcombs_GC_build_graph (CC_GCgraph *G, int ncount, int ecount,
        int *elist, double *x)
DESCRIPTION:
    BUILDS the graph corresponding to the edge lists, using x for the
     weights on the edges.
END_DESCRIPTION

FILENAME: COMBS/dngreedy.c
FUNCTION: CCcombs_GC_init_graph
HEADER: combs.h
PROTOTYPE:
    void CCcombs_GC_init_graph (CC_GCgraph *G)
DESCRIPTION:
    INITIALIZES the fields of the graph struct to NULL.
END_DESCRIPTION

FILENAME: COMBS/dngreedy.c
FUNCTION: CCcombs_GC_free_graph
HEADER: combs.h
PROTOTYPE:
    void CCcombs_GC_free_graph (CC_GCgraph *G)
DESCRIPTION:
    FREES the fields of the graph struct.

    NOTES: differences from Denis Naddef's greedy grower:
     1.  Denis only adds nodes to the step.  Greedy can delete nodes.
     2.  Denis selects any improving move.  Greedy selects the most
         improving move.
     3.  Denis has several methods of selecting a worsening move.
         Greedy selects the least worsening move.
     4.  Denis continues until a cut < target is found, or until
         badmoves worsening moves have been made.  The best cut seen
         during the process is returned.  Greedy continues until
         at least forced_moves moves have been made, and at least
         bad_moves worsening moves have been made, and until there are
         no more improving moves available.  Greedy returns the final
         cut.
     5.  Greedy supports fixed nodes.
END_DESCRIPTION

BEGINFILE: COMBS/block.c

FILENAME: COMBS/block.c
FUNCTION: CCcombs_find_blocks
HEADER: combs.h
PROTOTYPE:
    int CCcombs_find_blocks (int ncount, int ecount, int *elist,
        double *x, int *nblocks, int **blockcnts, int ***blocks,
        int *ncutnodes, int **cutnodes)
DESCRIPTION:
    RETURNS the 2-connected components of the graph specified by the
     edgeset
     -ncount is the number of nodes
     -ecount is the number of edges
     -elist is the edge list in node node format
     -x is an vector of length ecount (it can be NULL); if it is not
      NULL, then the blocks components will be for the graph consisting
      of the edges e with epsilon < x_e < 1 - epsilon
     -nblocks will return the number of blocks (it can be NULL)
     -blockcnts with return the size of the blocks (it can be NULL)
     -blocks will return the members of the blocks (it can be NULL)
     -ncutnodes with return the number of cutnodes (it can be NULL)
     -cutnodes will return the cutnodes (it can be NULL)
END_DESCRIPTION

BEGINFILE: LOCALCUT/lift.c

FILENAME: LOCALCUT/lift.c
FUNCTION: CCchunk_lift
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lift (CCchunk_graph *c, CCchunk_fault *fault,
        CCchunk_lift_timer *timer, CCchunk_cut_callback *callback)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/lift.c
FUNCTION: CCchunk_ineq_to_lpcut_in
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_ineq_to_lpcut_in (int ncount, int ecount, int *elist,
        int *ecoef, int rhs, CCtsp_lpcut_in *c)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/lift.c
FUNCTION: CCchunk_ineq_to_cut
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_ineq_to_cut (int ncount, int ecount, int *elist,
        int *ecoef, int rhs, int outside, CCchunk_cut_callback *callback)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/chunks.c

FILENAME: LOCALCUT/chunks.c
FUNCTION: CCchunk_finder
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_finder (int ncount, int ecount, int *elist, double *elen,
        double eps, CCchunk_flag flags, CCchunk_find_timer *timer,
        CCchunk_chunk_callback *callback, CCrandstate *rstate),
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/tsporacl.c

FILENAME: LOCALCUT/tsporacl.c
FUNCTION: CCchunk_oracle
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_oracle (CCchunk_graph *ch, CCchunk_ineq *c, int *xsol,
        int *objval, int rhsvalid, int effort_limit,
        CCchunk_oracle_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/tsporacl.c
FUNCTION: CCchunk_verify
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_verify (CCchunk_graph *ch, CCchunk_ineq *c)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/first.c

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_separate
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_separate (CCchunk_graph *chunk,
        CCchunk_separate_timer *timer, CCchunk_fault_callback *callback)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_graph_alloc
HEADER: localcut.h
PROTOTYPE:
    CCchunk_graph *CCchunk_graph_alloc (int ncount, int ecount)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_graph_free
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_graph_free (CCchunk_graph *c)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/intmat.c

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_build
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_intmat_build (CCchunk_intmat *mat_p, int ncols)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_addrow
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_intmat_addrow (CCchunk_intmat *mat_p, int *row)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_ortho
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_intmat_ortho (CCchunk_intmat *mat_p, int *ortho,
        int *pcol_p, int *taboo)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_init
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_intmat_init (CCchunk_intmat *mat_p)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_free
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_intmat_free (CCchunk_intmat *mat_p)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/intmat.c
FUNCTION: CCchunk_intmat_dellastrows
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_intmat_dellastrows (CCchunk_intmat *mat_p, int ndel)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/separate.c

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lpinit
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lpinit (CCchunklp **lp_p, const char *lp_name,
        int lp_nrows, double *xstar)
DESCRIPTION:
    Creates the *lp_p object (see 'typedef struct CCchunklp' below)
    and initializes it to have name lp_name, N empty, and the initial
    (empty) lp from above.
END_DESCRIPTION

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lpfree
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_lpfree (CCchunklp **lp_p)
DESCRIPTION:
    Destroys *lp_p, freeing all its parts.
END_DESCRIPTION

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lpaddcol
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lpaddcol (CCchunklp *lp, double *x)
DESCRIPTION:
    Adds a new entry to N, and updates the lp to reflect the new x^j.
    Note that it is possible some rows of the LP have been relaxed;
    however, x is still expected to have lp_nrows entries; those for
    the relaxed rows are skipped when adding x.
END_DESCRIPTION

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lprelaxrow
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lprelaxrow (CCchunklp *lp, int del_row)
DESCRIPTION:
    Deletes row del_row+1 from lp -- that is, changes lp so that
    coordinate del_row of x^* is ignored.  This makes easier for the
    lp to be feasible.
END_DESCRIPTION

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lpsolve
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lpsolve (CCchunklp *lp, int *lpstatus_p, double *c,
        double *alpha_p)
DESCRIPTION:
    "Solves" lp: *lp_status_p and (c,*alpha_p) will be set as
    described above, depending on the settings of SEPARATE_OPTIMIZE,
    SEPARATE_OPTIMIZE, SEPARATE_NORML1, and SEPARATE_EPSILON.
END_DESCRIPTION

FILENAME: LOCALCUT/separate.c
FUNCTION: CCchunk_lpbasis
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_lpbasis (CCchunklp *lp, int ncols, int *basis)
DESCRIPTION:
    Sets basis[i] to 1 if column i is in the currentbasis, 0
    otherwise. 
END_DESCRIPTION

BEGINFILE: BIGGUY/bigguy.c

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_swrite
HEADER: bigguy.h
PROTOTYPE:
    int CCbigguy_swrite (CC_SFILE *f, CCbigguy x)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_sread
HEADER: bigguy.h
PROTOTYPE:
    int CCbigguy_sread (CC_SFILE *f, CCbigguy *x)
DESCRIPTION:
    NONE
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_addmult
HEADER: bigguy.h
PROTOTYPE:
    void CCbigguy_addmult (CCbigguy *x, CCbigguy y, int m)
DESCRIPTION:
    If an overflow occurs, an error message is output and the routine
    aborts.  If CC_BIGGUY_BUILTIN is defined, this is implemented by a
    macro, and has no overflow checking.
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_cmp
HEADER: bigguy.h
PROTOTYPE:
    int CCbigguy_cmp (CCbigguy x, CCbigguy y)
DESCRIPTION:
    If CC_BIGGUY_BUILTIN is defined, this is implemented by a macro,
    and has no overflow checking.
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguytod
HEADER: bigguy.h
PROTOTYPE:
    double CCbigguytod (CCbigguy x)
DESCRIPTION:
    If CC_BIGGUY_BUILTIN is defined, this is implemented by a macro,
    and has no overflow checking.
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_itobigguy
HEADER: bigguy.h
PROTOTYPE:
    CCbigguy CCbigguy_itobigguy (int d)
DESCRIPTION:
    If CC_BIGGUY_BUILTIN is defined, this is implemented by a macro,
    and has no overflow checking.
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_dtobigguy
HEADER: bigguy.h
PROTOTYPE:
    CCbigguy CCbigguy_dtobigguy (double d)
DESCRIPTION:
    If an overflow occurs, an error message is output and the routine
    aborts.  If CC_BIGGUY_BUILTIN is defined, this is implemented by a
    macro, and has no overflow checking.
END_DESCRIPTION

FILENAME: BIGGUY/bigguy.c
FUNCTION: CCbigguy_ceil
HEADER: bigguy.h
PROTOTYPE:
    CCbigguy CCbigguy_ceil (CCbigguy x)
DESCRIPTION:
    If an overflow occurs, an error message is output and the routine
    aborts.  If CC_BIGGUY_BUILTIN is defined, this is implemented by a
    macro, and has no overflow checking.
END_DESCRIPTION

BEGINFILE: VERIFY/verify.c

FILENAME: VERIFY/verify.c
FUNCTION: CCverify_cut
HEADER: verify.h
PROTOTYPE:
    int CCverify_cut (CCtsp_lpcut_in *cut, int check_types, int *type)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: VERIFY/verify.c
FUNCTION: CCverify_classify
HEADER: verify.h
PROTOTYPE:
    int CCverify_classify (CCtsp_lpcut_in *cut, int check_types,
        CCverify_cutclass *class);
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: VERIFY/verify.c
FUNCTION: CCverify_initcutclass
HEADER: verify.h
PROTOTYPE:
    void CCverify_initcutclass (CCverify_cutclass *class)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: VERIFY/verify.c
FUNCTION: CCverify_freecutclass
HEADER: verify.h
PROTOTYPE:
    void CCverify_freecutclass (CCverify_cutclass *class)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: UTIL/edgemap.c

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_init
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_init (CCutil_edgehash *h, int size)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_add
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_add (CCutil_edgehash *h, int end1, int end2,
        int val)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_set
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_set (CCutil_edgehash *h, int end1, int end2,
        int val)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_del
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_del (CCutil_edgehash *h, int end1, int end2)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_find
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_find (CCutil_edgehash *h, int end1, int end2,
        int *val)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_getall
HEADER: util.h
PROTOTYPE:
    int CCutil_edgehash_getall (CCutil_edgehash *h, int *ecount,
        int **elist, int **elen);
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_delall
HEADER: util.h
PROTOTYPE:
    void CCutil_edgehash_delall (CCutil_edgehash *h)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/edgemap.c
FUNCTION: CCutil_edgehash_free
HEADER: util.h
PROTOTYPE:
    void CCutil_edgehash_free (CCutil_edgehash *h)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TSP/tighten.c

FILENAME: TSP/tighten.c
FUNCTION: CCtsp_tighten_lpcut_in
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_tighten_lpcut_in (CCtsp_lpgraph *g, CCtsp_lpcut_in *c,
        double *x, CCtsp_lpcut_in *d, CCtsp_tighten_info *stats,
        double *pimprove)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tighten.c
FUNCTION: CCtsp_tighten_lpcut
HEADER: tsp.h
PROTOTYPE:
    int CCtsp_tighten_lpcut (CCtsp_lpgraph *g, CCtsp_lpclique *cliques,
        CCtsp_lpcut *c, double *x, CCtsp_lpcut_in *d,
        CCtsp_tighten_info *stats, double *pimprove)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tighten.c
FUNCTION: CCtsp_init_tighten_info
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_init_tighten_info (CCtsp_tighten_info *stats)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TSP/tighten.c
FUNCTION: CCtsp_print_tighten_info
HEADER: tsp.h
PROTOTYPE:
    void CCtsp_print_tighten_info (CCtsp_tighten_info *stats)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TINY/tinytsp.c

FILENAME: TINY/tinytsp.c
FUNCTION: CCtiny_bnc_tsp
HEADER: tinytsp.h
PROTOTYPE:
    int CCtiny_bnc_tsp (int ncount, CCdatagroup *dat, double *upbound,
        double *optval, int nodelimit)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: TINY/tinytsp.c
FUNCTION: CCtiny_bnc_msp
HEADER: tinytsp.h
PROTOTYPE:
    int CCtiny_bnc_msp (int ncount, int ecount, int *elist, int *elen,
        int depot, int *lower, int *upper, double *upperbound,
        int objsense, double *optval, int *xsol, int checkresult,
        int searchlimit)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TINY/bnbtsp.c

FILENAME: TINY/bnbtsp.c
FUNCTION: CCtiny_bnb_tsp
HEADER: tinytsp.h
PROTOTYPE:
    int CCtiny_bnb_tsp (int nnodes, int nedges, int *elist, int *weight,
        int *lbound, int *ubound, double *objlimit, int objdir,
        double *objval, int *xsol, int searchlimit)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TINY/bnbmsp.c

FILENAME: TINY/bnbmsp.c
FUNCTION: CCtiny_bnb_msp
HEADER: tinytsp.h
PROTOTYPE:
    CCtiny_bnb_msp (int nnodes, int nedges, int *elist, int *weight,
        int depot, int *lbound, int *ubound, double *objlimit,
        int objdir, double *objval, int *xsol, int searchlimit)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: TINY/benttsp.c

FILENAME: TINY/benttsp.c
FUNCTION: CCtiny_benttsp_elist
HEADER: tinytsp.h
PROTOTYPE:
    int CCtiny_benttsp_elist (int ncount, int ecount, int *elist,
        int *elen, double *upbound, double *optval, int *foundtour,
        int anytour, int searchlimit, int silent)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: UTIL/profrus.c

FILENAME: UTIL/profrus.c
FUNCTION: CCprof_init
HEADER: profrus.h
PROTOTYPE:
    void CCprof_init (void)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/profrus.c
FUNCTION: CCprof_start
HEADER: profrus.h
PROTOTYPE:
    void CCprof_start (void)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/profrus.c
FUNCTION: CCprof_stop
HEADER: profrus.h
PROTOTYPE:
    void CCprof_stop (void)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: UTIL/profrus.c
FUNCTION: CCprof_end
HEADER: profrus.h
PROTOTYPE:
    void CCprof_end (void)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/localcut.c

FILENAME: LOCALCUT/localcut.c
FUNCTION: CCchunk_localcuts
HEADER: localcut.h
PROTOTYPE:
    int CCchunk_localcuts (CCtsp_lpcut_in **clist, int *cutcount,
        int ncount, int ecount, int *elist, double *x, double eps,
        CCchunk_flag flags, CCchunk_localcut_timer *timer, int silent,
        CCrandstate *rstate)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: LOCALCUT/first.c

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_init_separate_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_init_separate_timer (CCchunk_separate_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_init_find_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_init_find_timer (CCchunk_find_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_init_lift_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_init_lift_timer (CCchunk_lift_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_init_oracle_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_init_oracle_timer (CCchunk_oracle_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_init_localcut_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_init_localcut_timer (CCchunk_localcut_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_print_separate_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_print_separate_timer (CCchunk_separate_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_print_find_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_print_find_timer (CCchunk_find_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_print_lift_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_print_lift_timer (CCchunk_lift_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_print_oracle_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_print_oracle_timer (CCchunk_oracle_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: LOCALCUT/first.c
FUNCTION: CCchunk_print_localcut_timer
HEADER: localcut.h
PROTOTYPE:
    void CCchunk_print_localcut_timer (CCchunk_localcut_timer *timer)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: PQ/cuttree.c

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_init
HEADER: cuttree.h
PROTOTYPE:
    void CCpq_cuttree_init (CCtsp_cuttree *t)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_freetree
HEADER: cuttree.h
PROTOTYPE:
    void CCpq_cuttree_freetree (CCtsp_cuttree *t)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_check_clique
HEADER: cuttree.h
PROTOTYPE:
    void CCpq_check_clique (CCpq_tree *pqt, CCtsp_lpclique *c,
        int *status)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_display
HEADER: cuttree.h
PROTOTYPE:
    void CCpq_cuttree_display (CCtsp_cuttree *t)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_describe
HEADER: cuttree.h
PROTOTYPE:
    void CCpq_cuttree_describe (CCtsp_cuttree *t)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_trivial
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_cuttree_trivial (CCtsp_cuttree *t, int nodecount,
        int extern_node)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_update_clean
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_cuttree_update_clean (CCtsp_cuttree *t, int edgecount,
        int *elist, double *x)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_improve_quick
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_cuttree_improve_quick (CCtsp_cuttree *t, CCtsp_lpcuts *pool,
        int edgecount, int *elist, double *x)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_apply_clique
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_apply_clique (CCpq_tree *T, CCtsp_lpclique *c, int *status)
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_gen_cliques
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_cuttree_gen_cliques (CCtsp_cuttree *t, void *u_data,
        int (*cut_callback) (int *arr, int cnt, int *stop, void *u_data))
DESCRIPTION:
    MISSING
END_DESCRIPTION

FILENAME: PQ/cuttree.c
FUNCTION: CCpq_cuttree_build_necklaces
HEADER: cuttree.h
PROTOTYPE:
    int CCpq_cuttree_build_necklaces (CCtsp_cuttree *t, int ecount,
        int *elist, double *x, int *p_neckcount,
        CCtsp_cutnode ***p_necklist, int *necknum)
DESCRIPTION:
    MISSING
END_DESCRIPTION

BEGINFILE: INCLUDE/util.h

FILENAME: INCLUDE/util.h
MACRO: CC_SAFE_MALLOC
DESC: allocate memory, and output error message if out of memory.
HEADER: util.h
PROTOTYPE:
    CC_SAFE_MALLOC(nnum,type)
DESCRIPTION:
    int nnum (the number of objects to be malloced)
    data type (the sort of objects to be malloced)
    RETURNS a pointer to the allocated space. If out of memory,
            it prints an error message and returns NULL.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_FREE
DESC: free memory
HEADER: util.h
PROTOTYPE:
    CC_FREE(object,type)
DESCRIPTION:
    type *object (pointer to previously allocated space)
    data type (the sort of object)
    ACTION: frees the memory and sets the object to NULL.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_IFFREE
DESC: free memory if pointer is non-NULL
HEADER: util.h
PROTOTYPE:
    CC_IFFREE(object,type)
DESCRIPTION:
    type *object (pointer to previously allocated space)
    data type (the sort of object)
    ACTION: if *object is not NULL, frees the memory and sets
            the object to NULL.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_ALLOC_ROUTINE
DESC: create a routine to allocate a pointer object
HEADER: util.h
PROTOTYPE:
    CC_PTR_ALLOC_ROUTINE (type, functionname, chunklist, freelist)
DESCRIPTION:
    data type (the sort of objects)
    string functionname (the generated function)
    CCbigchunkptr *chunklist (used to accumulate bigchunks)
    type *freelist (used for the linked list of objects)
    ACTION: Generates a function ("functionname") that returns
            (type *) objects, keeping the free ones on freelist
            and getting its space from calls to
            CCutil_bigchunkalloc.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_FREE_ROUTINE
DESC: create a routine to free a pointer object
HEADER: util.h
PROTOTYPE:
    CC_PTR_FREE_ROUTINE (type, functionname, freelist)
DESCRIPTION:
    Parameters as above.
    ACTION: Generates a function that adds an object to the
            freelist.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_FREE_LIST_ROUTINE
DESC: create a routine to free a list of pointer objects
HEADER: util.h
PROTOTYPE:
    CC_PTR_FREE_LIST_ROUTINE (type, functionname, freefunction)
DESCRIPTION:
    Parameters defined as above, with freefunction the function
    generated by CC_PTR_FREE_ROUTINE.
    ACTION: Generates a function to free a linked list of
            objects using calls to freefunction.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_FREE_WORLD_ROUTINE
DESC: create a routine to free a pointer allocation world
HEADER: util.h
PROTOTYPE:
    CC_PTR_FREE_WORLD_ROUTINE (type, functionname, chunklist, freelist)
DESCRIPTION:
    Parameters defined as above.
    ACTION: Generates a function that returns all of the
            memory used in the CC_PTR_ALLOC_ROUTINE allocations
            back to the global supply of CCbigchunkptrs.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_LEAKS_ROUTINE
DESC: create a routine to check a pointer allocation world for leaks
HEADER: util.h
PROTOTYPE:
    CC_PTR_LEAKS_ROUTINE (type, name, chunklist, freelist, field,
        fieldtype)
DESCRIPTION:
    As above, with "field" the name of a "fieldtype" field in the
    object type that can be set to 0 or to 1.
    ACTION: Generates a function that checks to see that we have
            not leaked any of the objects.
END_DESCRIPTION

FILENAME: INCLUDE/util.h
MACRO: CC_PTR_STATUS_ROUTINE
DESC: create a routine to check the status of a pointer allocation world
HEADER: util.h
PROTOTYPE:
    CC_PTR_STATUS_ROUTINE (type, name, chunklist, freelist)
DESCRIPTION:
       ACTION: Like LEAKS, but does not check for duplicates (and so
               does not corrupt the objects).

    NOTES:
       These routines use the functions in allocrus.c.  The PTR macros
    generate the functions for allocating objects for linked lists. They
    get their raw memory from the bigchunk supply, so foo_free_world
    (generated by CC_PTR_FREE_WORLD_ROUTINE) should be called for each
    type of linked object "foo" when closing down the local memory.
       To use these functions, put the macros near the top of the file
    before any calls to the functions (since the macros also write the
    function prototypes). If you use CC_PTR_FREE_LIST_ROUTINE for foo,
    you must also use CC_PTR_FREE_ROUTINE, and
    CC_PTR_FREE_LIST_ROUTINE must be listed after CC_PTR_FREE_ROUTINE
    (to get the prototype). 
END_DESCRIPTION

BEGINFILE: INCLUDE/pqsets.h

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_INIT
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_INIT(CCpq_set s)
DESCRIPTION:
    initializes s to the empty set
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_ISEMPTY
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_ISEMPTY(CCpq_set s)
DESCRIPTION:
    is an expression which tests if s is empty
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_SIZE
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_SIZE(CCpq_set s)
DESCRIPTION:
    is the size of s
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_PTR_TO
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_PTR_TO(CCpq_elem e, CCpq_node *q)
DESCRIPTION:
    is the field of e which points to q
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_PTR_REPLACE
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_PTR_REPLACE(CCpq_elem e, CCpq_node *q, CCpq_node *r)
DESCRIPTION:
    replaces q with r in e
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_PTR_AWAY
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_PTR_AWAY(CCpq_elem e, CCpq_node *q)
DESCRIPTION:
    is the field of e which doesn't point to q
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_ADD_WORK
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_ADD_WORK(CCpq_node *x, CCpq_set s, ELEM_FIELD efield,
        DIRECTION dir)
DESCRIPTION:
    adds x to s at the dir end, using the efield field to link things
    together. It is intended to be an internal macro used by
    CCpq_set_ADD_LEFT and CCpq_set_ADD_RIGHT.
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_ADD_LEFT
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_ADD_LEFT(CCpq_node *x, CCpq_set s, ELEM_FIELD efield)
DESCRIPTION:
    adds x to s at the left end.
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_ADD_RIGHT
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_ADD_RIGHT(CCpq_node *x, CCpq_set s, ELEM_FIELD efield)
DESCRIPTION:
    adds x to s at the right end.
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_ADD
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_ADD(CCpq_node *x, CCpq_set s, ELEM_FIELD efield)
DESCRIPTION:
    adds x to s
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_DELETE
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_DELETE(CCpq_node *x, CCpq_set s, ELEM_FIELD efield)
DESCRIPTION:
    deletes x from s
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_DELETE2
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_DELETE2(CCpq_node *x, SET_FIELD sfield,
        ELEM_FIELD efield)
DESCRIPTION:
    deletes x from the sfield set of its parent.  If x is an endmost
    child in this set, then DELETE2 uses the parent pointer to find
    the set field.  Otherwise, the parent pointer is not used.
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_LEFT_ELEM
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_LEFT_ELEM(CCpq_set s)
DESCRIPTION:
    is the left element of s, or NULL if s is empty
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_RIGHT_ELEM
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_RIGHT_ELEM(CCpq_set s)
DESCRIPTION:
    is the right element of s, or NULL if s is empty
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_FOREACH
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_FOREACH(CCpq_set s, CCpq_node *x, ELEM_FIELD efield,
        CCpq_node *xprev, CCpq_node *xnext)
DESCRIPTION:
    iterates x over elements of s using temporary variables xprev and
    xnext.
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_FOREACH_FROM
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_FOREACH_FROM(CCpq_node *x, ELEM_FIELD efield,
        CCpq_node *xprev, CCpq_node *xnext)
DESCRIPTION:
    iterates x over elements of s starting at x and going away from
    xprev.  xnext is a temporary variable used in the loop, which also
    changes xprev and x
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_FOREACH_DEL
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_FOREACH_DEL(CCpq_set s, CCpq_node *x, ELEM_FIELD efield,
        CCpq_node *xprev, CCpq_node *xnext)
DESCRIPTION:
    iterates x over elements of s using temporary variables xprev and
    xnext.  x may be deleted from the set in the body of the loop (but
    delete any other element from s at your own risk).
END_DESCRIPTION

FILENAME: INCLUDE/pqsets.h
MACRO: CCpq_set_FOREACH_ADJ
HEADER: pqsets.h
PROTOTYPE:
    CCpq_set_FOREACH_ADJ(CCpq_node *x, ELEM_FIELD efield, CCpq_node *z,
        int itemp)
DESCRIPTION:
    iterates z over the immediate neighbors of x using itemp as a
    temporary variable. It is just used to save code replication when
    you want to do something for each of the two neighbors.
END_DESCRIPTION

BEGINFILE: INCLUDE/macrorus.h

FILENAME: INCLUDE/macrorus.h
MACRO: CC_SWAP
DESC: swap two variables
HEADER: macrorus.h
PROTOTYPE:
    CC_SWAP(a,b,t)
DESCRIPTION:
    swaps a and b, using t as temporary space.  a, b, and t should all
    be the same type.
END_DESCRIPTION

FILENAME: INCLUDE/macrorus.h
MACRO: CC_OURABS
DESC: absolute value
HEADER: macrorus.h
PROTOTYPE:
    CC_OURABS(a)
DESCRIPTION:
    returns the absolute value of a.
END_DESCRIPTION
