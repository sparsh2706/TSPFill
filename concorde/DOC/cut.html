<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Concorde cut.h functions</title>
</head>
<body>
<center><h1>Concorde cut.h functions</h1></center>
<h2><a href="concorde_org.html">Organizational index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_funcs.html">Function index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_prog.html">Program index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_macro.html">Macro index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_types.html">Data Types index</a>&nbsp;&nbsp;&nbsp;&nbsp;
</h2><a NAME="CCcut_SRK_init_graph"></a>
<h2>CCcut_SRK_init_graph</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_init_graph&nbsp;(CC_SRKgraph&nbsp;*G)</tt></dd>
<dt>Description:</dt>
<dd><tt>INITIALIZES&nbsp;the&nbsp;fields&nbsp;of&nbsp;the&nbsp;CC_SRKgraph.</tt></dd>
<a NAME="CCcut_SRK_buildgraph"></a>
<h2>CCcut_SRK_buildgraph</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_buildgraph&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*dlen)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_free_graph"></a>
<h2>CCcut_SRK_free_graph</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_free_graph&nbsp;(CC_SRKgraph&nbsp;*G)</tt></dd>
<dt>Description:</dt>
<dd><tt>FREES&nbsp;the&nbsp;CC_SRKgraph.</tt></dd>
<a NAME="CCcut_SRK_init_expinfo"></a>
<h2>CCcut_SRK_init_expinfo</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_init_expinfo&nbsp;(CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_free_expinfo"></a>
<h2>CCcut_SRK_free_expinfo</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_free_expinfo&nbsp;(CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_init_callback"></a>
<h2>CCcut_SRK_init_callback</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_init_callback&nbsp;(CC_SRKcallback&nbsp;*cb)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_grab_edges"></a>
<h2>CCcut_SRK_grab_edges</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_grab_edges&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*oncount,&nbsp;int&nbsp;*oecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**olist,&nbsp;double&nbsp;**olen,&nbsp;CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**omembers)</tt></dd>
<dd><tt>RETURNS&nbsp;the&nbsp;edges&nbsp;and&nbsp;member&nbsp;lists&nbsp;for&nbsp;the&nbsp;shrunk&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;-G&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;shrunk&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-oncount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;shrunk&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-oecount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;in&nbsp;the&nbsp;shrunk&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-olist&nbsp;returns&nbsp;the&nbsp;edges&nbsp;in&nbsp;node&nbsp;node&nbsp;format</tt></dd>
<dd><tt>&nbsp;-olen&nbsp;returns&nbsp;the&nbsp;edge&nbsp;lengths</tt></dd>
<dd><tt>&nbsp;-expand&nbsp;will&nbsp;be&nbsp;filled&nbsp;in&nbsp;with&nbsp;a&nbsp;memindex&nbsp;and&nbsp;members&nbsp;array;</tt></dd>
<dd><tt>&nbsp;&nbsp;memindex&nbsp;returns&nbsp;pointers&nbsp;into&nbsp;the&nbsp;members&nbsp;array,&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;members&nbsp;of&nbsp;node&nbsp;i&nbsp;will&nbsp;be&nbsp;stored&nbsp;in&nbsp;from&nbsp;memindex[i]&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;memindex[i+1]&nbsp;-&nbsp;1,&nbsp;so&nbsp;memindex&nbsp;is&nbsp;ncount&nbsp;+&nbsp;1&nbsp;long;&nbsp;members</tt></dd>
<dd><tt>&nbsp;&nbsp;returns&nbsp;the&nbsp;nodes&nbsp;lists&nbsp;corresponding&nbsp;to&nbsp;each&nbsp;node&nbsp;in&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;shrunk&nbsp;graph.&nbsp;(expand&nbsp;can&nbsp;be&nbsp;NULL)</tt></dd>
<a NAME="CCcut_SRK_grab_nodes"></a>
<h2>CCcut_SRK_grab_nodes</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_grab_nodes&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;member&nbsp;lists&nbsp;for&nbsp;the&nbsp;shrunk&nbsp;graph&nbsp;(see&nbsp;above)</tt></dd>
<a NAME="CCcut_SRK_trivial"></a>
<h2>CCcut_SRK_trivial</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_trivial&nbsp;(int&nbsp;ncount,&nbsp;CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_expand"></a>
<h2>CCcut_SRK_expand</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_expand&nbsp;(CC_SRKexpinfo&nbsp;*expand,&nbsp;int&nbsp;*arr,&nbsp;int&nbsp;size,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*pnewarr,&nbsp;int&nbsp;*pnewsize)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_identify_paths"></a>
<h2>CCcut_SRK_identify_paths</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_paths&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*newcount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;onecnt_okay)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_identify_paths_to_edges"></a>
<h2>CCcut_SRK_identify_paths_to_edges</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_paths_to_edges&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*newcount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;onecnt_okay)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_identify_ones"></a>
<h2>CCcut_SRK_identify_ones</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_ones&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;epsilon)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_identify_one_triangles"></a>
<h2>CCcut_SRK_identify_one_triangles</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_one_triangles&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CC_SRKnode&nbsp;*qstart,&nbsp;double&nbsp;epsilon,&nbsp;double&nbsp;cutoff,&nbsp;int&nbsp;unmarked)</tt></dd>
<dt>Description:</dt>
<dd><tt>SHRINKS&nbsp;any&nbsp;one&nbsp;edge&nbsp;that&nbsp;sits&nbsp;in&nbsp;a&nbsp;tight&nbsp;triangle.</tt></dd>
<dd><tt>&nbsp;-G&nbsp;is&nbsp;the&nbsp;current&nbsp;shrunk&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-count&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;shrunk&nbsp;triangles&nbsp;(can&nbsp;be&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;-qstart&nbsp;can&nbsp;point&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;a&nbsp;queue&nbsp;(linked&nbsp;by&nbsp;qnext)</tt></dd>
<dd><tt>&nbsp;-epsilon&nbsp;is&nbsp;used&nbsp;to&nbsp;determine&nbsp;one&nbsp;edges&nbsp;(at&nbsp;least&nbsp;1.0&nbsp;-&nbsp;epsilon)</tt></dd>
<dd><tt>&nbsp;-cutoff&nbsp;is&nbsp;used&nbsp;to&nbsp;determine&nbsp;tight&nbsp;triangles&nbsp;(weight&nbsp;cutoff)</tt></dd>
<dd><tt>&nbsp;-unmarked&nbsp;should&nbsp;be&nbsp;nonzero&nbsp;if&nbsp;only&nbsp;unmarked&nbsp;nodes&nbsp;(determined</tt></dd>
<dd><tt>&nbsp;&nbsp;by&nbsp;G->marker)&nbsp;should&nbsp;be&nbsp;involved&nbsp;in&nbsp;shrinks</tt></dd>
<a NAME="CCcut_SRK_identify_tight_triangles"></a>
<h2>CCcut_SRK_identify_tight_triangles</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_tight_triangles&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;cutoff,&nbsp;int&nbsp;unmarked)</tt></dd>
<dt>Description:</dt>
<dd><tt>SHRINKS&nbsp;any&nbsp;tight&nbsp;triangle&nbsp;into&nbsp;a&nbsp;single&nbsp;node.</tt></dd>
<dd><tt>&nbsp;-G&nbsp;is&nbsp;the&nbsp;current&nbsp;shrunk&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-count&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;shrunk&nbsp;triangles&nbsp;(can&nbsp;be&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;-cutoff&nbsp;is&nbsp;used&nbsp;to&nbsp;decide&nbsp;if&nbsp;a&nbsp;triangle&nbsp;is&nbsp;tight&nbsp;(shrunk&nbsp;any&nbsp;T</tt></dd>
<dd><tt>&nbsp;&nbsp;with&nbsp;x(T)&nbsp;>=&nbsp;cutoff)</tt></dd>
<dd><tt>&nbsp;-unmarked&nbsp;should&nbsp;be&nbsp;nonzero&nbsp;if&nbsp;only&nbsp;unmarked&nbsp;nodes&nbsp;(determined</tt></dd>
<dd><tt>&nbsp;&nbsp;by&nbsp;G->marker)&nbsp;should&nbsp;be&nbsp;involved&nbsp;in&nbsp;shrinks</tt></dd>
<dd><tt>NOTES:&nbsp;All&nbsp;new&nbsp;shrunk&nbsp;nodes&nbsp;will&nbsp;be&nbsp;marked.</tt></dd>
<a NAME="CCcut_SRK_identify_tight_squares"></a>
<h2>CCcut_SRK_identify_tight_squares</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_tight_squares&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;cutoff,&nbsp;int&nbsp;unmarked)</tt></dd>
<dt>Description:</dt>
<dd><tt>SHRINKS&nbsp;tight&nbsp;squares&nbsp;into&nbsp;a&nbsp;single&nbsp;nodes.</tt></dd>
<dd><tt>&nbsp;&nbsp;-see&nbsp;above.</tt></dd>
<a NAME="CCcut_SRK_identify_triangle_square"></a>
<h2>CCcut_SRK_identify_triangle_square</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_triangle_square&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;epsilon,&nbsp;int&nbsp;unmarked)</tt></dd>
<dt>Description:</dt>
<dd><tt>SHRINKS&nbsp;tight&nbsp;triangles&nbsp;within&nbsp;tight&nbsp;squares.</tt></dd>
<dd><tt>&nbsp;&nbsp;-epsilon&nbsp;is&nbsp;used&nbsp;to&nbsp;determine&nbsp;the&nbsp;tight&nbsp;triangle&nbsp;and&nbsp;square.</tt></dd>
<a NAME="CCcut_SRK_identify_one_square"></a>
<h2>CCcut_SRK_identify_one_square</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_one_square&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;*count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;epsilon,&nbsp;double&nbsp;cutoff,&nbsp;int&nbsp;unmarked)</tt></dd>
<dt>Description:</dt>
<dd><tt>SHRINKS&nbsp;two&nbsp;opposite&nbsp;1-edge&nbsp;in&nbsp;a&nbsp;tight&nbsp;4-square</tt></dd>
<a NAME="CCcut_SRK_identify_nodes"></a>
<h2>CCcut_SRK_identify_nodes</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_identify_nodes&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;CC_SRKnode&nbsp;*n,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CC_SRKnode&nbsp;*m)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_increment_marker"></a>
<h2>CCcut_SRK_increment_marker</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_increment_marker&nbsp;(CC_SRKgraph&nbsp;*G)</tt></dd>
<dt>Description:</dt>
<dd><tt>INCREASES&nbsp;the&nbsp;field&nbsp;used&nbsp;to&nbsp;mark&nbsp;nodes&nbsp;by&nbsp;1.</tt></dd>
<a NAME="CCcut_SRK_subtour_shrink"></a>
<h2>CCcut_SRK_subtour_shrink</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_subtour_shrink&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;double&nbsp;*minval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;epsilon,&nbsp;CC_SRKcallback&nbsp;*cb,&nbsp;int&nbsp;**cut,&nbsp;int&nbsp;*cutcount)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_identify_pr_edges"></a>
<h2>CCcut_SRK_identify_pr_edges</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_identify_pr_edges&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;double&nbsp;*minval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*count,&nbsp;CC_SRKnode&nbsp;*qstart,&nbsp;double&nbsp;epsilon,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CC_SRKcallback&nbsp;*cb,&nbsp;int&nbsp;**cut,&nbsp;int&nbsp;*cutcount)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_defluff"></a>
<h2>CCcut_SRK_defluff</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_defluff&nbsp;(CC_SRKGRAPH&nbsp;*G)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCcut_SRK_set_mark"></a>
<h2>CCcut_SRK_set_mark</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_SRK_set_mark&nbsp;(CC_SRKgraph&nbsp;*G,&nbsp;int&nbsp;marker)</tt></dd>
<dt>Description:</dt>
<dd><tt>SETS&nbsp;the&nbsp;mark&nbsp;field&nbsp;of&nbsp;all&nbsp;active&nbsp;nodes&nbsp;to&nbsp;marker.</tt></dd>
<a NAME="CCcut_SRK_original_ncount"></a>
<h2>CCcut_SRK_original_ncount</h2>
<dt>File:</dt>
<dd><tt>CUT/shrink.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_SRK_original_ncount&nbsp;(CC_SRKexpinfo&nbsp;*expand)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;RETURNS&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;original&nbsp;(unshrunk)&nbsp;graph.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:&nbsp;Cyles&nbsp;of&nbsp;1's&nbsp;will&nbsp;be&nbsp;shrunk&nbsp;into&nbsp;single&nbsp;nodes.</tt></dd>
<a NAME="CCcut_linsub"></a>
<h2>CCcut_linsub</h2>
<dt>File:</dt>
<dd><tt>CUT/segments.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_linsub&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*endmark,&nbsp;int&nbsp;*elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*x,&nbsp;double&nbsp;maxval,&nbsp;void&nbsp;*u_data,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*cut_callback)&nbsp;(double&nbsp;cut_val,&nbsp;int&nbsp;cut_start,&nbsp;int&nbsp;cut_end,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*u_data))</tt></dd>
<dt>Description:</dt>
<dd><tt>-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges</tt></dd>
<dd><tt>-endmark&nbsp;indicates&nbsp;which&nbsp;segments&nbsp;are&nbsp;of&nbsp;interest,&nbsp;by&nbsp;indicating</tt></dd>
<dd><tt>&nbsp;whether&nbsp;a&nbsp;node&nbsp;can&nbsp;be&nbsp;a&nbsp;right&nbsp;or&nbsp;left&nbsp;end&nbsp;of&nbsp;a&nbsp;segment</tt></dd>
<dd><tt>-elist&nbsp;contains&nbsp;the&nbsp;LP&nbsp;edges&nbsp;in&nbsp;node&nbsp;node&nbsp;format</tt></dd>
<dd><tt>-x&nbsp;is&nbsp;an&nbsp;LP&nbsp;solution</tt></dd>
<dd><tt>-maxval&nbsp;is&nbsp;the&nbsp;maximum&nbsp;cut&nbsp;value&nbsp;desired</tt></dd>
<dd><tt>-u_data&nbsp;is&nbsp;user&nbsp;data&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;cut_callback</tt></dd>
<dd><tt>-cut_callback&nbsp;is&nbsp;a&nbsp;function&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;segments&nbsp;which</tt></dd>
<dd><tt>&nbsp;define&nbsp;a&nbsp;cut&nbsp;of&nbsp;value&nbsp;<&nbsp;cutlim.&nbsp;&nbsp;The&nbsp;cut&nbsp;is&nbsp;cut_start,</tt></dd>
<dd><tt>&nbsp;cut_start+1,&nbsp;...,&nbsp;cut_end,&nbsp;and&nbsp;has&nbsp;value&nbsp;cut_val.&nbsp;&nbsp;cut_callback</tt></dd>
<dd><tt>&nbsp;will&nbsp;be&nbsp;called&nbsp;for&nbsp;the&nbsp;minimum&nbsp;segment&nbsp;cut&nbsp;starting&nbsp;at&nbsp;each</tt></dd>
<dd><tt>&nbsp;endpoint&nbsp;marked&nbsp;as&nbsp;a&nbsp;right&nbsp;end,&nbsp;provided&nbsp;that&nbsp;cut&nbsp;has&nbsp;value&nbsp;<</tt></dd>
<dd><tt>&nbsp;cutlim.</tt></dd>
<a NAME="CCcut_linsub_allcuts"></a>
<h2>CCcut_linsub_allcuts</h2>
<dt>File:</dt>
<dd><tt>CUT/segments.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_linsub_allcuts&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*perm,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*endmark,&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*x,&nbsp;double&nbsp;maxval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*u_data,&nbsp;int&nbsp;(*cut_callback)&nbsp;(double&nbsp;cut_val,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cut_start,&nbsp;int&nbsp;cut_end,&nbsp;void&nbsp;*u_data))</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-perm&nbsp;is&nbsp;a&nbsp;permutation&nbsp;of&nbsp;the&nbsp;nodes&nbsp;(if&nbsp;perm&nbsp;==&nbsp;(int&nbsp;*)&nbsp;NULL,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;identity&nbsp;permutation&nbsp;will&nbsp;be&nbsp;used)</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-elist&nbsp;contains&nbsp;the&nbsp;LP&nbsp;edges&nbsp;in&nbsp;node&nbsp;node&nbsp;format</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-endmark&nbsp;indicates&nbsp;which&nbsp;segments&nbsp;are&nbsp;of&nbsp;interest,&nbsp;by&nbsp;indicating</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whether&nbsp;a&nbsp;node&nbsp;can&nbsp;be&nbsp;a&nbsp;right&nbsp;or&nbsp;left&nbsp;end&nbsp;of&nbsp;a&nbsp;segment</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-x&nbsp;is&nbsp;an&nbsp;LP&nbsp;solution</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-maxval&nbsp;is&nbsp;the&nbsp;maximum&nbsp;cut&nbsp;value&nbsp;desired</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-u_data&nbsp;is&nbsp;data&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;callback</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-cut_callback&nbsp;is&nbsp;a&nbsp;function&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;every&nbsp;segment&nbsp;which</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defines&nbsp;a&nbsp;cut&nbsp;of&nbsp;value&nbsp;<=&nbsp;cutlim.&nbsp;&nbsp;The&nbsp;cut&nbsp;is&nbsp;perm[cut_start],</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perm[cut_start+1],&nbsp;...,&nbsp;perm[cut_end],&nbsp;and&nbsp;has&nbsp;value&nbsp;cut_val.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cut_callback&nbsp;returns&nbsp;a&nbsp;nonzero&nbsp;value,&nbsp;CCcut_linsub_allcuts</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;terminate.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCcut_linsub&nbsp;runs&nbsp;in&nbsp;time&nbsp;O(m&nbsp;log&nbsp;n).</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCcut_linsub_allcuts&nbsp;runs&nbsp;in&nbsp;time&nbsp;O(m&nbsp;log&nbsp;n&nbsp;+&nbsp;|C|&nbsp;log&nbsp;n)&nbsp;where</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;|C|&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;cuts&nbsp;found.</tt></dd>
<a NAME="CCcut_mincut"></a>
<h2>CCcut_mincut</h2>
<dt>File:</dt>
<dd><tt>CUT/mincut.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_mincut&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*dlen,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*cutval,&nbsp;int&nbsp;**cut,&nbsp;int&nbsp;*cutcount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;COMPUTES&nbsp;the&nbsp;global&nbsp;minimum&nbsp;cut&nbsp;in&nbsp;an&nbsp;undirected&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;in&nbsp;the&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-elist&nbsp;is&nbsp;the&nbsp;list&nbsp;of&nbsp;edges&nbsp;in&nbsp;end0&nbsp;end1&nbsp;format</tt></dd>
<dd><tt>&nbsp;&nbsp;-dlen&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;edge&nbsp;capacities</tt></dd>
<dd><tt>&nbsp;&nbsp;-cutval&nbsp;returns&nbsp;the&nbsp;capacity&nbsp;of&nbsp;the&nbsp;mincut&nbsp;(it&nbsp;can&nbsp;be&nbsp;NULL).</tt></dd>
<dd><tt>&nbsp;&nbsp;-cut&nbsp;will&nbsp;return&nbsp;the&nbsp;indices&nbsp;of&nbsp;the&nbsp;nodes&nbsp;in&nbsp;the&nbsp;minimum&nbsp;cut;</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;this&nbsp;variable&nbsp;can&nbsp;be&nbsp;passed&nbsp;in&nbsp;as&nbsp;NULL,&nbsp;otherwise&nbsp;it&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;an&nbsp;allocated&nbsp;to&nbsp;an&nbsp;array&nbsp;of&nbsp;the&nbsp;appropriate&nbsp;length.</tt></dd>
<dd><tt>&nbsp;&nbsp;-cutcount&nbsp;will&nbsp;return&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;minimum&nbsp;cut&nbsp;if</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;cut&nbsp;is&nbsp;not&nbsp;NULL&nbsp;(if&nbsp;cut&nbsp;is&nbsp;NULL,&nbsp;then&nbsp;cutcount&nbsp;can&nbsp;be&nbsp;NULL).</tt></dd>
<dd><tt>NOTES:&nbsp;This&nbsp;function&nbsp;assumes&nbsp;graph&nbsp;is&nbsp;connected.&nbsp;Paths&nbsp;of&nbsp;1's&nbsp;are</tt></dd>
<dd><tt>&nbsp;are&nbsp;shrunk&nbsp;-&nbsp;this&nbsp;is&nbsp;valid&nbsp;for&nbsp;the&nbsp;tsp,&nbsp;but&nbsp;not&nbsp;in&nbsp;general.</tt></dd>
<a NAME="CCcut_violated_cuts"></a>
<h2>CCcut_violated_cuts</h2>
<dt>File:</dt>
<dd><tt>CUT/mincut.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_violated_cuts&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*dlen,&nbsp;double&nbsp;cutoff,&nbsp;int&nbsp;(*doit_fn)&nbsp;(double,&nbsp;int,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*,&nbsp;void&nbsp;*),&nbsp;void&nbsp;*pass_param)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;the&nbsp;global&nbsp;minimum&nbsp;cut,&nbsp;but&nbsp;calls&nbsp;the&nbsp;doit_fn&nbsp;function</tt></dd>
<dd><tt>for&nbsp;any&nbsp;cut&nbsp;the&nbsp;algorithm&nbsp;encounters&nbsp;that&nbsp;has&nbsp;capacity&nbsp;at&nbsp;most</tt></dd>
<dd><tt>cutoff.&nbsp;</tt></dd>
<dd><tt>&nbsp;-doit_fn&nbsp;(if&nbsp;not&nbsp;NULL)&nbsp;will&nbsp;be&nbsp;called&nbsp;for&nbsp;each&nbsp;cut&nbsp;having&nbsp;capacity</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the&nbsp;cutoff&nbsp;value;&nbsp;the&nbsp;arguments&nbsp;will&nbsp;be&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;value&nbsp;of&nbsp;the&nbsp;cut,&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;cut,&nbsp;the&nbsp;array&nbsp;of</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;the&nbsp;members&nbsp;of&nbsp;the&nbsp;cut,&nbsp;and&nbsp;pass_param.</tt></dd>
<dd><tt>&nbsp;-pass_param&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;doit_fn;&nbsp;it&nbsp;can&nbsp;be&nbsp;NULL&nbsp;or&nbsp;it&nbsp;can&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;used&nbsp;to&nbsp;pass&nbsp;information&nbsp;to&nbsp;the&nbsp;doit_fn&nbsp;function.</tt></dd>
<dd><tt>NOTES:&nbsp;This&nbsp;function&nbsp;assumes&nbsp;graph&nbsp;is&nbsp;connected.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt></tt></dd>
<dd><tt>This&nbsp;code&nbsp;works&nbsp;with&nbsp;undirected&nbsp;graphs.&nbsp;The&nbsp;shrinking&nbsp;routines</tt></dd>
<dd><tt>assume&nbsp;that&nbsp;we&nbsp;are&nbsp;working&nbsp;with&nbsp;the&nbsp;TSP&nbsp;and&nbsp;not&nbsp;interested&nbsp;in&nbsp;cuts</tt></dd>
<dd><tt>of&nbsp;weight&nbsp;2.0&nbsp;or&nbsp;more.</tt></dd>
<a NAME="CCcut_gomory_hu"></a>
<h2>CCcut_gomory_hu</h2>
<dt>File:</dt>
<dd><tt>CUT/gomoryhu.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_gomory_hu&nbsp;(CC_GHtree&nbsp;*T,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*ecap,&nbsp;int&nbsp;markcount,&nbsp;int&nbsp;*marks,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;the&nbsp;Gomory-Hu&nbsp;tree&nbsp;of&nbsp;the&nbsp;marked&nbsp;nodes&nbsp;in&nbsp;G.</tt></dd>
<dd><tt>&nbsp;-T&nbsp;returns&nbsp;the&nbsp;tree&nbsp;(a&nbsp;description&nbsp;is&nbsp;given&nbsp;in&nbsp;the&nbsp;code&nbsp;below)</tt></dd>
<dd><tt>&nbsp;-ncount,&nbsp;ecount,&nbsp;elist&nbsp;specify&nbsp;the&nbsp;input&nbsp;graph</tt></dd>
<dd><tt>&nbsp;-ecap&nbsp;lists&nbsp;the&nbsp;capacities&nbsp;of&nbsp;the&nbsp;edges</tt></dd>
<dd><tt>&nbsp;-markcount&nbsp;is&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;array&nbsp;marks&nbsp;(if&nbsp;markcount&nbsp;is&nbsp;0,</tt></dd>
<dd><tt>&nbsp;&nbsp;then&nbsp;every&nbsp;node&nbsp;is&nbsp;a&nbsp;terminal)</tt></dd>
<dd><tt>&nbsp;-marks&nbsp;lists&nbsp;the&nbsp;special&nbsp;nodes&nbsp;(the&nbsp;terminals)</tt></dd>
<a NAME="CCcut_GHtreefree"></a>
<h2>CCcut_GHtreefree</h2>
<dt>File:</dt>
<dd><tt>CUT/gomoryhu.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_GHtreefree&nbsp;(CC_GHtree&nbsp;*T)</tt></dd>
<dt>Description:</dt>
<dd><tt>FREES&nbsp;the&nbsp;tree&nbsp;pointed&nbsp;by&nbsp;T.</tt></dd>
<a NAME="CCcut_GHtreeinit"></a>
<h2>CCcut_GHtreeinit</h2>
<dt>File:</dt>
<dd><tt>CUT/gomoryhu.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_GHtreeinit&nbsp;(CC_GHtree&nbsp;*T)</tt></dd>
<dt>Description:</dt>
<dd><tt>INITIALIZES&nbsp;the&nbsp;fields&nbsp;of&nbsp;T&nbsp;to&nbsp;NULL.</tt></dd>
<a NAME="CCcut_GHtreeprint"></a>
<h2>CCcut_GHtreeprint</h2>
<dt>File:</dt>
<dd><tt>CUT/gomoryhu.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCcut_GHtreeprint&nbsp;(CC_GHtree&nbsp;*T)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;PRINTS&nbsp;the&nbsp;Gomory-Hu&nbsp;tree&nbsp;to&nbsp;stdout.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;This&nbsp;code&nbsp;has&nbsp;only&nbsp;been&nbsp;tested&nbsp;on&nbsp;the&nbsp;instances&nbsp;that&nbsp;arise&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;exact&nbsp;blossom&nbsp;seperation.</tt></dd>
<a NAME="CCcut_mincut_st"></a>
<h2>CCcut_mincut_st</h2>
<dt>File:</dt>
<dd><tt>CUT/cut_st.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_mincut_st&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*ecap,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s,&nbsp;int&nbsp;t,&nbsp;double&nbsp;*value,&nbsp;int&nbsp;**cut,&nbsp;int&nbsp;*cutcount)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;the&nbsp;min&nbsp;st-cut&nbsp;in&nbsp;a&nbsp;directed&nbsp;or&nbsp;undirected&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;directed&nbsp;(undirected)&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;&nbsp;-elist&nbsp;gives&nbsp;the&nbsp;edges&nbsp;in&nbsp;node&nbsp;node&nbsp;format&nbsp;(interpreted&nbsp;as</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;head&nbsp;when&nbsp;compiled&nbsp;for&nbsp;directed&nbsp;graphs).</tt></dd>
<dd><tt>&nbsp;&nbsp;-ecap&nbsp;gives&nbsp;the&nbsp;capacities&nbsp;of&nbsp;the&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;&nbsp;-s&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;source&nbsp;node.</tt></dd>
<dd><tt>&nbsp;&nbsp;-t&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;sink&nbsp;node.</tt></dd>
<dd><tt>&nbsp;&nbsp;-value&nbsp;returns&nbsp;the&nbsp;capacity&nbsp;of&nbsp;the&nbsp;minimum&nbsp;cut.</tt></dd>
<dd><tt>&nbsp;&nbsp;-cut&nbsp;(if&nbsp;not&nbsp;NULL)&nbsp;returns&nbsp;a&nbsp;list&nbsp;of&nbsp;nodes&nbsp;in&nbsp;a&nbsp;a&nbsp;minimum&nbsp;cut&nbsp;(it</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;returns&nbsp;the&nbsp;side&nbsp;that&nbsp;contains&nbsp;t);&nbsp;it&nbsp;will&nbsp;be&nbsp;allocated&nbsp;to&nbsp;an</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;array&nbsp;of&nbsp;the&nbsp;appropriate&nbsp;size.</tt></dd>
<dd><tt>&nbsp;&nbsp;-cutcount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;listed&nbsp;cut,&nbsp;if&nbsp;cut</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;NULL&nbsp;(if&nbsp;cut&nbsp;is&nbsp;NULL,&nbsp;then&nbsp;cutcount&nbsp;can&nbsp;be&nbsp;NULL).</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;Returns&nbsp;0&nbsp;if&nbsp;it&nbsp;worked&nbsp;and&nbsp;1&nbsp;otherwise&nbsp;(for&nbsp;example,&nbsp;when&nbsp;one</tt></dd>
<dd><tt>&nbsp;&nbsp;of&nbsp;the&nbsp;mallocs&nbsp;failed).&nbsp;The&nbsp;nodes&nbsp;in&nbsp;the&nbsp;graph&nbsp;should&nbsp;be&nbsp;named</tt></dd>
<dd><tt>&nbsp;&nbsp;0&nbsp;through&nbsp;#nodes&nbsp;-&nbsp;1.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;Define&nbsp;UNDIRECTED_GRAPH&nbsp;to&nbsp;compile&nbsp;the&nbsp;code&nbsp;for&nbsp;undirected</tt></dd>
<dd><tt>&nbsp;&nbsp;graphs.&nbsp;(This&nbsp;appears&nbsp;to&nbsp;be&nbsp;the&nbsp;way&nbsp;to&nbsp;go&nbsp;for&nbsp;tsp&nbsp;instances.)</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;Two&nbsp;node&nbsp;selection&nbsp;rules&nbsp;are&nbsp;implemented:&nbsp;queue&nbsp;and&nbsp;highest</tt></dd>
<dd><tt>&nbsp;&nbsp;label.&nbsp;One&nbsp;of&nbsp;QUEUE_PRF&nbsp;and&nbsp;HIGHEST_LABEL_PRF&nbsp;must&nbsp;be&nbsp;defined</tt></dd>
<dd><tt>&nbsp;&nbsp;(but&nbsp;not&nbsp;both).</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;The&nbsp;code&nbsp;can&nbsp;carry&nbsp;out&nbsp;global&nbsp;relabelings&nbsp;via&nbsp;a&nbsp;backwards</tt></dd>
<dd><tt>&nbsp;&nbsp;breadth-first-search&nbsp;from&nbsp;the&nbsp;sink.&nbsp;The&nbsp;frequency&nbsp;of&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;relabelings&nbsp;is&nbsp;controlled&nbsp;by&nbsp;the&nbsp;defined&nbsp;constant</tt></dd>
<dd><tt>&nbsp;&nbsp;GLOBAL_RELABEL_FREQUENCY.&nbsp;A&nbsp;relabling&nbsp;will&nbsp;occur&nbsp;after&nbsp;each</tt></dd>
<dd><tt>&nbsp;&nbsp;#nodes&nbsp;*&nbsp;GLOBAL_RELABEL_FREQUENCY&nbsp;nodes&nbsp;have&nbsp;been&nbsp;processed.</tt></dd>
<dd><tt>&nbsp;&nbsp;A&nbsp;resonable&nbsp;choice&nbsp;for&nbsp;the&nbsp;constant&nbsp;is&nbsp;1.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;Defining&nbsp;USE_GAP&nbsp;turns&nbsp;on&nbsp;the&nbsp;gap&nbsp;heuristic&nbsp;of&nbsp;Derigs&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;Meyer&nbsp;for&nbsp;determing&nbsp;nodes&nbsp;that&nbsp;can&nbsp;be&nbsp;labeled&nbsp;to&nbsp;ncount.</tt></dd>
<dd><tt>&nbsp;&nbsp;This&nbsp;can&nbsp;be&nbsp;used&nbsp;with&nbsp;either&nbsp;the&nbsp;queue&nbsp;or&nbsp;highest&nbsp;label</tt></dd>
<dd><tt>&nbsp;&nbsp;variants.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;To&nbsp;use&nbsp;this&nbsp;code&nbsp;for&nbsp;maxflows,&nbsp;allow&nbsp;nodes&nbsp;with&nbsp;labels&nbsp;up&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;2*ncount&nbsp;to&nbsp;become&nbsp;active,&nbsp;or&nbsp;implement&nbsp;an&nbsp;algorithm&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;decompose&nbsp;the&nbsp;preflow&nbsp;to&nbsp;create&nbsp;a&nbsp;flow.</tt></dd>
<a NAME="CCcut_connect_components"></a>
<h2>CCcut_connect_components</h2>
<dt>File:</dt>
<dd><tt>CUT/connect.c</tt></dd>
<dt>Header:</dt>
<dd><tt>cut.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCcut_connect_components&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*x,&nbsp;int&nbsp;*ncomp,&nbsp;int&nbsp;**compscount,&nbsp;int&nbsp;**comps)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;connected&nbsp;components&nbsp;of&nbsp;the&nbsp;graph&nbsp;given&nbsp;by&nbsp;the&nbsp;edgeset</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;is&nbsp;the&nbsp;edge&nbsp;list&nbsp;in&nbsp;node&nbsp;node&nbsp;format</tt></dd>
<dd><tt>&nbsp;-x&nbsp;is&nbsp;an&nbsp;vector&nbsp;of&nbsp;length&nbsp;ecount&nbsp;(it&nbsp;can&nbsp;be&nbsp;NULL);&nbsp;is&nbsp;it&nbsp;is&nbsp;not</tt></dd>
<dd><tt>&nbsp;&nbsp;NULL,&nbsp;then&nbsp;the&nbsp;connected&nbsp;components&nbsp;will&nbsp;be&nbsp;for&nbsp;the&nbsp;graph</tt></dd>
<dd><tt>&nbsp;&nbsp;consisting&nbsp;of&nbsp;the&nbsp;positive&nbsp;edges</tt></dd>
<dd><tt>&nbsp;-ncomp&nbsp;will&nbsp;return&nbsp;the&nbsp;number&nbsp;of&nbsp;connected&nbsp;components</tt></dd>
<dd><tt>&nbsp;-compscount&nbsp;will&nbsp;return&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;each&nbsp;of&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;components&nbsp;(it&nbsp;will&nbsp;be&nbsp;an&nbsp;ncomp&nbsp;long&nbsp;array)</tt></dd>
<dd><tt>&nbsp;-comps&nbsp;will&nbsp;return&nbsp;the&nbsp;nodes&nbsp;in&nbsp;the&nbsp;components&nbsp;(it&nbsp;will&nbsp;be&nbsp;an</tt></dd>
<dd><tt>&nbsp;&nbsp;ncount&nbsp;array,&nbsp;with&nbsp;the&nbsp;first&nbsp;compscount[0]&nbsp;elements&nbsp;making&nbsp;up</tt></dd>
<dd><tt>&nbsp;&nbsp;the&nbsp;first&nbsp;component,&nbsp;etc.)</tt></dd>
</body>
</html>
