<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Concorde kdtree.h functions</title>
</head>
<body>
<center><h1>Concorde kdtree.h functions</h1></center>
<h2><a href="concorde_org.html">Organizational index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_funcs.html">Function index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_prog.html">Program index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_macro.html">Macro index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_types.html">Data Types index</a>&nbsp;&nbsp;&nbsp;&nbsp;
</h2><a NAME="CCkdtree_twoopt_tour"></a>
<h2>CCkdtree_twoopt_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdtwoopt.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_twoopt_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*incycle,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;run_two_and_a_half_opt,&nbsp;int&nbsp;silent,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;2-opted&nbsp;cycle&nbsp;(well,&nbsp;approximately&nbsp;2-opted)</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;can&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;&nbsp;-Does&nbsp;not&nbsp;use&nbsp;node&nbsp;weights.</tt></dd>
<dd><tt>&nbsp;&nbsp;-incycle&nbsp;is&nbsp;the&nbsp;starting&nbsp;cycle.</tt></dd>
<dd><tt>&nbsp;&nbsp;-If&nbsp;outcycle&nbsp;is&nbsp;not&nbsp;NULL,&nbsp;then&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;an&nbsp;array&nbsp;of</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;length&nbsp;at&nbsp;least&nbsp;ncount&nbsp;(allocated&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine).&nbsp;The</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;final&nbsp;tour&nbsp;will&nbsp;be&nbsp;placed&nbsp;in&nbsp;this&nbsp;array.</tt></dd>
<dd><tt>&nbsp;&nbsp;-The&nbsp;length&nbsp;of&nbsp;the&nbsp;tour&nbsp;is&nbsp;returned&nbsp;in&nbsp;val.</tt></dd>
<dd><tt>&nbsp;&nbsp;-If&nbsp;in_run_two_and_a_half_opt&nbsp;is&nbsp;nonzero,&nbsp;&nbsp;then&nbsp;some&nbsp;limited</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;3-swapping&nbsp;is&nbsp;performded.</tt></dd>
<dd><tt>&nbsp;&nbsp;-silent&nbsp;(if&nbsp;nonzero&nbsp;then&nbsp;very&nbsp;little&nbsp;info&nbsp;will&nbsp;be&nbsp;printed)</tt></dd>
<a NAME="CCkdtree_3opt_tour"></a>
<h2>CCkdtree_3opt_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdtwoopt.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_3opt_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*incycle,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,&nbsp;silent,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;an&nbsp;approximately&nbsp;3-opted&nbsp;tour.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;can&nbsp;be&nbsp;NULL.</tt></dd>
<a NAME="CCkdtree_prim_spanningtree"></a>
<h2>CCkdtree_prim_spanningtree</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdspan.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_prim_spanningtree&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;double&nbsp;*wcoord,&nbsp;int&nbsp;*outtree,&nbsp;double&nbsp;*val,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;min&nbsp;weight&nbsp;spanning&nbsp;tree.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;CCkdtree&nbsp;built&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;CCkdtree_build.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;If&nbsp;kt&nbsp;is&nbsp;NULL,&nbsp;then&nbsp;CCkdtree_build&nbsp;will&nbsp;be&nbsp;called.</tt></dd>
<dd><tt>&nbsp;&nbsp;-If&nbsp;wcoord&nbsp;is&nbsp;not&nbsp;NULL,&nbsp;then&nbsp;the&nbsp;array&nbsp;should&nbsp;have&nbsp;nonnegative</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;values.&nbsp;The&nbsp;code&nbsp;will&nbsp;use&nbsp;Held-Karp&nbsp;style&nbsp;distances.</tt></dd>
<dd><tt>&nbsp;&nbsp;-If&nbsp;outtree&nbsp;is&nbsp;non&nbsp;NULL,&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;an&nbsp;array&nbsp;of&nbsp;length</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;at&nbsp;least&nbsp;2*ncount&nbsp;-&nbsp;2.&nbsp;The&nbsp;edges&nbsp;in&nbsp;the&nbsp;min&nbsp;spanning&nbsp;tree&nbsp;will</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;be&nbsp;returned&nbsp;in&nbsp;the&nbsp;array&nbsp;in&nbsp;end&nbsp;end&nbsp;format.</tt></dd>
<dd><tt>&nbsp;&nbsp;-The&nbsp;length&nbsp;of&nbsp;the&nbsp;min&nbsp;tree&nbsp;is&nbsp;returned&nbsp;in&nbsp;val.</tt></dd>
<a NAME="CCkdtree_greedy_tour"></a>
<h2>CCkdtree_greedy_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdspan.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_greedy_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,&nbsp;int&nbsp;silent,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;greedy&nbsp;tour.&nbsp;(No&nbsp;randomization&nbsp;(expect&nbsp;in&nbsp;building&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;CCkdtree)&nbsp;so&nbsp;there&nbsp;is&nbsp;no&nbsp;point&nbsp;in&nbsp;calling&nbsp;this&nbsp;more&nbsp;than&nbsp;once)</tt></dd>
<dd><tt>&nbsp;-kt&nbsp;can&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;-Does&nbsp;not&nbsp;use&nbsp;node&nbsp;weights.</tt></dd>
<dd><tt>&nbsp;-If&nbsp;outcycle&nbsp;is&nbsp;non&nbsp;NUL,&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;an&nbsp;array&nbsp;of&nbsp;length</tt></dd>
<dd><tt>&nbsp;&nbsp;at&nbsp;least&nbsp;ncount.&nbsp;The&nbsp;cycle&nbsp;will&nbsp;be&nbsp;returned&nbsp;in&nbsp;node&nbsp;node&nbsp;node</tt></dd>
<dd><tt>&nbsp;&nbsp;format.</tt></dd>
<a NAME="CCkdtree_far_add_tour"></a>
<h2>CCkdtree_far_add_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdspan.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_far_add_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;start,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;farthest&nbsp;addition&nbsp;tour,&nbsp;beginning&nbsp;with&nbsp;node&nbsp;start.</tt></dd>
<dd><tt>&nbsp;-like&nbsp;CCkdtree_greedy_tour.</tt></dd>
<a NAME="CCkdtree_qboruvka_tour"></a>
<h2>CCkdtree_qboruvka_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdspan.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_qboruvka_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCkdtree_boruvka_tour"></a>
<h2>CCkdtree_boruvka_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdspan.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_boruvka_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCkdtree_k_nearest"></a>
<h2>CCkdtree_k_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_k_nearest&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;k,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;double&nbsp;*wcoord,&nbsp;int&nbsp;wantlist,&nbsp;int&nbsp;*ocount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**olist,&nbsp;int&nbsp;silent,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;k-nearest&nbsp;neighbor&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;can&nbsp;be&nbsp;NULL,&nbsp;otherwise&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;a&nbsp;CCkdtree&nbsp;built</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;kdbuild&nbsp;()</tt></dd>
<dd><tt>&nbsp;&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;points.</tt></dd>
<dd><tt>&nbsp;&nbsp;-k&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nearest&nbsp;neighbors&nbsp;wanted.</tt></dd>
<dd><tt>&nbsp;&nbsp;-wcoord&nbsp;is&nbsp;an&nbsp;array&nbsp;of&nbsp;node&nbsp;weights&nbsp;(like&nbsp;Held-Karp),&nbsp;it&nbsp;can</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;be&nbsp;NULL.&nbsp;The&nbsp;weights&nbsp;should&nbsp;be&nbsp;nonnegative.</tt></dd>
<dd><tt>&nbsp;&nbsp;-wantlist&nbsp;is&nbsp;1&nbsp;if&nbsp;you&nbsp;want&nbsp;the&nbsp;function&nbsp;to&nbsp;return&nbsp;the&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;&nbsp;-ocount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;(if&nbsp;wantlist&nbsp;is&nbsp;1)&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;olist&nbsp;returns&nbsp;the&nbsp;edgelist&nbsp;is&nbsp;end1&nbsp;end2&nbsp;format.</tt></dd>
<dd><tt>&nbsp;&nbsp;-silent&nbsp;will&nbsp;turn&nbsp;off&nbsp;print&nbsp;messages&nbsp;if&nbsp;set&nbsp;to&nbsp;nonzero&nbsp;value.</tt></dd>
<a NAME="CCkdtree_quadrant_k_nearest"></a>
<h2>CCkdtree_quadrant_k_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_quadrant_k_nearest&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;k,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;double&nbsp;*wcoord,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;wantlist,&nbsp;int&nbsp;*ocount,&nbsp;int&nbsp;**olist,&nbsp;int&nbsp;silent,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;quadrant&nbsp;k-nearest&nbsp;neighbor&nbsp;graph.</tt></dd>
<dd><tt>&nbsp;&nbsp;-see&nbsp;CCkdtree_k_nearest.</tt></dd>
<a NAME="CCkdtree_node_k_nearest"></a>
<h2>CCkdtree_node_k_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_node_k_nearest&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;int&nbsp;n,&nbsp;int&nbsp;k,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat,&nbsp;double&nbsp;*wcoord,&nbsp;int&nbsp;*list,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;k&nbsp;nearest&nbsp;points&nbsp;to&nbsp;point&nbsp;n.</tt></dd>
<dd><tt>&nbsp;&nbsp;-The&nbsp;k&nbsp;points&nbsp;are&nbsp;return&nbsp;in&nbsp;list&nbsp;(and&nbsp;list&nbsp;must&nbsp;be&nbsp;allocated&nbsp;by</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;calling&nbsp;routine.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;CCkdtree&nbsp;previously&nbsp;built&nbsp;by</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;CCkdtree_build.</tt></dd>
<a NAME="CCkdtree_node_quadrant_k_nearest"></a>
<h2>CCkdtree_node_quadrant_k_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_node_quadrant_k_nearest&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n,&nbsp;int&nbsp;k,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;double&nbsp;*wcoord,&nbsp;int&nbsp;*list,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;quadrant&nbsp;k&nbsp;nearest&nbsp;point&nbsp;to&nbsp;point&nbsp;n.</tt></dd>
<dd><tt>&nbsp;&nbsp;-see&nbsp;CCkdtree_node_k_nearest.</tt></dd>
<a NAME="CCkdtree_node_nearest"></a>
<h2>CCkdtree_node_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_node_nearest&nbsp;(ktree&nbsp;*kt,&nbsp;int&nbsp;n,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*wcoord)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;nearest&nbsp;point&nbsp;to&nbsp;point&nbsp;n.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;CANNOT&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;&nbsp;-The&nbsp;point&nbsp;is&nbsp;returned&nbsp;as&nbsp;the&nbsp;function&nbsp;value.&nbsp;kt&nbsp;is&nbsp;a&nbsp;pointer</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;to&nbsp;a&nbsp;CCkdtree&nbsp;(previously&nbsp;buildt&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;CCkdtree_build)</tt></dd>
<a NAME="CCkdtree_fixed_radius_nearest"></a>
<h2>CCkdtree_fixed_radius_nearest</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_fixed_radius_nearest&nbsp;(CCkdtree&nbsp;*kt,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*wcoord,&nbsp;int&nbsp;n,&nbsp;double&nbsp;rad,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*doit_fn)&nbsp;(int,&nbsp;int,&nbsp;void&nbsp;*),&nbsp;void&nbsp;*pass_param)</tt></dd>
<dt>Description:</dt>
<dd><tt>ACTION:&nbsp;Calls&nbsp;the&nbsp;function&nbsp;doit_fn&nbsp;(n,&nbsp;a,&nbsp;void&nbsp;*),&nbsp;where&nbsp;a&nbsp;ranges</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;over&nbsp;all&nbsp;points&nbsp;within&nbsp;distance&nbsp;rad&nbsp;of&nbsp;the&nbsp;point&nbsp;n.&nbsp;The</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;field&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;bundle&nbsp;a&nbsp;group&nbsp;of&nbsp;parmeters</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;into&nbsp;pass_param&nbsp;that&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;doit_fn.</tt></dd>
<dd><tt>&nbsp;&nbsp;-kt&nbsp;CANNOT&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;&nbsp;-doit_fn&nbsp;can&nbsp;also&nbsp;call&nbsp;CCkdtree_fixed_radius_nearest&nbsp;(no&nbsp;globals</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;are&nbsp;set&nbsp;by&nbsp;the&nbsp;function&nbsp;calls)</tt></dd>
<dd><tt>&nbsp;&nbsp;-pass_param&nbsp;can&nbsp;be&nbsp;NULL&nbsp;or&nbsp;used&nbsp;to&nbsp;point&nbsp;to&nbsp;a&nbsp;structure&nbsp;with</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;with&nbsp;parameters&nbsp;for&nbsp;doit_fn.</tt></dd>
<a NAME="CCkdtree_nearest_neighbor_tour"></a>
<h2>CCkdtree_nearest_neighbor_tour</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_nearest_neighbor_tour&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;start,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*outcycle,&nbsp;double&nbsp;*val,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>-kt&nbsp;can&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>-Node&nbsp;weights&nbsp;are&nbsp;not&nbsp;used.</tt></dd>
<dd><tt>-start&nbsp;is&nbsp;the&nbsp;starting&nbsp;node&nbsp;for&nbsp;the&nbsp;tour.</tt></dd>
<dd><tt>-if&nbsp;outcycle&nbsp;is&nbsp;not&nbsp;NULL,&nbsp;then&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;a&nbsp;array&nbsp;of</tt></dd>
<dd><tt>&nbsp;length&nbsp;at&nbsp;least&nbsp;ncount&nbsp;(allocated&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine).&nbsp;The</tt></dd>
<dd><tt>&nbsp;cycle&nbsp;will&nbsp;be&nbsp;returned&nbsp;in&nbsp;the&nbsp;array&nbsp;in&nbsp;node&nbsp;node&nbsp;node&nbsp;format.</tt></dd>
<dd><tt>-the&nbsp;length&nbsp;of&nbsp;the&nbsp;tour&nbsp;is&nbsp;return&nbsp;in&nbsp;val.</tt></dd>
<a NAME="CCkdtree_nearest_neighbor_2match"></a>
<h2>CCkdtree_nearest_neighbor_2match</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdnear.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_nearest_neighbor_2match&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;start,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*outmatch,&nbsp;double&nbsp;*val,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>-Like&nbsp;CCkdtree_nearest_neighbor_tour.&nbsp;If&nbsp;outmatch&nbsp;is&nbsp;not&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;then&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;an&nbsp;array&nbsp;of&nbsp;length&nbsp;at&nbsp;least&nbsp;2*ncount.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;If&nbsp;memory&nbsp;is&nbsp;tight,&nbsp;use&nbsp;CCkdtree_node_k_nearest&nbsp;to&nbsp;get&nbsp;the</tt></dd>
<dd><tt>edges&nbsp;one&nbsp;node&nbsp;at&nbsp;a&nbsp;time.&nbsp;(CCkdtree_k_nearest&nbsp;()&nbsp;builds&nbsp;a&nbsp;hash</tt></dd>
<dd><tt>table&nbsp;to&nbsp;avoid&nbsp;duplicate&nbsp;edges,&nbsp;and&nbsp;it&nbsp;will&nbsp;use&nbsp;8&nbsp;*&nbsp;nedges</tt></dd>
<dd><tt>bytes.)</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;CCkdtree_node_nearest&nbsp;returns&nbsp;the&nbsp;nearest&nbsp;point&nbsp;as&nbsp;the</tt></dd>
<dd><tt>function&nbsp;value;&nbsp;CCkdtree_fixed_radius_nearest&nbsp;returns&nbsp;1&nbsp;if</tt></dd>
<dd><tt>doit_fn&nbsp;returns&nbsp;a&nbsp;nonzero&nbsp;value,&nbsp;otherwise&nbsp;it&nbsp;returns&nbsp;0;&nbsp;all</tt></dd>
<dd><tt>other&nbsp;routines&nbsp;return&nbsp;0&nbsp;if&nbsp;successful&nbsp;and&nbsp;1&nbsp;otherwise.</tt></dd>
<a NAME="CCkdtree_build"></a>
<h2>CCkdtree_build</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCkdtree_build&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*wcoord,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>-When&nbsp;called,&nbsp;intree&nbsp;should&nbsp;point&nbsp;to&nbsp;a&nbsp;CCkdtree&nbsp;struct&nbsp;that&nbsp;the</tt></dd>
<dd><tt>&nbsp;funtion&nbsp;will&nbsp;load&nbsp;with&nbsp;the&nbsp;tree&nbsp;it&nbsp;builds.&nbsp;The&nbsp;wcoord&nbsp;array</tt></dd>
<dd><tt>&nbsp;is&nbsp;used&nbsp;for&nbsp;node&nbsp;weights&nbsp;(like&nbsp;in&nbsp;Held-Karp),&nbsp;it&nbsp;can&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;The&nbsp;node&nbsp;weights&nbsp;must&nbsp;be&nbsp;nonegative&nbsp;(for&nbsp;cutoffs).</tt></dd>
<a NAME="CCkdtree_free"></a>
<h2>CCkdtree_free</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCkdtree_free&nbsp;(CCkdtree&nbsp;*kt)</tt></dd>
<dt>Description:</dt>
<dd><tt>-Frees&nbsp;the&nbsp;space&nbsp;(including&nbsp;the&nbsp;ptrs)&nbsp;used&nbsp;by&nbsp;kt.</tt></dd>
<a NAME="CCkdtree_delete"></a>
<h2>CCkdtree_delete</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCkdtree_delete&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;k)</tt></dd>
<dt>Description:</dt>
<dd><tt>-Deletes&nbsp;the&nbsp;point&nbsp;k&nbsp;from&nbsp;the&nbsp;CCkdtree&nbsp;kt.</tt></dd>
<a NAME="CCkdtree_undelete"></a>
<h2>CCkdtree_undelete</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCkdtree_undelete&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;k)</tt></dd>
<dt>Description:</dt>
<dd><tt>-Puts&nbsp;the&nbsp;previously&nbsp;deleted&nbsp;point&nbsp;k&nbsp;back&nbsp;into&nbsp;kt.</tt></dd>
<a NAME="CCkdtree_delete_all"></a>
<h2>CCkdtree_delete_all</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCkdtree_delete_all&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount)</tt></dd>
<dt>Description:</dt>
<dd><tt>-Deletes&nbsp;all&nbsp;points&nbsp;in&nbsp;kt.</tt></dd>
<a NAME="CCkdtree_undelete_all"></a>
<h2>CCkdtree_undelete_all</h2>
<dt>File:</dt>
<dd><tt>KDTREE/kdbuild.c</tt></dd>
<dt>Header:</dt>
<dd><tt>kdtree.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCkdtree_undelete_all&nbsp;(CCkdtree&nbsp;*kt,&nbsp;int&nbsp;ncount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Puts&nbsp;all&nbsp;deleted&nbsp;points&nbsp;back&nbsp;in&nbsp;kt.&nbsp;Used&nbsp;to&nbsp;cleanup&nbsp;trees.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;On&nbsp;a&nbsp;32&nbsp;bit&nbsp;machine,&nbsp;a&nbsp;CCkdtree&nbsp;on&nbsp;n&nbsp;nodes&nbsp;needs&nbsp;about&nbsp;52n</tt></dd>
<dd><tt>&nbsp;bytes&nbsp;of&nbsp;memory.&nbsp;CCkdtree_build&nbsp;will&nbsp;return&nbsp;1&nbsp;if&nbsp;an&nbsp;error</tt></dd>
<dd><tt>&nbsp;occurs&nbsp;(most&nbsp;likely&nbsp;running&nbsp;out&nbsp;of&nbsp;memory).</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;CCutil_sprand&nbsp;()&nbsp;should&nbsp;be&nbsp;called&nbsp;before&nbsp;calling</tt></dd>
<dd><tt>&nbsp;CCkdtree_build&nbsp;().</tt></dd>
</body>
</html>
