<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Concorde util.h functions</title>
</head>
<body>
<center><h1>Concorde util.h functions</h1></center>
<h2><a href="concorde_org.html">Organizational index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_funcs.html">Function index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_prog.html">Program index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_macro.html">Macro index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="concorde_types.html">Data Types index</a>&nbsp;&nbsp;&nbsp;&nbsp;
</h2><a NAME="CCutil_linked_radixsort"></a>
<h2>CCutil_linked_radixsort</h2>
<dt>File:</dt>
<dd><tt>UTIL/sortrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>char&nbsp;*CCutil_linked_radixsort&nbsp;(char&nbsp;*data,&nbsp;char&nbsp;*datanext,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*dataval,&nbsp;int&nbsp;valsize)</tt></dd>
<dt>Description:</dt>
<dd><tt>USAGE:</tt></dd>
<dd><tt>&nbsp;&nbsp;head&nbsp;=&nbsp;(bar&nbsp;*)&nbsp;CCutil_linked_radixsort&nbsp;((char&nbsp;*)&nbsp;head,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(char&nbsp;*)&nbsp;&(head->next),&nbsp;(char&nbsp;*)&nbsp;&(head->val),&nbsp;sizeof&nbsp;(int));</tt></dd>
<dd><tt>Then&nbsp;head&nbsp;is&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;linked&nbsp;list&nbsp;in&nbsp;increasing&nbsp;order&nbsp;of</tt></dd>
<dd><tt>val,&nbsp;with&nbsp;next&nbsp;as&nbsp;the&nbsp;field&nbsp;that&nbsp;links&nbsp;the&nbsp;bars.</tt></dd>
<dd><tt>WARNING:&nbsp;DOES&nbsp;NOT&nbsp;HANDLE&nbsp;NEGATIVE&nbsp;NUMBERS&nbsp;PROPERLY.</tt></dd>
<a NAME="CCutil_int_array_quicksort"></a>
<h2>CCutil_int_array_quicksort</h2>
<dt>File:</dt>
<dd><tt>UTIL/sortrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_int_array_quicksort&nbsp;(int&nbsp;*len,&nbsp;int&nbsp;n)</tt></dd>
<dt>Description:</dt>
<dd><tt>len&nbsp;-&nbsp;the&nbsp;array&nbsp;to&nbsp;be&nbsp;sorted</tt></dd>
<dd><tt>n&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;len</tt></dd>
<dd><tt>Uses&nbsp;quicksort&nbsp;to&nbsp;put&nbsp;len&nbsp;in&nbsp;increasing&nbsp;order.</tt></dd>
<a NAME="CCutil_int_perm_quicksort"></a>
<h2>CCutil_int_perm_quicksort</h2>
<dt>File:</dt>
<dd><tt>UTIL/sortrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_int_perm_quicksort&nbsp;(int&nbsp;*perm,&nbsp;int&nbsp;*len,&nbsp;int&nbsp;n)</tt></dd>
<dt>Description:</dt>
<dd><tt>perm&nbsp;-&nbsp;must&nbsp;be&nbsp;allocated&nbsp;and&nbsp;initialized&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;will&nbsp;be&nbsp;arranged&nbsp;in&nbsp;increasing&nbsp;order&nbsp;of&nbsp;len.</tt></dd>
<dd><tt>n&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;perm&nbsp;and&nbsp;len.</tt></dd>
<a NAME="CCutil_double_perm_quicksort"></a>
<h2>CCutil_double_perm_quicksort</h2>
<dt>File:</dt>
<dd><tt>UTIL/sortrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_double_perm_quicksort&nbsp;(int&nbsp;*perm,&nbsp;double&nbsp;*len,&nbsp;int&nbsp;n)</tt></dd>
<dt>Description:</dt>
<dd><tt>perm&nbsp;-&nbsp;must&nbsp;be&nbsp;allocated&nbsp;and&nbsp;initialized&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;will&nbsp;be&nbsp;arranged&nbsp;in&nbsp;increasing&nbsp;order&nbsp;of&nbsp;len.</tt></dd>
<dd><tt>n&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;perm&nbsp;and&nbsp;len.</tt></dd>
<a NAME="CCutil_rselect"></a>
<h2>CCutil_rselect</h2>
<dt>File:</dt>
<dd><tt>UTIL/sortrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_rselect&nbsp;(int&nbsp;*arr,&nbsp;int&nbsp;l,&nbsp;int&nbsp;r,&nbsp;int&nbsp;m,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*coord,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>arr&nbsp;-&nbsp;permutation&nbsp;that&nbsp;will&nbsp;be&nbsp;rearranged</tt></dd>
<dd><tt>l,r&nbsp;-&nbsp;specify&nbsp;the&nbsp;range&nbsp;of&nbsp;arr&nbsp;that&nbsp;we&nbsp;are&nbsp;interested&nbsp;in</tt></dd>
<dd><tt>m&nbsp;-&nbsp;is&nbsp;the&nbsp;index&nbsp;into&nbsp;l,r&nbsp;that&nbsp;is&nbsp;the&nbsp;break&nbsp;point&nbsp;for&nbsp;the&nbsp;perm</tt></dd>
<dd><tt>coord&nbsp;-&nbsp;gives&nbsp;the&nbsp;keys&nbsp;that&nbsp;determine&nbsp;the&nbsp;ordering</tt></dd>
<a NAME="CCutil_zeit"></a>
<h2>CCutil_zeit</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>double&nbsp;CCutil_zeit&nbsp;(void)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;To&nbsp;measure&nbsp;cpu&nbsp;time.</tt></dd>
<dd><tt>To&nbsp;use&nbsp;this,&nbsp;set&nbsp;double&nbsp;t&nbsp;=&nbsp;CCutil_zeit&nbsp;(),&nbsp;run&nbsp;the&nbsp;function&nbsp;you</tt></dd>
<dd><tt>want&nbsp;to&nbsp;time,&nbsp;then&nbsp;compute&nbsp;CCutil_zeit&nbsp;()&nbsp;-&nbsp;t.</tt></dd>
<a NAME="CCutil_real_zeit"></a>
<h2>CCutil_real_zeit</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>double&nbsp;CCutil_real_zeit&nbsp;(void)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;To&nbsp;measure&nbsp;wall&nbsp;clock&nbsp;time.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>To&nbsp;use&nbsp;this,&nbsp;set&nbsp;double&nbsp;t&nbsp;=&nbsp;CCutil_real_zeit&nbsp;(),&nbsp;run&nbsp;the&nbsp;function</tt></dd>
<dd><tt>you&nbsp;want&nbsp;to&nbsp;time,&nbsp;then&nbsp;compute&nbsp;CCutil_real_zeit&nbsp;()&nbsp;-&nbsp;t.</tt></dd>
<a NAME="CCutil_init_timer"></a>
<h2>CCutil_init_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_init_timer&nbsp;(CCutil_timer&nbsp;*t,&nbsp;const&nbsp;char&nbsp;*name)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Initializes&nbsp;a&nbsp;CCutil_timer,&nbsp;and&nbsp;gives&nbsp;it&nbsp;a&nbsp;name.</tt></dd>
<dd><tt>-&nbsp;The&nbsp;name&nbsp;is&nbsp;silently&nbsp;truncated&nbsp;if&nbsp;it&nbsp;is&nbsp;too&nbsp;long.</tt></dd>
<a NAME="CCutil_start_timer"></a>
<h2>CCutil_start_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_start_timer&nbsp;(CCutil_timer&nbsp;*t)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Starts&nbsp;the&nbsp;timer.</tt></dd>
<a NAME="CCutil_suspend_timer"></a>
<h2>CCutil_suspend_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_suspend_timer&nbsp;(CCutil_timer&nbsp;*t)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Suspends&nbsp;the&nbsp;timer.&nbsp;&nbsp;Similar&nbsp;to&nbsp;CCutil_stop_timer,&nbsp;but&nbsp;doesn't</tt></dd>
<dd><tt>&nbsp;&nbsp;count&nbsp;a&nbsp;call,&nbsp;and&nbsp;doesn't&nbsp;output.</tt></dd>
<a NAME="CCutil_resume_timer"></a>
<h2>CCutil_resume_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_resume_timer&nbsp;(CCutil_timer&nbsp;*t)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Resumes&nbsp;the&nbsp;timer&nbsp;after&nbsp;a&nbsp;suspend.</tt></dd>
<a NAME="CCutil_stop_timer"></a>
<h2>CCutil_stop_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>double&nbsp;CCutil_stop_timer&nbsp;(CCutil_timer&nbsp;*t,&nbsp;int&nbsp;printit)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Stops&nbsp;the&nbsp;timer,&nbsp;and&nbsp;returns&nbsp;the&nbsp;time&nbsp;since&nbsp;the&nbsp;last&nbsp;start.</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;1,&nbsp;outputs&nbsp;the&nbsp;time&nbsp;spent.</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;2,&nbsp;outputs&nbsp;the&nbsp;time&nbsp;spent&nbsp;only&nbsp;if&nbsp;nonzero</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;3,4,&nbsp;like&nbsp;1,2,&nbsp;except&nbsp;brief,&nbsp;table-form&nbsp;output</tt></dd>
<a NAME="CCutil_total_timer"></a>
<h2>CCutil_total_timer</h2>
<dt>File:</dt>
<dd><tt>UTIL/zeit.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>double&nbsp;CCutil_total_timer&nbsp;(CCutil_timer&nbsp;*t,&nbsp;int&nbsp;printit)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Returns&nbsp;the&nbsp;cumulative&nbsp;time&nbsp;for&nbsp;this&nbsp;timer.</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;1,&nbsp;outputs&nbsp;the&nbsp;cumulative&nbsp;time.</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;2,&nbsp;outputs&nbsp;the&nbsp;cumulative&nbsp;time&nbsp;only&nbsp;if&nbsp;nonzero</tt></dd>
<dd><tt>-&nbsp;if&nbsp;printit&nbsp;==&nbsp;3,4,&nbsp;like&nbsp;1,2,&nbsp;except&nbsp;brief,&nbsp;table-form&nbsp;output</tt></dd>
<a NAME="CCutil_nextprime"></a>
<h2>CCutil_nextprime</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>unsigned&nbsp;int&nbsp;CCutil_nextprime&nbsp;(unsigned&nbsp;int&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>FINDS&nbsp;the&nbsp;smallest&nbsp;positive&nbsp;prime&nbsp;>=&nbsp;x</tt></dd>
<a NAME="CCutil_our_gcd"></a>
<h2>CCutil_our_gcd</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_our_gcd&nbsp;(int&nbsp;a,&nbsp;int&nbsp;b)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;gcd(a,b)</tt></dd>
<dd><tt>-gcd(a,b)&nbsp;is&nbsp;always&nbsp;>=&nbsp;0</tt></dd>
<dd><tt>-a&nbsp;and&nbsp;b&nbsp;can&nbsp;be&nbsp;negative,&nbsp;positive,&nbsp;or&nbsp;zero</tt></dd>
<a NAME="CCutil_our_lcm"></a>
<h2>CCutil_our_lcm</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_our_lcm&nbsp;(int&nbsp;a,&nbsp;int&nbsp;b)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;lcm(a,b)</tt></dd>
<dd><tt>-lcm(a,b)&nbsp;is&nbsp;always&nbsp;>=&nbsp;0</tt></dd>
<dd><tt>-a&nbsp;and&nbsp;b&nbsp;can&nbsp;be&nbsp;negative,&nbsp;positive,&nbsp;or&nbsp;zero</tt></dd>
<a NAME="CCutil_strchr"></a>
<h2>CCutil_strchr</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>char&nbsp;*CCutil_strchr&nbsp;(char&nbsp;*s,&nbsp;int&nbsp;c)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;first&nbsp;occurrence&nbsp;of&nbsp;c&nbsp;in&nbsp;s,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;c</tt></dd>
<dd><tt>does&nbsp;not&nbsp;occur&nbsp;in&nbsp;s</tt></dd>
<a NAME="CCutil_strrchr"></a>
<h2>CCutil_strrchr</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>char&nbsp;*CCutil_strrchr&nbsp;(char&nbsp;*s,&nbsp;int&nbsp;c)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;last&nbsp;occurrence&nbsp;of&nbsp;c&nbsp;in&nbsp;s,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;c</tt></dd>
<dd><tt>does&nbsp;not&nbsp;occur&nbsp;in&nbsp;s</tt></dd>
<a NAME="CCutil_strchr_c"></a>
<h2>CCutil_strchr_c</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>const&nbsp;char&nbsp;*CCutil_strchr_c&nbsp;(const&nbsp;char&nbsp;*s,&nbsp;int&nbsp;c)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;first&nbsp;occurrence&nbsp;of&nbsp;c&nbsp;in&nbsp;s,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;c</tt></dd>
<dd><tt>does&nbsp;not&nbsp;occur&nbsp;in&nbsp;s.&nbsp;&nbsp;A&nbsp;variant&nbsp;for&nbsp;const&nbsp;strings.</tt></dd>
<a NAME="CCutil_strrchr_c"></a>
<h2>CCutil_strrchr_c</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>const&nbsp;char&nbsp;*CCutil_strrchr_c&nbsp;(const&nbsp;char&nbsp;*s,&nbsp;int&nbsp;c)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;last&nbsp;occurrence&nbsp;of&nbsp;c&nbsp;in&nbsp;s,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;c</tt></dd>
<dd><tt>does&nbsp;not&nbsp;occur&nbsp;in&nbsp;s.&nbsp;&nbsp;A&nbsp;variant&nbsp;for&nbsp;const&nbsp;strings.</tt></dd>
<a NAME="CCutil_strdup"></a>
<h2>CCutil_strdup</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>char&nbsp;*CCutil_strdup&nbsp;(const&nbsp;char&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;copy&nbsp;of&nbsp;s,&nbsp;allocated&nbsp;with&nbsp;CC_SAFE_MALLOC,</tt></dd>
<dd><tt>or&nbsp;NULL&nbsp;if&nbsp;unable&nbsp;to&nbsp;allocate&nbsp;space&nbsp;for&nbsp;the&nbsp;string</tt></dd>
<a NAME="CCutil_strdup2"></a>
<h2>CCutil_strdup2</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>char&nbsp;*CCutil_strdup2&nbsp;(const&nbsp;char&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;copy&nbsp;of&nbsp;s&nbsp;up&nbsp;until&nbsp;the&nbsp;first&nbsp;whitespace,</tt></dd>
<dd><tt>allocated&nbsp;with&nbsp;CC_SAFE_MALLOC,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;unable&nbsp;to&nbsp;allocate&nbsp;space</tt></dd>
<dd><tt>for&nbsp;the&nbsp;string.</tt></dd>
<a NAME="CCutil_readstr"></a>
<h2>CCutil_readstr</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_readstr&nbsp;(FILE&nbsp;*f,&nbsp;char&nbsp;*s,&nbsp;int&nbsp;len)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;a&nbsp;string&nbsp;from&nbsp;f&nbsp;into&nbsp;s.&nbsp;&nbsp;The&nbsp;string&nbsp;is&nbsp;terminated&nbsp;by&nbsp;a</tt></dd>
<dd><tt>whitespace&nbsp;character&nbsp;(space,&nbsp;tab,&nbsp;newline)&nbsp;or&nbsp;EOF.&nbsp;&nbsp;The&nbsp;entire</tt></dd>
<dd><tt>string&nbsp;including&nbsp;the&nbsp;terminating&nbsp;character&nbsp;is&nbsp;read,&nbsp;but&nbsp;only&nbsp;at</tt></dd>
<dd><tt>most&nbsp;len&nbsp;characters&nbsp;are&nbsp;stored&nbsp;in&nbsp;s,&nbsp;including&nbsp;the&nbsp;terminating</tt></dd>
<dd><tt>NULL.</tt></dd>
<a NAME="CCutil_printlabel"></a>
<h2>CCutil_printlabel</h2>
<dt>File:</dt>
<dd><tt>UTIL/util.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_printlabel&nbsp;(void)</tt></dd>
<dt>Description:</dt>
<dd><tt>PRINTS&nbsp;information&nbsp;identifying&nbsp;a&nbsp;machine</tt></dd>
<a NAME="CCutil_sprand"></a>
<h2>CCutil_sprand</h2>
<dt>File:</dt>
<dd><tt>UTIL/urandom.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_sprand&nbsp;(int&nbsp;seed,&nbsp;CCrandstate&nbsp;*r)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Call&nbsp;once&nbsp;to&nbsp;initialize&nbsp;the&nbsp;generator.</tt></dd>
<a NAME="CCutil_lprand"></a>
<h2>CCutil_lprand</h2>
<dt>File:</dt>
<dd><tt>UTIL/urandom.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_lprand&nbsp;(CCrandstate&nbsp;*r)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Returns&nbsp;an&nbsp;integer&nbsp;in&nbsp;the&nbsp;range&nbsp;0&nbsp;to&nbsp;CC_PRANDMAX&nbsp;-&nbsp;1.</tt></dd>
<a NAME="CCutil_normrand"></a>
<h2>CCutil_normrand</h2>
<dt>File:</dt>
<dd><tt>UTIL/urandom.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>double&nbsp;CCutil_normrand&nbsp;(CCrandstate&nbsp;*r)</tt></dd>
<dt>Description:</dt>
<dd><tt>-&nbsp;Returns&nbsp;a&nbsp;normally-distributed&nbsp;random&nbsp;value&nbsp;with&nbsp;mean&nbsp;0&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;deviation&nbsp;1.</tt></dd>
<a NAME="CCutil_signal_handler"></a>
<h2>CCutil_signal_handler</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_signal_handler&nbsp;(int&nbsp;ccsignum,&nbsp;CCutil_handler&nbsp;handler)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;-ccsignum&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;CCutil_SIG*&nbsp;values&nbsp;defined&nbsp;in&nbsp;util.h</tt></dd>
<dd><tt>&nbsp;-handler&nbsp;is&nbsp;the&nbsp;new&nbsp;signal&nbsp;handler.</tt></dd>
<dd><tt>INSTALLS&nbsp;handler&nbsp;as&nbsp;the&nbsp;handler&nbsp;for&nbsp;ccsignum&nbsp;signals.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>CCutil_handler&nbsp;is&nbsp;just&nbsp;a&nbsp;typedef&nbsp;for&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;signal</tt></dd>
<dd><tt>handling&nbsp;function.&nbsp;&nbsp;It&nbsp;is&nbsp;a&nbsp;void&nbsp;(*)(int).&nbsp;&nbsp;The&nbsp;signal&nbsp;handler</tt></dd>
<dd><tt>is&nbsp;called&nbsp;whenever&nbsp;the&nbsp;signal&nbsp;is&nbsp;raised.&nbsp;&nbsp;The&nbsp;integer&nbsp;argument</tt></dd>
<dd><tt>passed&nbsp;to&nbsp;the&nbsp;signal&nbsp;handler&nbsp;is&nbsp;the&nbsp;signal&nbsp;number,&nbsp;in&nbsp;the</tt></dd>
<dd><tt>operating&nbsp;system's&nbsp;numbering.&nbsp;&nbsp;CCutil_sig_to_ccsig&nbsp;can&nbsp;be&nbsp;used</tt></dd>
<dd><tt>to&nbsp;convert&nbsp;this&nbsp;signal&nbsp;number&nbsp;into&nbsp;a&nbsp;CCutil_SIG*&nbsp;value.</tt></dd>
<dd><tt>CCutil_handler_fatal&nbsp;and&nbsp;CCutil_handler_warn&nbsp;are&nbsp;provided&nbsp;as</tt></dd>
<dd><tt>signal&nbsp;handlers&nbsp;for&nbsp;two&nbsp;common&nbsp;cases.</tt></dd>
<a NAME="CCutil_signal_default"></a>
<h2>CCutil_signal_default</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_signal_default&nbsp;(int&nbsp;ccsignum)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;-ccsignum&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;CCutil_SIG*&nbsp;values&nbsp;defined&nbsp;in&nbsp;util.h</tt></dd>
<dd><tt>RESTORES&nbsp;the&nbsp;default&nbsp;handling&nbsp;for&nbsp;ccsignum&nbsp;signals.</tt></dd>
<a NAME="CCutil_signal_ignore"></a>
<h2>CCutil_signal_ignore</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_signal_ignore&nbsp;(int&nbsp;ccsignum)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;-ccsignum&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;CCutil_SIG*&nbsp;values&nbsp;defined&nbsp;in&nbsp;util.h</tt></dd>
<dd><tt>IGNORES&nbsp;ccsignum&nbsp;signals.</tt></dd>
<a NAME="CCutil_sig_to_ccsig"></a>
<h2>CCutil_sig_to_ccsig</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sig_to_ccsig&nbsp;(int&nbsp;signum)</tt></dd>
<dt>Description:</dt>
<dd><tt>CONVERTS&nbsp;a&nbsp;signal&nbsp;number&nbsp;from&nbsp;the&nbsp;operating&nbsp;system's&nbsp;terms&nbsp;to</tt></dd>
<dd><tt>a&nbsp;CCutil_SIG*&nbsp;value.&nbsp;&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;corresponding&nbsp;value,&nbsp;returns</tt></dd>
<dd><tt>-1.</tt></dd>
<a NAME="CCutil_signal_init"></a>
<h2>CCutil_signal_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_signal_init&nbsp;(void)</tt></dd>
<dt>Description:</dt>
<dd><tt>INITIALIZES&nbsp;signal&nbsp;handlers&nbsp;to&nbsp;CCutil_handler_fatal,</tt></dd>
<dd><tt>CCutil_handler_warn&nbsp;or&nbsp;CCutil_handler_exit&nbsp;as&nbsp;appropriate.</tt></dd>
<a NAME="CCutil_handler_fatal"></a>
<h2>CCutil_handler_fatal</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_handler_fatal&nbsp;(int&nbsp;signum)</tt></dd>
<dt>Description:</dt>
<dd><tt>HANDLES&nbsp;a&nbsp;signal&nbsp;by&nbsp;printing&nbsp;an&nbsp;error&nbsp;message,&nbsp;waiting&nbsp;a&nbsp;long</tt></dd>
<dd><tt>time&nbsp;to&nbsp;provide&nbsp;an&nbsp;opportunity&nbsp;to&nbsp;examine&nbsp;the&nbsp;program&nbsp;state&nbsp;with</tt></dd>
<dd><tt>a&nbsp;debugger,&nbsp;and&nbsp;then&nbsp;exiting.&nbsp;&nbsp;Designed&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;handler</tt></dd>
<dd><tt>argument&nbsp;to&nbsp;CCutil_signal_handler.</tt></dd>
<a NAME="CCutil_handler_warn"></a>
<h2>CCutil_handler_warn</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_handler_warn&nbsp;(int&nbsp;signum)</tt></dd>
<dt>Description:</dt>
<dd><tt>HANDLES&nbsp;a&nbsp;signal&nbsp;by&nbsp;printing&nbsp;a&nbsp;warning&nbsp;message&nbsp;and&nbsp;continuing.</tt></dd>
<dd><tt>Designed&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;handler&nbsp;argument&nbsp;to&nbsp;CCutil_signal_handler.</tt></dd>
<a NAME="CCutil_handler_exit"></a>
<h2>CCutil_handler_exit</h2>
<dt>File:</dt>
<dd><tt>UTIL/signal.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_handler_exit&nbsp;(int&nbsp;signum)</tt></dd>
<dt>Description:</dt>
<dd><tt>HANDLES&nbsp;a&nbsp;signal&nbsp;by&nbsp;printing&nbsp;a&nbsp;warning&nbsp;message&nbsp;and&nbsp;exiting.</tt></dd>
<dd><tt>Designed&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;handler&nbsp;argument&nbsp;to&nbsp;CCutil_signal_handler.</tt></dd>
<a NAME="CCutil_sopen"></a>
<h2>CCutil_sopen</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SFILE&nbsp;*CCutil_sopen&nbsp;(char&nbsp;*f,&nbsp;char&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Opens&nbsp;a&nbsp;file&nbsp;for&nbsp;buffered&nbsp;binary&nbsp;I/O.&nbsp;&nbsp;The&nbsp;buffered&nbsp;binary&nbsp;I/O</tt></dd>
<dd><tt>&nbsp;&nbsp;routines&nbsp;using&nbsp;CC_SFILE's&nbsp;attempt&nbsp;to&nbsp;be&nbsp;machine&nbsp;independent,</tt></dd>
<dd><tt>&nbsp;&nbsp;and&nbsp;only&nbsp;compatible&nbsp;with&nbsp;themselves.&nbsp;&nbsp;Comparable&nbsp;to&nbsp;the&nbsp;stdio</tt></dd>
<dd><tt>&nbsp;&nbsp;routine&nbsp;fopen().&nbsp;&nbsp;If&nbsp;the&nbsp;file&nbsp;already&nbsp;exists&nbsp;and&nbsp;is&nbsp;being</tt></dd>
<dd><tt>&nbsp;&nbsp;opened&nbsp;for&nbsp;output,&nbsp;the&nbsp;old&nbsp;file&nbsp;is&nbsp;renamed&nbsp;by&nbsp;prepending&nbsp;an&nbsp;O</tt></dd>
<dd><tt>&nbsp;&nbsp;to&nbsp;is&nbsp;name.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;filename&nbsp;to&nbsp;open.&nbsp;&nbsp;"stdin"&nbsp;means&nbsp;descriptor&nbsp;0,&nbsp;"stdout"</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;descriptor&nbsp;1,&nbsp;and&nbsp;"stderr"&nbsp;descriptor&nbsp;2.&nbsp;&nbsp;"-"&nbsp;means</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;descriptor&nbsp;0&nbsp;or&nbsp;1,&nbsp;depending&nbsp;on&nbsp;wither&nbsp;the&nbsp;file&nbsp;is&nbsp;opened</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;reading&nbsp;or&nbsp;writing.</tt></dd>
<dd><tt>s&nbsp;-&nbsp;the&nbsp;mode&nbsp;to&nbsp;open,&nbsp;either&nbsp;"r"&nbsp;for&nbsp;input,&nbsp;or&nbsp;"w"&nbsp;for&nbsp;output.</tt></dd>
<dd><tt>returns&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;opened&nbsp;file,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;there&nbsp;is&nbsp;an</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;error.</tt></dd>
<a NAME="CCutil_sdopen"></a>
<h2>CCutil_sdopen</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SFILE&nbsp;*CCutil_sdopen&nbsp;(int&nbsp;d,&nbsp;char&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Opens&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;buffered&nbsp;binary&nbsp;I/O.&nbsp;&nbsp;The&nbsp;buffered&nbsp;binary</tt></dd>
<dd><tt>&nbsp;&nbsp;I/O&nbsp;routines&nbsp;using&nbsp;CC_SFILE's&nbsp;attempt&nbsp;to&nbsp;be&nbsp;machine&nbsp;independent,</tt></dd>
<dd><tt>&nbsp;&nbsp;and&nbsp;only&nbsp;compatible&nbsp;with&nbsp;themselves.&nbsp;&nbsp;Comparable&nbsp;to&nbsp;the&nbsp;stdio</tt></dd>
<dd><tt>&nbsp;&nbsp;routine&nbsp;fdopen().</tt></dd>
<dd><tt>d&nbsp;-&nbsp;the&nbsp;descriptor&nbsp;to&nbsp;open.</tt></dd>
<dd><tt>s&nbsp;-&nbsp;the&nbsp;mode&nbsp;to&nbsp;open,&nbsp;either&nbsp;"r"&nbsp;for&nbsp;input,&nbsp;"w"&nbsp;for&nbsp;output,&nbsp;or</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;"rw"&nbsp;for&nbsp;both&nbsp;input&nbsp;and&nbsp;output.</tt></dd>
<dd><tt>returns&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;opened&nbsp;file,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;there&nbsp;is&nbsp;an</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;error.</tt></dd>
<a NAME="CCutil_swrite"></a>
<h2>CCutil_swrite</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite&nbsp;(CC_SFILE&nbsp;*f,&nbsp;char&nbsp;*buf,&nbsp;int&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>buf&nbsp;-&nbsp;the&nbsp;data&nbsp;to&nbsp;write</tt></dd>
<dd><tt>size&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_bits"></a>
<h2>CCutil_swrite_bits</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_bits&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;x,&nbsp;int&nbsp;xbits)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;bits&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;an&nbsp;int&nbsp;containing&nbsp;the&nbsp;data&nbsp;to&nbsp;write</tt></dd>
<dd><tt>xbits&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;to&nbsp;write.&nbsp;&nbsp;The&nbsp;lowest&nbsp;order&nbsp;xbits</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bits&nbsp;of&nbsp;x&nbsp;will&nbsp;be&nbsp;written.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_ubits"></a>
<h2>CCutil_swrite_ubits</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_ubits&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;int&nbsp;x,&nbsp;int&nbsp;xbits)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;bits&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;an&nbsp;unsigned&nbsp;int&nbsp;int&nbsp;containing&nbsp;the&nbsp;data&nbsp;to&nbsp;write</tt></dd>
<dd><tt>xbits&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;to&nbsp;write.&nbsp;&nbsp;The&nbsp;lowest&nbsp;order&nbsp;xbits</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bits&nbsp;of&nbsp;x&nbsp;will&nbsp;be&nbsp;written.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_char"></a>
<h2>CCutil_swrite_char</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_char&nbsp;(CC_SFILE&nbsp;*f,&nbsp;char&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;a&nbsp;char&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;char&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_string"></a>
<h2>CCutil_swrite_string</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_string&nbsp;(CC_SFILE&nbsp;*f,&nbsp;const&nbsp;char&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;a&nbsp;string&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>s&nbsp;-&nbsp;the&nbsp;string&nbsp;to&nbsp;write.&nbsp;&nbsp;The&nbsp;array&nbsp;of&nbsp;characters&nbsp;in&nbsp;s&nbsp;up&nbsp;to&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;including&nbsp;the&nbsp;first&nbsp;NULL&nbsp;are&nbsp;written.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_short"></a>
<h2>CCutil_swrite_short</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_short&nbsp;(CC_SFILE&nbsp;*f,&nbsp;short&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;a&nbsp;short&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;short&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_ushort"></a>
<h2>CCutil_swrite_ushort</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_ushort&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;short&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;an&nbsp;unsigned&nbsp;short&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;unsigned&nbsp;short&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_int"></a>
<h2>CCutil_swrite_int</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_int&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;an&nbsp;int&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;int&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_uint"></a>
<h2>CCutil_swrite_uint</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_uint&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;int&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;an&nbsp;unsigned&nbsp;int&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;unsigned&nbsp;int&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_swrite_double"></a>
<h2>CCutil_swrite_double</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_swrite_double&nbsp;(CC_SFILE&nbsp;*f,&nbsp;double&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;writes&nbsp;a&nbsp;double&nbsp;to&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;to</tt></dd>
<dd><tt>x&nbsp;-&nbsp;the&nbsp;double&nbsp;to&nbsp;write</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread"></a>
<h2>CCutil_sread</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread&nbsp;(CC_SFILE&nbsp;*f,&nbsp;char&nbsp;*buf,&nbsp;int&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>buf&nbsp;-&nbsp;a&nbsp;buffer&nbsp;in&nbsp;which&nbsp;to&nbsp;store&nbsp;the&nbsp;data&nbsp;read.&nbsp;&nbsp;buf&nbsp;should&nbsp;have</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space&nbsp;for&nbsp;size&nbsp;characters.</tt></dd>
<dd><tt>size&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_bits"></a>
<h2>CCutil_sread_bits</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_bits&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;*x,&nbsp;int&nbsp;xbits)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;bits&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;bits&nbsp;read&nbsp;(in&nbsp;the&nbsp;low-order</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;xbits&nbsp;bits).</tt></dd>
<dd><tt>xbits&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;read.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_ubits"></a>
<h2>CCutil_sread_ubits</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_ubits&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;int&nbsp;*x,&nbsp;int&nbsp;xbits)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;bits&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;bits&nbsp;read&nbsp;(in&nbsp;the&nbsp;low-order</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;xbits&nbsp;bits).</tt></dd>
<dd><tt>xbits&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;read.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_char"></a>
<h2>CCutil_sread_char</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_char&nbsp;(CC_SFILE&nbsp;*f,&nbsp;char&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;char&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;char&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_string"></a>
<h2>CCutil_sread_string</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_string&nbsp;(CC_SFILE&nbsp;*f,&nbsp;char&nbsp;*x,&nbsp;int&nbsp;maxlen)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;string&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;string&nbsp;read.</tt></dd>
<dd><tt>maxlen&nbsp;-&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;characters&nbsp;to&nbsp;read.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_short"></a>
<h2>CCutil_sread_short</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_short&nbsp;(CC_SFILE&nbsp;*f,&nbsp;short&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;short&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;short&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_ushort"></a>
<h2>CCutil_sread_ushort</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_ushort&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;short&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;an&nbsp;unsigned&nbsp;short&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;unsigned&nbsp;short&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_short_r"></a>
<h2>CCutil_sread_short_r</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_short_r&nbsp;(CC_SFILE&nbsp;*f,&nbsp;short&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;reversed&nbsp;short&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;short&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<dd><tt>CCutil_sread_short_r&nbsp;is&nbsp;provided&nbsp;for&nbsp;compatability&nbsp;with&nbsp;some</tt></dd>
<dd><tt>binary&nbsp;files&nbsp;written&nbsp;by&nbsp;other&nbsp;tools&nbsp;which&nbsp;use&nbsp;a&nbsp;different&nbsp;byte</tt></dd>
<dd><tt>order.</tt></dd>
<a NAME="CCutil_sread_int"></a>
<h2>CCutil_sread_int</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_int&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;an&nbsp;int&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;int&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_uint"></a>
<h2>CCutil_sread_uint</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_uint&nbsp;(CC_SFILE&nbsp;*f,&nbsp;unsigned&nbsp;int&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;an&nbsp;unsigned&nbsp;int&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;unsigned&nbsp;int&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_int_r"></a>
<h2>CCutil_sread_int_r</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_int_r&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;reversed&nbsp;int&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;int&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<dd><tt>CCutil_sread_int_r&nbsp;is&nbsp;provided&nbsp;for&nbsp;compatability&nbsp;with&nbsp;some</tt></dd>
<dd><tt>binary&nbsp;files&nbsp;written&nbsp;by&nbsp;other&nbsp;tools&nbsp;which&nbsp;use&nbsp;a&nbsp;different&nbsp;byte</tt></dd>
<dd><tt>order.</tt></dd>
<a NAME="CCutil_sread_double"></a>
<h2>CCutil_sread_double</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_double&nbsp;(CC_SFILE&nbsp;*f,&nbsp;double&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;double&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;double&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_sread_double_r"></a>
<h2>CCutil_sread_double_r</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sread_double_r&nbsp;(CC_SFILE&nbsp;*f,&nbsp;double&nbsp;*x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;reads&nbsp;a&nbsp;reversed&nbsp;double&nbsp;from&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from.</tt></dd>
<dd><tt>x&nbsp;-&nbsp;on&nbsp;return,&nbsp;will&nbsp;contain&nbsp;the&nbsp;double&nbsp;read</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<dd><tt>CCutil_sread_double_r&nbsp;is&nbsp;provided&nbsp;for&nbsp;compatability&nbsp;with&nbsp;some</tt></dd>
<dd><tt>binary&nbsp;files&nbsp;written&nbsp;by&nbsp;other&nbsp;tools&nbsp;which&nbsp;use&nbsp;a&nbsp;different&nbsp;byte</tt></dd>
<dd><tt>order.</tt></dd>
<a NAME="CCutil_sflush"></a>
<h2>CCutil_sflush</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sflush&nbsp;(CC_SFILE&nbsp;*f)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;flushes&nbsp;the&nbsp;buffer&nbsp;of&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;flush</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;if&nbsp;succesful,&nbsp;nonzero&nbsp;if&nbsp;failure.</tt></dd>
<a NAME="CCutil_stell"></a>
<h2>CCutil_stell</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_stell&nbsp;(CC_SFILE&nbsp;*f)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;returns&nbsp;the&nbsp;current&nbsp;location&nbsp;in&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>&nbsp;&nbsp;Comparable&nbsp;to&nbsp;the&nbsp;stdio&nbsp;function&nbsp;ftell().</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE</tt></dd>
<dd><tt>returns&nbsp;the&nbsp;current&nbsp;location,&nbsp;or&nbsp;-1&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_sseek"></a>
<h2>CCutil_sseek</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sseek&nbsp;(CC_SFILE&nbsp;*f,&nbsp;int&nbsp;offset)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;changes&nbsp;the&nbsp;current&nbsp;location&nbsp;in&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file.</tt></dd>
<dd><tt>&nbsp;&nbsp;Comparable&nbsp;to&nbsp;the&nbsp;stdio&nbsp;function&nbsp;fseek().</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE</tt></dd>
<dd><tt>offset&nbsp;-&nbsp;a&nbsp;value&nbsp;returned&nbsp;by&nbsp;CCutil_stell().</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;for&nbsp;success,&nbsp;nonzero&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_srewind"></a>
<h2>CCutil_srewind</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_srewind&nbsp;(CC_SFILE&nbsp;*f)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;changes&nbsp;the&nbsp;current&nbsp;location&nbsp;in&nbsp;a&nbsp;buffered&nbsp;binary&nbsp;I/O&nbsp;file&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;the&nbsp;beginning.&nbsp;&nbsp;Comparable&nbsp;to&nbsp;the&nbsp;stdio&nbsp;function&nbsp;rewind().</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;for&nbsp;success,&nbsp;nonzero&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_sclose"></a>
<h2>CCutil_sclose</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sclose&nbsp;(CC_SFILE&nbsp;*f)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;closes&nbsp;a&nbsp;CC_SFILE.</tt></dd>
<dd><tt>f&nbsp;-&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;close</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;for&nbsp;success,&nbsp;nonzero&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_sbits"></a>
<h2>CCutil_sbits</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sbits&nbsp;(unsigned&nbsp;int&nbsp;x)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;computes&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;necessary&nbsp;to&nbsp;represent&nbsp;all</tt></dd>
<dd><tt>&nbsp;&nbsp;nonnegative&nbsp;integers&nbsp;<=&nbsp;x</tt></dd>
<dd><tt>x&nbsp;-&nbsp;a&nbsp;number</tt></dd>
<dd><tt>returns&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;necessary&nbsp;to&nbsp;represent&nbsp;x.</tt></dd>
<a NAME="CCutil_sdelete_file"></a>
<h2>CCutil_sdelete_file</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sdelete_file&nbsp;(const&nbsp;char&nbsp;*fname)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;deletes&nbsp;a&nbsp;file.</tt></dd>
<dd><tt>fname&nbsp;-&nbsp;the&nbsp;file&nbsp;to&nbsp;delete</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;for&nbsp;success,&nbsp;nonzero&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_sdelete_file_backup"></a>
<h2>CCutil_sdelete_file_backup</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sdelete_file_backup&nbsp;(const&nbsp;char&nbsp;*fname)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;deletes&nbsp;the&nbsp;backup&nbsp;file&nbsp;for&nbsp;fname&nbsp;(created&nbsp;if&nbsp;fname&nbsp;was</tt></dd>
<dd><tt>&nbsp;&nbsp;overwritten&nbsp;by&nbsp;CCutil_sopen).</tt></dd>
<dd><tt>fname&nbsp;-&nbsp;the&nbsp;file&nbsp;name&nbsp;whose&nbsp;backup&nbsp;is&nbsp;to&nbsp;be&nbsp;deleted.</tt></dd>
<dd><tt>returns&nbsp;0&nbsp;for&nbsp;success,&nbsp;nonzero&nbsp;for&nbsp;failure.</tt></dd>
<a NAME="CCutil_snet_open"></a>
<h2>CCutil_snet_open</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SFILE&nbsp;*CCutil_snet_open&nbsp;(char&nbsp;*h,&nbsp;unsigned&nbsp;short&nbsp;p)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Opens&nbsp;a&nbsp;network&nbsp;connection&nbsp;to&nbsp;a&nbsp;port&nbsp;on&nbsp;a&nbsp;remote&nbsp;host</tt></dd>
<dd><tt>h&nbsp;-&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;host&nbsp;to&nbsp;connect&nbsp;to</tt></dd>
<dd><tt>p&nbsp;-&nbsp;the&nbsp;port&nbsp;on&nbsp;the&nbsp;host&nbsp;to&nbsp;connect&nbsp;to</tt></dd>
<dd><tt>returns&nbsp;a&nbsp;CC_SFILE&nbsp;(opened&nbsp;for&nbsp;input&nbsp;and&nbsp;output)&nbsp;for&nbsp;buffered</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binary&nbsp;I/O&nbsp;to&nbsp;the&nbsp;specified&nbsp;port&nbsp;on&nbsp;the&nbsp;remote&nbsp;host,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;NULL&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;failure.</tt></dd>
<dd><tt>Only&nbsp;exists&nbsp;if&nbsp;CC_NETREADY&nbsp;is&nbsp;defined</tt></dd>
<a NAME="CCutil_snet_receive"></a>
<h2>CCutil_snet_receive</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SFILE&nbsp;*CCutil_snet_receive&nbsp;(CC_SPORT&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Accepts&nbsp;a&nbsp;network&nbsp;connection&nbsp;on&nbsp;a&nbsp;port.</tt></dd>
<dd><tt>s&nbsp;-&nbsp;the&nbsp;CC_SPORT&nbsp;to&nbsp;accept&nbsp;a&nbsp;connection&nbsp;from.&nbsp;&nbsp;Must&nbsp;be&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;returned&nbsp;result&nbsp;of&nbsp;a&nbsp;successfull&nbsp;CCutil_snet_listen&nbsp;call.</tt></dd>
<dd><tt>returns&nbsp;a&nbsp;CC_SFILE&nbsp;(opened&nbsp;for&nbsp;input&nbsp;and&nbsp;output)&nbsp;for&nbsp;buffered</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;binary&nbsp;I/O&nbsp;on&nbsp;the&nbsp;specified&nbsp;port,&nbsp;or&nbsp;NULL&nbsp;if&nbsp;there&nbsp;is&nbsp;a</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;failure.</tt></dd>
<dd><tt>Only&nbsp;exists&nbsp;if&nbsp;CC_NETREADY&nbsp;is&nbsp;defined</tt></dd>
<a NAME="CCutil_snet_listen"></a>
<h2>CCutil_snet_listen</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SPORT&nbsp;*CCutil_snet_listen&nbsp;(unsigned&nbsp;short&nbsp;p)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Prepares&nbsp;to&nbsp;accept&nbsp;network&nbsp;connections&nbsp;on&nbsp;a&nbsp;port.</tt></dd>
<dd><tt>p&nbsp;-&nbsp;the&nbsp;port&nbsp;on&nbsp;which&nbsp;to&nbsp;accept&nbsp;connections.</tt></dd>
<dd><tt>returns&nbsp;a&nbsp;CC_SPORT&nbsp;for&nbsp;accepting&nbsp;connections&nbsp;on&nbsp;the&nbsp;specified</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;port.&nbsp;&nbsp;This&nbsp;return&nbsp;value&nbsp;is&nbsp;passed&nbsp;to&nbsp;CCutil_snet_receive&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;accept&nbsp;a&nbsp;connection.&nbsp;&nbsp;Returns&nbsp;NULL&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;failure.</tt></dd>
<dd><tt>Only&nbsp;exists&nbsp;if&nbsp;CC_NETREADY&nbsp;is&nbsp;defined</tt></dd>
<a NAME="CCutil_snet_unlisten"></a>
<h2>CCutil_snet_unlisten</h2>
<dt>File:</dt>
<dd><tt>UTIL/safe_io.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_snet_unlisten&nbsp;(CC_SPORT&nbsp;*s)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;Ceases&nbsp;accepting&nbsp;network&nbsp;connections&nbsp;from&nbsp;an&nbsp;CC_SPORT.</tt></dd>
<dd><tt>s&nbsp;-&nbsp;the&nbsp;CC_SPORT&nbsp;to&nbsp;close.</tt></dd>
<dd><tt>Only&nbsp;exists&nbsp;if&nbsp;CC_NETREADY&nbsp;is&nbsp;defined</tt></dd>
<a NAME="CCutil_priority_init"></a>
<h2>CCutil_priority_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_priority_init&nbsp;(CCpriority&nbsp;*pri,&nbsp;int&nbsp;k)</tt></dd>
<dt>Description:</dt>
<dd><tt>-h&nbsp;should&nbsp;point&nbsp;to&nbsp;a&nbsp;CCpriority&nbsp;struct.</tt></dd>
<dd><tt>-k&nbsp;an&nbsp;initial&nbsp;allocation&nbsp;for&nbsp;the&nbsp;priority&nbsp;queue.</tt></dd>
<a NAME="CCutil_priority_free"></a>
<h2>CCutil_priority_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_priority_free&nbsp;(CCpriority&nbsp;*pri)</tt></dd>
<dt>Description:</dt>
<dd><tt>-frees&nbsp;the&nbsp;spaces&nbsp;allocated&nbsp;for&nbsp;the&nbsp;CCpriority&nbsp;queue.</tt></dd>
<a NAME="CCutil_priority_findmin"></a>
<h2>CCutil_priority_findmin</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_priority_findmin&nbsp;(CCpriority&nbsp;*pri,&nbsp;double&nbsp;*keyval)</tt></dd>
<dt>Description:</dt>
<dd><tt>-returns&nbsp;the&nbsp;entry&nbsp;with&nbsp;least&nbsp;key&nbsp;value.</tt></dd>
<dd><tt>-returns&nbsp;NULL&nbsp;if&nbsp;no&nbsp;entries&nbsp;in&nbsp;heap.</tt></dd>
<dd><tt>-if&nbsp;(keyval&nbsp;!=&nbsp;NULL),&nbsp;*keyval&nbsp;will&nbsp;be&nbsp;the&nbsp;minimum&nbsp;key&nbsp;value.</tt></dd>
<a NAME="CCutil_priority_insert"></a>
<h2>CCutil_priority_insert</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_priority_insert&nbsp;(CCpriority&nbsp;*pri,&nbsp;void&nbsp;*data,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;keyval)</tt></dd>
<dt>Description:</dt>
<dd><tt>-adds&nbsp;(data,&nbsp;keyval)&nbsp;to&nbsp;h.</tt></dd>
<dd><tt>-returns&nbsp;a&nbsp;handle&nbsp;(>=&nbsp;0)&nbsp;to&nbsp;use&nbsp;when&nbsp;deleting&nbsp;or&nbsp;changing&nbsp;the&nbsp;entry</tt></dd>
<dd><tt>-returns&nbsp;-1&nbsp;if&nbsp;out&nbsp;of&nbsp;memory.</tt></dd>
<a NAME="CCutil_priority_delete"></a>
<h2>CCutil_priority_delete</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_priority_delete&nbsp;(CCpriority&nbsp;*pri,&nbsp;int&nbsp;handle)</tt></dd>
<dt>Description:</dt>
<dd><tt>-deletes&nbsp;an&nbsp;entry&nbsp;from&nbsp;the&nbsp;queue.&nbsp;&nbsp;handle&nbsp;is&nbsp;the&nbsp;value&nbsp;returned&nbsp;by</tt></dd>
<dd><tt>&nbsp;CCutil_priority_insert.</tt></dd>
<a NAME="CCutil_priority_deletemin"></a>
<h2>CCutil_priority_deletemin</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_priority_deletemin&nbsp;(CCpriority&nbsp;*pri,&nbsp;double&nbsp;*keyval)</tt></dd>
<dt>Description:</dt>
<dd><tt>-like&nbsp;CCutil_priority_findmin,&nbsp;but&nbsp;also&nbsp;deletes&nbsp;the&nbsp;entry.</tt></dd>
<a NAME="CCutil_priority_changekey"></a>
<h2>CCutil_priority_changekey</h2>
<dt>File:</dt>
<dd><tt>UTIL/priority.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_priority_changekey&nbsp;(CCpriority&nbsp;*pri,&nbsp;int&nbsp;handle,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;newkey)</tt></dd>
<dt>Description:</dt>
<dd><tt>-changes&nbsp;the&nbsp;key&nbsp;of&nbsp;an&nbsp;entry&nbsp;in&nbsp;the&nbsp;queue.&nbsp;&nbsp;handle&nbsp;is&nbsp;the&nbsp;value</tt></dd>
<dd><tt>&nbsp;returned&nbsp;by&nbsp;CCutil_priority_insert.</tt></dd>
<a NAME="CCutil_getdata"></a>
<h2>CCutil_getdata</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getdata&nbsp;(char&nbsp;*datname,&nbsp;int&nbsp;binary_in,&nbsp;int&nbsp;innorm,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*ncount,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;data&nbsp;to&nbsp;generate&nbsp;edge&nbsp;lengths&nbsp;in&nbsp;the&nbsp;dat&nbsp;structure.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;calling&nbsp;routine&nbsp;should&nbsp;be&nbsp;sure&nbsp;that&nbsp;dat&nbsp;points&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;structure.&nbsp;If&nbsp;datname&nbsp;is&nbsp;NULL&nbsp;then&nbsp;random&nbsp;entries&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generated.</tt></dd>
<dd><tt>&nbsp;-datname&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;datfile&nbsp;or&nbsp;the&nbsp;matrix&nbsp;file,&nbsp;if&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;&nbsp;then&nbsp;random&nbsp;data&nbsp;will&nbsp;be&nbsp;generated,&nbsp;according&nbsp;to&nbsp;the&nbsp;norm&nbsp;type.</tt></dd>
<dd><tt>&nbsp;&nbsp;For&nbsp;D2&nbsp;and&nbsp;D3&nbsp;norms,&nbsp;the&nbsp;coordinates&nbsp;will&nbsp;be&nbsp;uniform&nbsp;between&nbsp;0</tt></dd>
<dd><tt>&nbsp;&nbsp;and&nbsp;ncount&nbsp;-1&nbsp;(GEOGRAPHIC&nbsp;norms&nbsp;have&nbsp;x&nbsp;between&nbsp;-90&nbsp;and&nbsp;90&nbsp;and&nbsp;y</tt></dd>
<dd><tt>&nbsp;&nbsp;between&nbsp;-180&nbsp;and&nbsp;180).&nbsp;(For&nbsp;D2,&nbsp;the&nbsp;points&nbsp;will&nbsp;be&nbsp;distinct.)</tt></dd>
<dd><tt>&nbsp;&nbsp;For&nbsp;MATRIX&nbsp;norms,&nbsp;the&nbsp;entries&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;uniform&nbsp;between&nbsp;0&nbsp;and&nbsp;MATRAND_SCALE&nbsp;*&nbsp;ncount&nbsp;-&nbsp;1&nbsp;(currently</tt></dd>
<dd><tt>&nbsp;&nbsp;10*ncount&nbsp;-&nbsp;1.&nbsp;For&nbsp;CRYSTAL&nbsp;norms,&nbsp;a&nbsp;random&nbsp;matrix&nbsp;and&nbsp;bounds&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;range&nbsp;of&nbsp;the&nbsp;TSPLIB&nbsp;problems&nbsp;is&nbsp;generated&nbsp;-&nbsp;the&nbsp;wavelength&nbsp;is</tt></dd>
<dd><tt>&nbsp;&nbsp;chosen&nbsp;to&nbsp;be&nbsp;1.0,&nbsp;1.35,&nbsp;or&nbsp;1.70&nbsp;depending&nbsp;on&nbsp;the&nbsp;ncount&nbsp;(but&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;problem&nbsp;will&nbsp;not&nbsp;be&nbsp;very&nbsp;close&nbsp;to&nbsp;hitting&nbsp;ncount.).</tt></dd>
<dd><tt>&nbsp;-binary_in&nbsp;should&nbsp;be&nbsp;1&nbsp;if&nbsp;the&nbsp;datname&nbsp;file&nbsp;is&nbsp;in&nbsp;binary&nbsp;integers.</tt></dd>
<dd><tt>&nbsp;-innorm&nbsp;is&nbsp;the&nbsp;norm.</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;will&nbsp;return&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes.&nbsp;If&nbsp;datname&nbsp;is&nbsp;NULL,&nbsp;then</tt></dd>
<dd><tt>&nbsp;&nbsp;ncount&nbsp;should&nbsp;be&nbsp;passed&nbsp;in&nbsp;with&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;to&nbsp;be&nbsp;used&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;the&nbsp;random&nbsp;problem&nbsp;generation.</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;will&nbsp;contain&nbsp;the&nbsp;info&nbsp;to&nbsp;call&nbsp;the&nbsp;edgelen&nbsp;function.</tt></dd>
<a NAME="CCutil_putmaster"></a>
<h2>CCutil_putmaster</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_putmaster&nbsp;(char&nbsp;*mastername,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*perm)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;dat&nbsp;information&nbsp;and&nbsp;the&nbsp;permutation&nbsp;into&nbsp;a&nbsp;binary&nbsp;file.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;used&nbsp;in&nbsp;the&nbsp;TSP,&nbsp;where&nbsp;the&nbsp;dat&nbsp;file&nbsp;has&nbsp;usually</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;been&nbsp;permuted&nbsp;to&nbsp;put&nbsp;the&nbsp;nodes&nbsp;into&nbsp;tour&nbsp;order.</tt></dd>
<dd><tt>&nbsp;-mastername&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;(cannot&nbsp;be&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;contains&nbsp;the&nbsp;edgelen&nbsp;info&nbsp;(e.g.&nbsp;x,y&nbsp;coordinates),&nbsp;it&nbsp;can&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;-perm&nbsp;contains&nbsp;a&nbsp;permutation&nbsp;of&nbsp;0&nbsp;to&nbsp;ncount&nbsp;-&nbsp;1&nbsp;(so&nbsp;a&nbsp;tour&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;node&nbsp;node&nbsp;node&nbsp;format)</tt></dd>
<a NAME="CCutil_writemaster"></a>
<h2>CCutil_writemaster</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writemaster&nbsp;(CC_SFILE&nbsp;*out,&nbsp;int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*perm)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;dat&nbsp;information&nbsp;and&nbsp;the&nbsp;permutation&nbsp;into&nbsp;a&nbsp;binary&nbsp;file.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;used&nbsp;in&nbsp;the&nbsp;TSP,&nbsp;where&nbsp;the&nbsp;dat&nbsp;file&nbsp;has&nbsp;usually</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;been&nbsp;permuted&nbsp;to&nbsp;put&nbsp;the&nbsp;nodes&nbsp;into&nbsp;tour&nbsp;order.</tt></dd>
<dd><tt>&nbsp;-f&nbsp;is&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;write&nbsp;into</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;contains&nbsp;the&nbsp;edgelen&nbsp;info&nbsp;(e.g.&nbsp;x,y&nbsp;coordinates),&nbsp;it&nbsp;can&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;-perm&nbsp;contains&nbsp;a&nbsp;permutation&nbsp;of&nbsp;0&nbsp;to&nbsp;ncount&nbsp;-&nbsp;1&nbsp;(so&nbsp;a&nbsp;tour&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;node&nbsp;node&nbsp;node&nbsp;format)</tt></dd>
<a NAME="CCutil_getmaster"></a>
<h2>CCutil_getmaster</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getmaster&nbsp;(char&nbsp;*mastername,&nbsp;int&nbsp;*ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**perm)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;dat&nbsp;information&nbsp;and&nbsp;the&nbsp;permutation&nbsp;from&nbsp;a&nbsp;binary&nbsp;file</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(written&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;CCutil_writemaster).&nbsp;Used&nbsp;by&nbsp;the&nbsp;TSP</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code.</tt></dd>
<dd><tt>&nbsp;-mastername&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;(cannot&nbsp;be&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;returns&nbsp;the&nbsp;edgelen&nbsp;info&nbsp;(e.g.&nbsp;x,y&nbsp;coordinates),&nbsp;or&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;-perm&nbsp;returns&nbsp;a&nbsp;permutation&nbsp;of&nbsp;0&nbsp;to&nbsp;ncount&nbsp;-&nbsp;1&nbsp;(so&nbsp;a&nbsp;tour&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;node&nbsp;node&nbsp;node&nbsp;format)</tt></dd>
<a NAME="CCutil_readmaster"></a>
<h2>CCutil_readmaster</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_readmaster&nbsp;(CC_SFILE&nbsp;*in,&nbsp;int&nbsp;*ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**perm)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;the&nbsp;dat&nbsp;information&nbsp;and&nbsp;the&nbsp;permutation&nbsp;from&nbsp;a&nbsp;binary&nbsp;file</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(written&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;CCutil_writemaster).&nbsp;Used&nbsp;by&nbsp;the&nbsp;TSP</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code.</tt></dd>
<dd><tt>&nbsp;-f&nbsp;is&nbsp;the&nbsp;CC_SFILE&nbsp;to&nbsp;read&nbsp;from</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;returns&nbsp;the&nbsp;edgelen&nbsp;info&nbsp;(e.g.&nbsp;x,y&nbsp;coordinates),&nbsp;or&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;-perm&nbsp;returns&nbsp;a&nbsp;permutation&nbsp;of&nbsp;0&nbsp;to&nbsp;ncount&nbsp;-&nbsp;1&nbsp;(so&nbsp;a&nbsp;tour&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;node&nbsp;node&nbsp;node&nbsp;format)</tt></dd>
<a NAME="CCutil_getnodeweights"></a>
<h2>CCutil_getnodeweights</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getnodeweights&nbsp;(char&nbsp;*weightname,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;weight_limit,&nbsp;double&nbsp;**wcoord,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;list&nbsp;of&nbsp;nonnegative&nbsp;nodesweights&nbsp;(they&nbsp;will&nbsp;be&nbsp;translated</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;the&nbsp;weightname&nbsp;file&nbsp;has&nbsp;negative&nbsp;entries).&nbsp;If&nbsp;weightname</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;NULL&nbsp;then&nbsp;random&nbsp;entries&nbsp;(from&nbsp;0&nbsp;to&nbsp;ncount&nbsp;-&nbsp;1&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generated.</tt></dd>
<dd><tt>&nbsp;-weightname&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;a&nbsp;file&nbsp;containing&nbsp;nodeweights.&nbsp;It&nbsp;will</tt></dd>
<dd><tt>&nbsp;&nbsp;only&nbsp;be&nbsp;read&nbsp;if&nbsp;inusenodeweights&nbsp;is&nbsp;1.&nbsp;If&nbsp;NULL,&nbsp;random&nbsp;entries</tt></dd>
<dd><tt>&nbsp;&nbsp;will&nbsp;be&nbsp;generated&nbsp;(between&nbsp;0&nbsp;and&nbsp;weight_limit&nbsp;-&nbsp;1)</tt></dd>
<dd><tt>&nbsp;-wcoord&nbsp;will&nbsp;contain&nbsp;the&nbsp;nonnegative&nbsp;node&nbsp;weights&nbsp;(it&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;here&nbsp;in&nbsp;CCutil_getnodeweights)</tt></dd>
<a NAME="CCutil_gettsplib"></a>
<h2>CCutil_gettsplib</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_gettsplib(char&nbsp;*datname,&nbsp;int&nbsp;*ncount,&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;an&nbsp;xxx.tsp&nbsp;TSPLIB&nbsp;file,&nbsp;and&nbsp;returns&nbsp;the&nbsp;dat&nbsp;structure&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generate&nbsp;edge&nbsp;lengths.</tt></dd>
<dd><tt>&nbsp;-datname&nbsp;should&nbsp;be&nbsp;the&nbsp;name&nbsp;of&nbsp;a&nbsp;TSPLIB&nbsp;xxx.tsp&nbsp;file.</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes.</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;returns&nbsp;the&nbsp;data.</tt></dd>
<a NAME="CCutil_writetsplib"></a>
<h2>CCutil_writetsplib</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writetsplib&nbsp;(const&nbsp;char&nbsp;*fname,&nbsp;int&nbsp;ncount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;a&nbsp;TSPLIB&nbsp;file&nbsp;for&nbsp;the&nbsp;instance&nbsp;specified&nbsp;by&nbsp;dat.</tt></dd>
<a NAME="CCutil_getedgelist"></a>
<h2>CCutil_getedgelist</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getedgelist&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*fname,&nbsp;int&nbsp;*ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen,&nbsp;int&nbsp;binary_in)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;an&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-fname&nbsp;name&nbsp;of&nbsp;the&nbsp;file</tt></dd>
<dd><tt>&nbsp;-ecount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;edges</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;returns&nbsp;the&nbsp;edges&nbsp;in&nbsp;end1&nbsp;end2&nbsp;format&nbsp;(it&nbsp;will&nbsp;be&nbsp;allocated</tt></dd>
<dd><tt>&nbsp;&nbsp;by&nbsp;CCutil_getedgelist)</tt></dd>
<dd><tt>&nbsp;-elen&nbsp;returns&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;edges&nbsp;in&nbsp;len&nbsp;len&nbsp;len&nbsp;format</tt></dd>
<a NAME="CCutil_getedgelist_n"></a>
<h2>CCutil_getedgelist_n</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getedgelist_n&nbsp;(int&nbsp;*ncount,&nbsp;char&nbsp;*fname,&nbsp;int&nbsp;*ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen,&nbsp;int&nbsp;binary_in)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;an&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format.</tt></dd>
<dd><tt>Like&nbsp;CCutil_getedgelist&nbsp;(),&nbsp;but&nbsp;it&nbsp;also&nbsp;returns&nbsp;ncount.</tt></dd>
<a NAME="CCutil_genedgelist"></a>
<h2>CCutil_genedgelist</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genedgelist&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;**elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**elen,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;maxlen,&nbsp;CCrandstate&nbsp;*rstate)</tt></dd>
<dt>Description:</dt>
<dd><tt>GENERATES&nbsp;a&nbsp;random&nbsp;graph&nbsp;with&nbsp;ncount&nbsp;nodes&nbsp;and&nbsp;ecount&nbsp;edges,&nbsp;with</tt></dd>
<dd><tt>&nbsp;with&nbsp;edgelengths&nbsp;either&nbsp;determined&nbsp;by&nbsp;dat&nbsp;or&nbsp;random&nbsp;between&nbsp;0&nbsp;and</tt></dd>
<dd><tt>&nbsp;maxlen-1.</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;specifies&nbsp;the&nbsp;function&nbsp;for&nbsp;computing&nbsp;the&nbsp;edge&nbsp;lengths&nbsp;(it&nbsp;can</tt></dd>
<dd><tt>&nbsp;&nbsp;be&nbsp;NULL.</tt></dd>
<dd><tt>&nbsp;-maxlen&nbsp;gives&nbsp;the&nbsp;range&nbsp;for&nbsp;random&nbsp;edge&nbsp;lengths&nbsp;(it&nbsp;is&nbsp;used&nbsp;if&nbsp;dat</tt></dd>
<dd><tt>&nbsp;&nbsp;is&nbsp;NULL.</tt></dd>
<a NAME="CCutil_getcycle_edgelist"></a>
<h2>CCutil_getcycle_edgelist</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getcycle_edgelist&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*cyclename,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*outcycle,&nbsp;int&nbsp;binary_in)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;a&nbsp;cycle&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format,&nbsp;and&nbsp;returns&nbsp;the&nbsp;cycle&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;node&nbsp;format&nbsp;in&nbsp;the&nbsp;array&nbsp;outcycle.</tt></dd>
<dd><tt>&nbsp;-outcycle&nbsp;should&nbsp;be&nbsp;allocated&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine&nbsp;(and&nbsp;should</tt></dd>
<dd><tt>&nbsp;&nbsp;be&nbsp;at&nbsp;least&nbsp;ncount&nbsp;long)</tt></dd>
<a NAME="CCutil_getcycle"></a>
<h2>CCutil_getcycle</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getcycle&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*cyclename,&nbsp;int&nbsp;*outcycle,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;binary_in)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;a&nbsp;cycle&nbsp;in&nbsp;node&nbsp;node&nbsp;format,&nbsp;and&nbsp;returns&nbsp;the&nbsp;cycle&nbsp;in&nbsp;node</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;format&nbsp;in&nbsp;the&nbsp;array&nbsp;outcycle.</tt></dd>
<dd><tt>&nbsp;-outcycle&nbsp;should&nbsp;be&nbsp;allocated&nbsp;by&nbsp;the&nbsp;calling&nbsp;routine</tt></dd>
<a NAME="CCutil_cycle_len"></a>
<h2>CCutil_cycle_len</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_cycle_len&nbsp;(int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*cycle,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*len)</tt></dd>
<dt>Description:</dt>
<dd><tt>COMPUTES&nbsp;the&nbsp;length&nbsp;of&nbsp;a&nbsp;cycle&nbsp;(in&nbsp;permutation&nbsp;format).</tt></dd>
<a NAME="CCutil_getedges_double"></a>
<h2>CCutil_getedges_double</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_getedges_double&nbsp;(int&nbsp;*ncount,&nbsp;char&nbsp;*fname,&nbsp;int&nbsp;*ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**elist,&nbsp;double&nbsp;**elen,&nbsp;int&nbsp;binary_in)</tt></dd>
<dt>Description:</dt>
<dd><tt>READS&nbsp;the&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format,&nbsp;where&nbsp;the&nbsp;length</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;double&nbsp;(used&nbsp;for&nbsp;x-vectors)</tt></dd>
<dd><tt>&nbsp;-returns&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-fname&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;to&nbsp;read.</tt></dd>
<dd><tt>&nbsp;-ecount&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;returns&nbsp;the&nbsp;list&nbsp;of&nbsp;edges&nbsp;in&nbsp;end1&nbsp;end2&nbsp;format&nbsp;(it&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;&nbsp;allocated&nbsp;by&nbsp;CCutil_getedges_double).</tt></dd>
<dd><tt>&nbsp;-elen&nbsp;returns&nbsp;the&nbsp;lengths&nbsp;of&nbsp;the&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;-binary_in&nbsp;indicates&nbsp;whether&nbsp;the&nbsp;file&nbsp;should&nbsp;be&nbsp;read&nbsp;in&nbsp;binary</tt></dd>
<dd><tt>&nbsp;&nbsp;or&nbsp;in&nbsp;ascii&nbsp;(1&nbsp;is&nbsp;binary,&nbsp;0&nbsp;is&nbsp;ascii)</tt></dd>
<a NAME="CCutil_writeedges"></a>
<h2>CCutil_writeedges</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writeedges&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*outedgename,&nbsp;int&nbsp;ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elist,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;binary_out)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-outedgename&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;to&nbsp;write&nbsp;to.</tt></dd>
<dd><tt>&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;is&nbsp;the&nbsp;list&nbsp;of&nbsp;edges&nbsp;in&nbsp;end1&nbsp;end2&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;contains&nbsp;the&nbsp;data&nbsp;to&nbsp;compute&nbsp;edgelengths.</tt></dd>
<dd><tt>&nbsp;-binary_in&nbsp;indicates&nbsp;whether&nbsp;the&nbsp;file&nbsp;should&nbsp;be&nbsp;written&nbsp;in&nbsp;binary</tt></dd>
<dd><tt>&nbsp;&nbsp;or&nbsp;in&nbsp;ascii&nbsp;(1&nbsp;is&nbsp;binary,&nbsp;0&nbsp;is&nbsp;ascii)</tt></dd>
<a NAME="CCutil_writecycle_edgelist"></a>
<h2>CCutil_writecycle_edgelist</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writecycle_edgelist&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*outedgename,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*cycle,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;binary_out)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;cycle&nbsp;in&nbsp;edgelist&nbsp;format.</tt></dd>
<a NAME="CCutil_writecycle"></a>
<h2>CCutil_writecycle</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writecycle&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*outcyclename,&nbsp;int&nbsp;*cycle,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;binary_out)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;cycle&nbsp;in&nbsp;node&nbsp;node&nbsp;node&nbsp;format.</tt></dd>
<a NAME="CCutil_writeedges_int"></a>
<h2>CCutil_writeedges_int</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writeedges_int&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*outedgename,&nbsp;int&nbsp;ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elist,&nbsp;int&nbsp;*elen,&nbsp;int&nbsp;binary_out)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format.</tt></dd>
<dd><tt>Like&nbsp;CCutil_writeedges,&nbsp;but&nbsp;lengths&nbsp;are&nbsp;specified&nbsp;in&nbsp;elen.</tt></dd>
<a NAME="CCutil_writeedges_double"></a>
<h2>CCutil_writeedges_double</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_writeedges_double&nbsp;(int&nbsp;ncount,&nbsp;char&nbsp;*outedgename,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,&nbsp;double&nbsp;*elen,&nbsp;int&nbsp;binary_out)</tt></dd>
<dt>Description:</dt>
<dd><tt>WRITES&nbsp;the&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;length&nbsp;format,&nbsp;where&nbsp;the&nbsp;length</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;double&nbsp;(used&nbsp;for&nbsp;x-vectors)</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes</tt></dd>
<dd><tt>&nbsp;-outedgename&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;to&nbsp;write&nbsp;to.</tt></dd>
<dd><tt>&nbsp;-ecount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;is&nbsp;the&nbsp;list&nbsp;of&nbsp;edges&nbsp;in&nbsp;end1&nbsp;end2&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-elen&nbsp;are&nbsp;the&nbsp;lengths&nbsp;of&nbsp;the&nbsp;edges.</tt></dd>
<dd><tt>&nbsp;-binary_out&nbsp;indicates&nbsp;whether&nbsp;the&nbsp;file&nbsp;should&nbsp;be&nbsp;written&nbsp;in&nbsp;binary</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;in&nbsp;ascii&nbsp;(1&nbsp;is&nbsp;binary,&nbsp;0&nbsp;is&nbsp;ascii)</tt></dd>
<a NAME="CCutil_datagroup_perm"></a>
<h2>CCutil_datagroup_perm</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_datagroup_perm&nbsp;(int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*perm)</tt></dd>
<dt>Description:</dt>
<dd><tt>reorders&nbsp;the&nbsp;nodes&nbsp;to&nbsp;match&nbsp;the&nbsp;order&nbsp;given&nbsp;in&nbsp;perm.</tt></dd>
<a NAME="CCutil_copy_datagroup"></a>
<h2>CCutil_copy_datagroup</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_copy_datagroup&nbsp;(int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*indat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;*outdat)</tt></dd>
<dt>Description:</dt>
<dd><tt>COPIES&nbsp;indat&nbsp;to&nbsp;outdat.</tt></dd>
<a NAME="CCutil_tri2dat"></a>
<h2>CCutil_tri2dat</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_tri2dat&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;*elen,&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;convert&nbsp;an&nbsp;upper&nbsp;triangular&nbsp;matrix&nbsp;of&nbsp;edge&nbsp;lengths&nbsp;to&nbsp;a&nbsp;CCdatagroup</tt></dd>
<a NAME="CCutil_graph2dat_matrix"></a>
<h2>CCutil_graph2dat_matrix</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_graph2dat_matrix&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elen,&nbsp;int&nbsp;defaultlen,&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;convert&nbsp;a&nbsp;matrix&nbsp;of&nbsp;edge&nbsp;lengths&nbsp;to&nbsp;a&nbsp;CCdatagroup</tt></dd>
<a NAME="CCutil_graph2dat_sparse"></a>
<h2>CCutil_graph2dat_sparse</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_graph2dat_sparse&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;ecount,&nbsp;int&nbsp;*elist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*elen,&nbsp;int&nbsp;defaultlen,&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>BUILDS&nbsp;a&nbsp;datagroup&nbsp;from&nbsp;the&nbsp;edge&nbsp;list&nbsp;using&nbsp;the&nbsp;CC_SPARSE&nbsp;norm.</tt></dd>
<dd><tt>&nbsp;-dat&nbsp;will&nbsp;be&nbsp;filled&nbsp;in&nbsp;by&nbsp;the&nbsp;function.</tt></dd>
<dd><tt>&nbsp;-defaultlen&nbsp;gives&nbsp;the&nbsp;value&nbsp;for&nbsp;the&nbsp;non-edges&nbsp;(if&nbsp;it&nbsp;is&nbsp;<=&nbsp;0,&nbsp;then</tt></dd>
<dd><tt>&nbsp;&nbsp;a&nbsp;default&nbsp;value&nbsp;of&nbsp;(max_edgelen&nbsp;+&nbsp;1)&nbsp;*&nbsp;nnodes&nbsp;if&nbsp;fiven).</tt></dd>
<a NAME="CCutil_get_sparse_dat_edges"></a>
<h2>CCutil_get_sparse_dat_edges</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_get_sparse_dat_edges&nbsp;(int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*ecount,&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen)</tt></dd>
<dt>Description:</dt>
<dd><tt>GRABS&nbsp;the&nbsp;enitre&nbsp;set&nbsp;of&nbsp;edges&nbsp;in&nbsp;a&nbsp;CC_SPARSE&nbsp;datagroup.&nbsp;&nbsp;It&nbsp;returns</tt></dd>
<dd><tt>&nbsp;&nbsp;an&nbsp;error&nbsp;if&nbsp;the&nbsp;datagroup&nbsp;norm&nbsp;is&nbsp;not&nbsp;CC_SPARSE.</tt></dd>
<a NAME="CCutil_sparse_strip_edges"></a>
<h2>CCutil_sparse_strip_edges</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sparse_strip_edges&nbsp;(CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;in_ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*in_elist,&nbsp;int&nbsp;*in_elen,&nbsp;int&nbsp;*ecount,&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen)</tt></dd>
<dt>Description:</dt>
<dd><tt>REMOVES&nbsp;the&nbsp;artifical&nbsp;edges&nbsp;from&nbsp;in_elist.</tt></dd>
<dd><tt>&nbsp;-ecount,&nbsp;elist,&nbsp;and&nbsp;elen&nbsp;return&nbsp;the&nbsp;stripped&nbsp;edgelist.</tt></dd>
<a NAME="CCutil_sparse_real_tour"></a>
<h2>CCutil_sparse_real_tour</h2>
<dt>File:</dt>
<dd><tt>UTIL/getdata.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_sparse_real_tour&nbsp;(int&nbsp;ncount,&nbsp;CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*cyc,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*yesno)</tt></dd>
<dt>Description:</dt>
<dd><tt>CHECKS&nbsp;whether&nbsp;each&nbsp;edge&nbsp;of&nbsp;cyc&nbsp;is&nbsp;in&nbsp;the&nbsp;CC_SPARSE&nbsp;datagroup.</tt></dd>
<dd><tt>&nbsp;-cyc&nbsp;gives&nbsp;a&nbsp;tour&nbsp;in&nbsp;node&nbsp;node&nbsp;node&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-yesno&nbsp;will&nbsp;be&nbsp;set&nbsp;to&nbsp;1&nbsp;if&nbsp;it&nbsp;is&nbsp;a&nbsp;tour,&nbsp;and&nbsp;0&nbsp;otherwise.</tt></dd>
<a NAME="CCutil_genhash_init"></a>
<h2>CCutil_genhash_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_init&nbsp;(CCgenhash&nbsp;*h,&nbsp;int&nbsp;size,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*hcmp)&nbsp;(void&nbsp;*key1,&nbsp;void&nbsp;*key2,&nbsp;void&nbsp;*u_data),</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;(*hfunc)&nbsp;(void&nbsp;*key,&nbsp;void&nbsp;*u_data),</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*u_data,&nbsp;double&nbsp;maxdensity,&nbsp;double&nbsp;lowdensity)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;CCgenhash&nbsp;structure&nbsp;to&nbsp;be</tt></dd>
<dd><tt>&nbsp;initialized)</tt></dd>
<dd><tt>-int&nbsp;size&nbsp;(the&nbsp;initial&nbsp;size&nbsp;of&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-int&nbsp;(*hcmp)&nbsp;(void&nbsp;*key1,&nbsp;void&nbsp;*key2,&nbsp;void&nbsp;*u_data)&nbsp;(a&nbsp;pointer&nbsp;to</tt></dd>
<dd><tt>&nbsp;a&nbsp;function&nbsp;which&nbsp;returns&nbsp;0&nbsp;if&nbsp;key1&nbsp;==&nbsp;key2,&nbsp;nonzero&nbsp;otherwise.</tt></dd>
<dd><tt>&nbsp;u_data&nbsp;will&nbsp;be&nbsp;the&nbsp;u_data&nbsp;passed&nbsp;to&nbsp;CCutil_genhash_init)</tt></dd>
<dd><tt>-unsigned&nbsp;int&nbsp;(*hfunc)&nbsp;(void&nbsp;*key,&nbsp;void&nbsp;*u_data)&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;a</tt></dd>
<dd><tt>&nbsp;function&nbsp;which&nbsp;computes&nbsp;a&nbsp;hash&nbsp;function&nbsp;of&nbsp;key.&nbsp;&nbsp;u_data&nbsp;will&nbsp;be</tt></dd>
<dd><tt>&nbsp;the&nbsp;u_data&nbsp;passed&nbsp;to&nbsp;CCutil_genhash_init)</tt></dd>
<dd><tt>-void&nbsp;*u_data&nbsp;(a&nbsp;pointer&nbsp;which&nbsp;will&nbsp;be&nbsp;passed&nbsp;into&nbsp;hcmp&nbsp;and&nbsp;hfunc)</tt></dd>
<dd><tt>-double&nbsp;maxdensity&nbsp;(the&nbsp;maximum&nbsp;density&nbsp;(#&nbsp;elems&nbsp;/&nbsp;size)&nbsp;for&nbsp;the</tt></dd>
<dd><tt>&nbsp;hash&nbsp;table.&nbsp;&nbsp;When&nbsp;this&nbsp;density&nbsp;is&nbsp;reached&nbsp;the&nbsp;hash&nbsp;table&nbsp;is</tt></dd>
<dd><tt>&nbsp;expanded.&nbsp;&nbsp;0.0&nbsp;means&nbsp;never&nbsp;expand&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-double&nbsp;lowdensity&nbsp;(the&nbsp;density&nbsp;of&nbsp;a&nbsp;hash&nbsp;table&nbsp;immediately&nbsp;after</tt></dd>
<dd><tt>&nbsp;expansion)</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;0&nbsp;for&nbsp;success,&nbsp;-1&nbsp;if&nbsp;out&nbsp;of&nbsp;memory.</tt></dd>
<a NAME="CCutil_genhash_free"></a>
<h2>CCutil_genhash_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_genhash_free&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;(*freefunc)(void&nbsp;*k,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*d,&nbsp;void&nbsp;*u_data))</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;(*freefunc)(void&nbsp;*key,&nbsp;void&nbsp;*data,&nbsp;void&nbsp;*u_data)&nbsp;(a&nbsp;pointer</tt></dd>
<dd><tt>&nbsp;to&nbsp;a&nbsp;function&nbsp;to&nbsp;be&nbsp;called&nbsp;for&nbsp;each&nbsp;(key,&nbsp;data)&nbsp;pair&nbsp;in&nbsp;the</tt></dd>
<dd><tt>&nbsp;hashtable,&nbsp;or&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;deletes&nbsp;all&nbsp;entries&nbsp;in&nbsp;h,&nbsp;and&nbsp;frees&nbsp;the&nbsp;space&nbsp;for&nbsp;h.</tt></dd>
<a NAME="CCutil_genhash_u_data"></a>
<h2>CCutil_genhash_u_data</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_genhash_u_data&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*u_data)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*u_data&nbsp;(a&nbsp;new&nbsp;value&nbsp;for&nbsp;u_data)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;changes&nbsp;the&nbsp;u_data&nbsp;stored&nbsp;with&nbsp;the&nbsp;hash&nbsp;table,&nbsp;and</tt></dd>
<dd><tt>&nbsp;passed&nbsp;to&nbsp;hcomp&nbsp;and&nbsp;hfunc)</tt></dd>
<a NAME="CCutil_genhash_insert"></a>
<h2>CCutil_genhash_insert</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_insert&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*key,&nbsp;void&nbsp;*data)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;key&nbsp;data&nbsp;for&nbsp;this&nbsp;entry)</tt></dd>
<dd><tt>-void&nbsp;*data&nbsp;(the&nbsp;data&nbsp;to&nbsp;be&nbsp;stored)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;h[key]&nbsp;=&nbsp;data</tt></dd>
<dd><tt>&nbsp;COMMENT:&nbsp;if&nbsp;h[key]&nbsp;already&nbsp;has&nbsp;a&nbsp;value,&nbsp;this&nbsp;acts&nbsp;like&nbsp;a&nbsp;stack</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCutil_genhash_delete(key)&nbsp;will&nbsp;reveal&nbsp;the&nbsp;old&nbsp;value.</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;0&nbsp;for&nbsp;success,&nbsp;-1&nbsp;if&nbsp;out&nbsp;of&nbsp;memory.</tt></dd>
<a NAME="CCutil_genhash_replace"></a>
<h2>CCutil_genhash_replace</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_replace&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*key,&nbsp;void&nbsp;*data)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;key&nbsp;data&nbsp;for&nbsp;this&nbsp;entry)</tt></dd>
<dd><tt>-void&nbsp;*data&nbsp;(the&nbsp;data&nbsp;to&nbsp;be&nbsp;stored)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;h[key]&nbsp;=&nbsp;data</tt></dd>
<dd><tt>&nbsp;COMMENT:&nbsp;if&nbsp;h[key]&nbsp;already&nbsp;has&nbsp;a&nbsp;value,&nbsp;this&nbsp;replaces&nbsp;that</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;0&nbsp;for&nbsp;success,&nbsp;-1&nbsp;if&nbsp;out&nbsp;of&nbsp;memory.</tt></dd>
<a NAME="CCutil_genhash_delete"></a>
<h2>CCutil_genhash_delete</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_delete&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*key)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;key&nbsp;data&nbsp;for&nbsp;this&nbsp;entry)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;h[key]&nbsp;=&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;0&nbsp;for&nbsp;success,&nbsp;-1&nbsp;if&nbsp;h[key]&nbsp;was&nbsp;already&nbsp;NULL</tt></dd>
<a NAME="CCutil_genhash_lookup"></a>
<h2>CCutil_genhash_lookup</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_genhash_lookup&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*key)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;key&nbsp;data&nbsp;for&nbsp;this&nbsp;entry)</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;h[key],&nbsp;or&nbsp;NULL&nbsp;if&nbsp;h[key]&nbsp;not&nbsp;defined</tt></dd>
<a NAME="CCutil_genhash_hash"></a>
<h2>CCutil_genhash_hash</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>unsigned&nbsp;int&nbsp;CCutil_genhash_hash&nbsp;(CCgenhash&nbsp;*h,&nbsp;void&nbsp;*key)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-void&nbsp;*key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;key&nbsp;data)</tt></dd>
<dd><tt>&nbsp;RETURNS&nbsp;the&nbsp;hash&nbsp;function&nbsp;of&nbsp;key&nbsp;(ie,&nbsp;h->hfunc(key))</tt></dd>
<a NAME="CCutil_genhash_insert_h"></a>
<h2>CCutil_genhash_insert_h</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_insert_h&nbsp;(CCgenhash&nbsp;*h,&nbsp;unsigned&nbsp;int&nbsp;hashval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key,&nbsp;void&nbsp;*data)</tt></dd>
<dt>Description:</dt>
<dd><tt>alternate&nbsp;version&nbsp;of&nbsp;CCutil_genhash_insert,&nbsp;which&nbsp;takes&nbsp;an</tt></dd>
<dd><tt>additional&nbsp;argument,&nbsp;hashval,&nbsp;which&nbsp;should&nbsp;be&nbsp;equal&nbsp;to</tt></dd>
<dd><tt>CCutil_genhash_hash(key).&nbsp;&nbsp;This&nbsp;provides&nbsp;a&nbsp;method&nbsp;to&nbsp;avoid</tt></dd>
<dd><tt>recomputing&nbsp;CCutil_genhash_hash&nbsp;over&nbsp;multiple&nbsp;calls&nbsp;with&nbsp;the&nbsp;same</tt></dd>
<dd><tt>key</tt></dd>
<a NAME="CCutil_genhash_replace_h"></a>
<h2>CCutil_genhash_replace_h</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_replace_h&nbsp;(CCgenhash&nbsp;*h,&nbsp;unsigned&nbsp;int&nbsp;hashval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key,&nbsp;void&nbsp;*data)</tt></dd>
<dt>Description:</dt>
<dd><tt>alternate&nbsp;version&nbsp;of&nbsp;CCutil_genhash_replace,&nbsp;which&nbsp;takes&nbsp;an</tt></dd>
<dd><tt>additional&nbsp;argument,&nbsp;hashval,&nbsp;which&nbsp;should&nbsp;be&nbsp;equal&nbsp;to</tt></dd>
<dd><tt>CCutil_genhash_hash(key).&nbsp;&nbsp;This&nbsp;provides&nbsp;a&nbsp;method&nbsp;to&nbsp;avoid</tt></dd>
<dd><tt>recomputing&nbsp;CCutil_genhash_hash&nbsp;over&nbsp;multiple&nbsp;calls&nbsp;with&nbsp;the&nbsp;same</tt></dd>
<dd><tt>key.</tt></dd>
<a NAME="CCutil_genhash_delete_h"></a>
<h2>CCutil_genhash_delete_h</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_delete_h&nbsp;(CCgenhash&nbsp;*h,&nbsp;unsigned&nbsp;int&nbsp;hashval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key)</tt></dd>
<dt>Description:</dt>
<dd><tt>alternate&nbsp;version&nbsp;of&nbsp;CCutil_genhash_delete,&nbsp;which&nbsp;takes&nbsp;an</tt></dd>
<dd><tt>additional&nbsp;argument,&nbsp;hashval,&nbsp;which&nbsp;should&nbsp;be&nbsp;equal&nbsp;to</tt></dd>
<dd><tt>CCutil_genhash_hash(key).&nbsp;&nbsp;This&nbsp;provides&nbsp;a&nbsp;method&nbsp;to&nbsp;avoid</tt></dd>
<dd><tt>recomputing&nbsp;CCutil_genhash_hash&nbsp;over&nbsp;multiple&nbsp;calls&nbsp;with&nbsp;the&nbsp;same</tt></dd>
<dd><tt>key.</tt></dd>
<a NAME="CCutil_genhash_lookup_h"></a>
<h2>CCutil_genhash_lookup_h</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_genhash_lookup_h&nbsp;(CCgenhash&nbsp;*h,&nbsp;unsigned&nbsp;int&nbsp;hashval,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key)</tt></dd>
<dt>Description:</dt>
<dd><tt>alternate&nbsp;version&nbsp;of&nbsp;CCutil_genhash_lookup,&nbsp;which&nbsp;takes&nbsp;an</tt></dd>
<dd><tt>additional&nbsp;argument,&nbsp;hashval,&nbsp;which&nbsp;should&nbsp;be&nbsp;equal&nbsp;to</tt></dd>
<dd><tt>CCutil_genhash_hash(key).&nbsp;&nbsp;This&nbsp;provides&nbsp;a&nbsp;method&nbsp;to&nbsp;avoid</tt></dd>
<dd><tt>recomputing&nbsp;CCutil_genhash_hash&nbsp;over&nbsp;multiple&nbsp;calls&nbsp;with&nbsp;the&nbsp;same</tt></dd>
<dd><tt>key.</tt></dd>
<a NAME="CCutil_genhash_start"></a>
<h2>CCutil_genhash_start</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_genhash_start&nbsp;(CCgenhash&nbsp;*h,&nbsp;CCgenhash_iter&nbsp;*iter)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-CCgenhash_iter&nbsp;*iter&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;iterator&nbsp;to&nbsp;be</tt></dd>
<dd><tt>&nbsp;initialized)</tt></dd>
<dd><tt>&nbsp;ACTION:&nbsp;initializes&nbsp;iter&nbsp;for&nbsp;iterating&nbsp;over&nbsp;elements&nbsp;of&nbsp;h&nbsp;using</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCutil_genhash_next()</tt></dd>
<a NAME="CCutil_genhash_next"></a>
<h2>CCutil_genhash_next</h2>
<dt>File:</dt>
<dd><tt>UTIL/genhash.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_genhash_next&nbsp;(CCgenhash&nbsp;*h,&nbsp;CCgenhash_iter&nbsp;*iter,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;**key,&nbsp;int&nbsp;*keysize)</tt></dd>
<dt>Description:</dt>
<dd><tt>-CCgenhash&nbsp;*h&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;hash&nbsp;table)</tt></dd>
<dd><tt>-CCgenhash_iter&nbsp;*iter&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;an&nbsp;iterator)</tt></dd>
<dd><tt>-void&nbsp;**key&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;location&nbsp;for&nbsp;the&nbsp;key&nbsp;value)</tt></dd>
<dd><tt>-int&nbsp;*keysize&nbsp;(a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;location&nbsp;for&nbsp;the&nbsp;key&nbsp;size)</tt></dd>
<dd><tt>&nbsp;RETURNS:&nbsp;a&nbsp;next&nbsp;data&nbsp;value&nbsp;from&nbsp;the&nbsp;hash&nbsp;table&nbsp;(corresponding</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;returned&nbsp;key&nbsp;and&nbsp;keysize),&nbsp;or&nbsp;NULL&nbsp;if&nbsp;there</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;no&nbsp;more&nbsp;elements.</tt></dd>
<dd><tt>CCutil_genhash_next&nbsp;can&nbsp;tolerate&nbsp;the&nbsp;deletion&nbsp;of&nbsp;the&nbsp;current</tt></dd>
<dd><tt>(last&nbsp;returned)&nbsp;element&nbsp;and&nbsp;arbitrary&nbsp;lookups&nbsp;and&nbsp;replaces</tt></dd>
<dd><tt>between&nbsp;calls&nbsp;to&nbsp;CCutil_genhash_next.&nbsp;&nbsp;However,&nbsp;deletion&nbsp;of</tt></dd>
<dd><tt>elements&nbsp;other&nbsp;than&nbsp;the&nbsp;current&nbsp;one&nbsp;are&nbsp;not&nbsp;permitted,&nbsp;and</tt></dd>
<dd><tt>insertion&nbsp;a&nbsp;table&nbsp;which&nbsp;could&nbsp;be&nbsp;expanded&nbsp;can&nbsp;result&nbsp;in</tt></dd>
<dd><tt>elements&nbsp;being&nbsp;skipped.</tt></dd>
<a NAME="CCutil_readint"></a>
<h2>CCutil_readint</h2>
<dt>File:</dt>
<dd><tt>UTIL/fastread.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_readint&nbsp;(FILE&nbsp;*f)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;-&nbsp;Returns&nbsp;the&nbsp;next&nbsp;int&nbsp;in&nbsp;the&nbsp;file&nbsp;f.</tt></dd>
<dd><tt>This&nbsp;is&nbsp;much&nbsp;faster&nbsp;that&nbsp;scanf.&nbsp;It&nbsp;is&nbsp;useful&nbsp;for&nbsp;big&nbsp;files&nbsp;and</tt></dd>
<dd><tt>and&nbsp;for&nbsp;profiling.</tt></dd>
<a NAME="CCutil_edge_file_union"></a>
<h2>CCutil_edge_file_union</h2>
<dt>File:</dt>
<dd><tt>UTIL/eunion.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edge_file_union&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;nfiles,&nbsp;char&nbsp;**flist,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*ecount,&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen,&nbsp;int&nbsp;*foundtour,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*besttourlen)</tt></dd>
<dt>Description:</dt>
<dd><tt>MERGES&nbsp;a&nbsp;list&nbsp;of&nbsp;edge&nbsp;sets.</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes.</tt></dd>
<dd><tt>&nbsp;-nfiles&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;files&nbsp;to&nbsp;be&nbsp;read.</tt></dd>
<dd><tt>&nbsp;-flist&nbsp;is&nbsp;the&nbsp;list&nbsp;of&nbsp;the&nbsp;files.</tt></dd>
<dd><tt>&nbsp;-ecount,&nbsp;elist,&nbsp;elen&nbsp;returns&nbsp;the&nbsp;merged&nbsp;edge&nbsp;set.</tt></dd>
<dd><tt>&nbsp;-foundtour&nbsp;will&nbsp;return&nbsp;a&nbsp;1&nbsp;if&nbsp;at&nbsp;least&nbsp;one&nbsp;of&nbsp;the&nbsp;files&nbsp;is&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;edgeset&nbsp;of&nbsp;a&nbsp;tour&nbsp;(it&nbsp;can&nbsp;be&nbsp;NULL).</tt></dd>
<dd><tt>&nbsp;-besttour&nbsp;will&nbsp;return&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;best&nbsp;tour&nbsp;amongst&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;edge&nbsp;sets&nbsp;(it&nbsp;can&nbsp;be&nbsp;NULL)</tt></dd>
<dd><tt>&nbsp;Returns&nbsp;a&nbsp;nonzero&nbsp;value&nbsp;if&nbsp;there&nbsp;was&nbsp;and&nbsp;error.</tt></dd>
<a NAME="CCutil_edge_to_cycle"></a>
<h2>CCutil_edge_to_cycle</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edge_to_cycle&nbsp;(int&nbsp;ncount,&nbsp;int&nbsp;*elist,&nbsp;int&nbsp;*yesno,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*cyc)</tt></dd>
<dt>Description:</dt>
<dd><tt>CONVERTS&nbsp;an&nbsp;edgelist&nbsp;to&nbsp;a&nbsp;cycle.</tt></dd>
<dd><tt>&nbsp;-ncount&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes.</tt></dd>
<dd><tt>&nbsp;-elist&nbsp;is&nbsp;an&nbsp;edgelist&nbsp;in&nbsp;end1&nbsp;end2&nbsp;format.</tt></dd>
<dd><tt>&nbsp;-yesno&nbsp;returns&nbsp;1&nbsp;if&nbsp;elist&nbsp;describes&nbsp;a&nbsp;tour&nbsp;and&nbsp;0&nbsp;otherwise.</tt></dd>
<dd><tt>&nbsp;-cyc&nbsp;returns&nbsp;the&nbsp;cycle&nbsp;in&nbsp;permutation&nbsp;format&nbsp;if&nbsp;it&nbsp;is&nbsp;not&nbsp;NULL</tt></dd>
<dd><tt>&nbsp;&nbsp;(if&nbsp;cyc&nbsp;is&nbsp;not&nbsp;NULL,&nbsp;then&nbsp;it&nbsp;should&nbsp;point&nbsp;to&nbsp;an&nbsp;array&nbsp;of</tt></dd>
<dd><tt>&nbsp;&nbsp;length&nbsp;at&nbsp;least&nbsp;ncount).</tt></dd>
<dd><tt>&nbsp;Returns&nbsp;a&nbsp;nonzero&nbsp;value&nbsp;if&nbsp;there&nbsp;was&nbsp;an&nbsp;error.</tt></dd>
<a NAME="CCelist_init"></a>
<h2>CCelist_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelist_init&nbsp;(CCelist&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCelist</tt></dd>
<a NAME="CCelistl_init"></a>
<h2>CCelistl_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistl_init&nbsp;(CCelistl&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCelistl</tt></dd>
<a NAME="CCelistw_init"></a>
<h2>CCelistw_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistw_init&nbsp;(CCelistw&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCelistw</tt></dd>
<a NAME="CCelistlw_init"></a>
<h2>CCelistlw_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistlw_init&nbsp;(CCelistlw&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCelistlw</tt></dd>
<a NAME="CCelist_free"></a>
<h2>CCelist_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelist_free&nbsp;(CCelist&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;free&nbsp;a&nbsp;CCelist</tt></dd>
<a NAME="CCelistl_free"></a>
<h2>CCelistl_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistl_free&nbsp;(CCelistl&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;free&nbsp;a&nbsp;CCelistl</tt></dd>
<a NAME="CCelistw_free"></a>
<h2>CCelistw_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistw_free&nbsp;(CCelistw&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;free&nbsp;a&nbsp;CCelistw</tt></dd>
<a NAME="CCelistlw_free"></a>
<h2>CCelistlw_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCelistlw_free&nbsp;(CCelistlw&nbsp;*elist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;free&nbsp;a&nbsp;CCelistlw</tt></dd>
<a NAME="CCelist_alloc"></a>
<h2>CCelist_alloc</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCelist_alloc&nbsp;(CCelist&nbsp;*elist,&nbsp;int&nbsp;ecount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;allocate&nbsp;space&nbsp;for&nbsp;a&nbsp;CCelist</tt></dd>
<a NAME="CCelistl_alloc"></a>
<h2>CCelistl_alloc</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCelistl_alloc&nbsp;(CCelistl&nbsp;*elist,&nbsp;int&nbsp;ecount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;allocate&nbsp;space&nbsp;for&nbsp;a&nbsp;CCelistl</tt></dd>
<a NAME="CCelistw_alloc"></a>
<h2>CCelistw_alloc</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCelistw_alloc&nbsp;(CCelistw&nbsp;*elist,&nbsp;int&nbsp;ecount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;allocate&nbsp;space&nbsp;for&nbsp;a&nbsp;CCelistw</tt></dd>
<a NAME="CCelistlw_alloc"></a>
<h2>CCelistlw_alloc</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgeutil.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCelistlw_alloc&nbsp;(CCelistlw&nbsp;*elist,&nbsp;int&nbsp;ecount)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;CCelistlw</tt></dd>
<a NAME="CCutil_dat_setnorm"></a>
<h2>CCutil_dat_setnorm</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dat_setnorm&nbsp;(CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;norm)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supported&nbsp;norms&nbsp;(with&nbsp;defs&nbsp;in&nbsp;edgelen.h)&nbsp;are:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_MAXNORM&nbsp;&nbsp;-&nbsp;&nbsp;the&nbsp;L-infinity&nbsp;norm</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_EUCLIDEAN_CEIL&nbsp;-&nbsp;the&nbsp;norm&nbsp;for&nbsp;the&nbsp;plaXXXX&nbsp;problems</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_EUCLIDEAN&nbsp;-&nbsp;rounded&nbsp;L-2&nbsp;norm</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_EUCLIDEAN_3D&nbsp;-&nbsp;rounded&nbsp;L-2&nbsp;norm&nbsp;in&nbsp;3&nbsp;space</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_USER&nbsp;-&nbsp;a&nbsp;norm&nbsp;specified&nbsp;by&nbsp;the&nbsp;user</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_GEOGRAPHIC&nbsp;-&nbsp;distances&nbsp;on&nbsp;a&nbsp;sphere&nbsp;(Groetshel&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Holland)</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_ATT&nbsp;-&nbsp;pseudo-Euclidean&nbsp;norm&nbsp;for&nbsp;att532</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_MATRIXNORM&nbsp;-&nbsp;complete&nbsp;graph&nbsp;(lower&nbsp;+&nbsp;diagonal&nbsp;matrix)</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_DSJRANDNORM&nbsp;-&nbsp;random&nbsp;edgelengths</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_CRYSTAL&nbsp;-&nbsp;Bland-Shallcross&nbsp;xray&nbsp;norm</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;The&nbsp;coordinates&nbsp;generated&nbsp;for&nbsp;CC_CRYSTAL&nbsp;problems</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(in&nbsp;CCutil_getdata.c)&nbsp;have&nbsp;been&nbsp;diveded&nbsp;by&nbsp;the&nbsp;motor</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speeds&nbsp;(this&nbsp;makes&nbsp;the&nbsp;edgelen&nbsp;function&nbsp;faster)&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scaled&nbsp;by&nbsp;CRYSTAL_SCALE&nbsp;(currently&nbsp;10000)&nbsp;and&nbsp;rounded&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;nearest&nbsp;integer&nbsp;(this&nbsp;lets&nbsp;the&nbsp;edgelen&nbsp;function</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;produce&nbsp;integer&nbsp;lengths&nbsp;without&nbsp;further&nbsp;rounding).&nbsp;The</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;is&nbsp;a&nbsp;closer&nbsp;approximation&nbsp;to&nbsp;the&nbsp;Bland&nbsp;-</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shallcross&nbsp;floating&nbsp;point&nbsp;length&nbsp;function&nbsp;than&nbsp;that</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;given&nbsp;in&nbsp;TSPLIB_1.2.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_SPARSE&nbsp;-&nbsp;a&nbsp;sparse&nbsp;graph</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC_RHMAPx&nbsp;-&nbsp;where&nbsp;x&nbsp;=&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;one&nbsp;of&nbsp;5&nbsp;RH&nbsp;mapping</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;norms.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;CCUTIL_EDGELEN_FUNCTIONPTR&nbsp;has&nbsp;been&nbsp;defined&nbsp;in&nbsp;util.h,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;CCutil_dat_edgelen&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;function&nbsp;instead&nbsp;of</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;function.&nbsp;&nbsp;This&nbsp;saves&nbsp;a&nbsp;function&nbsp;call&nbsp;and&nbsp;results&nbsp;in</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;improved&nbsp;performance&nbsp;on&nbsp;some&nbsp;machines&nbsp;for&nbsp;edgelen-intensive</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routines&nbsp;like&nbsp;linkern.&nbsp;&nbsp;The&nbsp;function&nbsp;pointer&nbsp;is&nbsp;set&nbsp;by</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCutil_dat_setnorm.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMPORTANT:&nbsp;This&nbsp;means&nbsp;that&nbsp;if&nbsp;CCUTIL_EDGELEN_FUNCTIONPTR&nbsp;is&nbsp;set</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;you&nbsp;have&nbsp;more&nbsp;than&nbsp;one&nbsp;CCdatagroup,&nbsp;you&nbsp;must&nbsp;call</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCutil_dat_setnorm&nbsp;whenever&nbsp;you&nbsp;switch&nbsp;from&nbsp;using&nbsp;one</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCdatagroup&nbsp;to&nbsp;the&nbsp;other.&nbsp;&nbsp;IF&nbsp;YOU&nbsp;DON'T&nbsp;DO&nbsp;THIS,&nbsp;EDGELEN&nbsp;WILL</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN&nbsp;INCORRECT&nbsp;RESULTS.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCUTIL_EDGELEN_FUNCTIONPTR&nbsp;should&nbsp;only&nbsp;be&nbsp;set&nbsp;with&nbsp;extreme</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caution.</tt></dd>
<dd><tt></tt></dd>
<dd><tt>To&nbsp;define&nbsp;a&nbsp;user&nbsp;norm,&nbsp;you&nbsp;must&nbsp;perform&nbsp;the&nbsp;following&nbsp;steps:</tt></dd>
<dd><tt>1.&nbsp;&nbsp;In&nbsp;util.h,&nbsp;define&nbsp;the&nbsp;struct&nbsp;CCdata_user&nbsp;to&nbsp;contain&nbsp;the&nbsp;data</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;necessary&nbsp;for&nbsp;the&nbsp;computation&nbsp;of&nbsp;edge&nbsp;lengths.</tt></dd>
<dd><tt>2.&nbsp;&nbsp;In&nbsp;edgelen.c,&nbsp;write&nbsp;the&nbsp;init_userdat&nbsp;and&nbsp;free_userdat&nbsp;functions</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;initialize&nbsp;and&nbsp;free&nbsp;a&nbsp;CCdata_user&nbsp;structure.</tt></dd>
<dd><tt>3.&nbsp;&nbsp;In&nbsp;edgelen.c,&nbsp;write&nbsp;the&nbsp;user_edgelen&nbsp;function&nbsp;which</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;computes&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;edge&nbsp;for&nbsp;node&nbsp;i&nbsp;to&nbsp;node&nbsp;j,&nbsp;using&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;userdat&nbsp;field&nbsp;of&nbsp;the&nbsp;CCdatagroup&nbsp;argument&nbsp;(userdat&nbsp;is&nbsp;of&nbsp;type</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;CCdata_user).</tt></dd>
<dd><tt>4.&nbsp;&nbsp;In&nbsp;getdata.c,&nbsp;write&nbsp;the&nbsp;build_user,&nbsp;read_user_text,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;read_user_binary,&nbsp;readmaster_user,&nbsp;and&nbsp;writemaster_user</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;routines.&nbsp;&nbsp;read_user_text&nbsp;reads&nbsp;the&nbsp;data&nbsp;file&nbsp;which&nbsp;provides</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;data&nbsp;for&nbsp;computing&nbsp;the&nbsp;edge&nbsp;lengths.&nbsp;&nbsp;build_user&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;read_user_binary&nbsp;are&nbsp;optional&nbsp;routines&nbsp;which&nbsp;build&nbsp;random</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;datasets&nbsp;and&nbsp;read&nbsp;binary&nbsp;datafiles.&nbsp;&nbsp;writemaster_user&nbsp;writes&nbsp;a</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;binary&nbsp;version&nbsp;of&nbsp;that&nbsp;data&nbsp;to&nbsp;the&nbsp;master&nbsp;file,&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;readmaster_user&nbsp;reads&nbsp;that&nbsp;same&nbsp;data.&nbsp;&nbsp;See&nbsp;the&nbsp;comments&nbsp;before</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;those&nbsp;routines&nbsp;in&nbsp;getdata&nbsp;for&nbsp;more&nbsp;details&nbsp;on&nbsp;what&nbsp;they&nbsp;should</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;do.</tt></dd>
<dd><tt>5.&nbsp;&nbsp;In&nbsp;getdata.c,&nbsp;write&nbsp;permute_user,&nbsp;which&nbsp;permutes&nbsp;the&nbsp;data&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;reflect&nbsp;a&nbsp;permutation&nbsp;of&nbsp;the&nbsp;nodes.</tt></dd>
<a NAME="CCutil_dat_edgelen"></a>
<h2>CCutil_dat_edgelen</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dat_edgelen&nbsp;(int&nbsp;i,&nbsp;int&nbsp;j,&nbsp;CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;compute&nbsp;the&nbsp;length&nbsp;of&nbsp;an&nbsp;edge</tt></dd>
<a NAME="CCutil_dsjrand_init"></a>
<h2>CCutil_dsjrand_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_dsjrand_init&nbsp;(CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;maxdist,&nbsp;int&nbsp;seed)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;the&nbsp;dsjrand&nbsp;norm</tt></dd>
<a NAME="CCutil_dat_getnorm"></a>
<h2>CCutil_dat_getnorm</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_dat_getnorm&nbsp;(CCdatagroup&nbsp;*dat,&nbsp;int&nbsp;*norm)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;get&nbsp;the&nbsp;norm&nbsp;of&nbsp;a&nbsp;CCdatagroup</tt></dd>
<a NAME="CCutil_init_datagroup"></a>
<h2>CCutil_init_datagroup</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_init_datagroup&nbsp;(CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCdatagroup</tt></dd>
<a NAME="CCutil_freedatagroup"></a>
<h2>CCutil_freedatagroup</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgelen.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_freedatagroup&nbsp;(CCdatagroup&nbsp;*dat)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;free&nbsp;a&nbsp;CCdatagroup</tt></dd>
<a NAME="CCutil_dheap_init"></a>
<h2>CCutil_dheap_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dheap_init&nbsp;(CCdheap&nbsp;*h,&nbsp;int&nbsp;k)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-h&nbsp;should&nbsp;point&nbsp;to&nbsp;a&nbsp;CCdheap&nbsp;struct.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;-k&nbsp;the&nbsp;max&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;the&nbsp;dheap.</tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;k-element&nbsp;heap&nbsp;will&nbsp;malloc&nbsp;16k&nbsp;bytes&nbsp;of&nbsp;memory.&nbsp;If&nbsp;memory&nbsp;is</tt></dd>
<dd><tt>tight,&nbsp;using&nbsp;integer&nbsp;keys&nbsp;(instead&nbsp;of&nbsp;doubles),&nbsp;brings&nbsp;it&nbsp;down&nbsp;to</tt></dd>
<dd><tt>12k&nbsp;bytes,&nbsp;and&nbsp;if&nbsp;arbitrary&nbsp;deletions&nbsp;are&nbsp;not&nbsp;required,&nbsp;with&nbsp;a</tt></dd>
<dd><tt>little&nbsp;rewriting,&nbsp;the&nbsp;h->loc&nbsp;field&nbsp;can&nbsp;be&nbsp;eliminated,&nbsp;bring&nbsp;the</tt></dd>
<dd><tt>space&nbsp;down&nbsp;to&nbsp;8k&nbsp;bytes.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;These&nbsp;routines&nbsp;work&nbsp;with&nbsp;indices&nbsp;into&nbsp;the&nbsp;h->key&nbsp;array,&nbsp;so&nbsp;in</tt></dd>
<dd><tt>some&nbsp;cases,&nbsp;you&nbsp;will&nbsp;need&nbsp;to&nbsp;maintain&nbsp;a&nbsp;separate&nbsp;names&nbsp;array&nbsp;to&nbsp;know</tt></dd>
<dd><tt>what&nbsp;element&nbsp;belongs&nbsp;to&nbsp;index&nbsp;i.&nbsp;For&nbsp;an&nbsp;example,&nbsp;see&nbsp;the&nbsp;k_nearest</tt></dd>
<dd><tt>code&nbsp;in&nbsp;kdnear.c.</tt></dd>
<a NAME="CCutil_dheap_free"></a>
<h2>CCutil_dheap_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_dheap_free&nbsp;(CCdheap&nbsp;*h)</tt></dd>
<dt>Description:</dt>
<dd><tt>-frees&nbsp;the&nbsp;spaces&nbsp;allocated&nbsp;by&nbsp;CCutil_dheap_init</tt></dd>
<a NAME="CCutil_dheap_resize"></a>
<h2>CCutil_dheap_resize</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dheap_resize&nbsp;(CCdheap&nbsp;*h,&nbsp;int&nbsp;newsize)</tt></dd>
<dt>Description:</dt>
<dd><tt>-REALLOCs&nbsp;h&nbsp;so&nbsp;it&nbsp;can&nbsp;contain&nbsp;newsize&nbsp;elements.</tt></dd>
<dd><tt>-returns&nbsp;-1&nbsp;if&nbsp;it&nbsp;can't&nbsp;resize&nbsp;the&nbsp;heap.</tt></dd>
<a NAME="CCutil_dheap_findmin"></a>
<h2>CCutil_dheap_findmin</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dheap_findmin&nbsp;(CCdheap&nbsp;*h)</tt></dd>
<dt>Description:</dt>
<dd><tt>-returns&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;element&nbsp;with&nbsp;min&nbsp;value&nbsp;h->key[i]</tt></dd>
<dd><tt>-returns&nbsp;-1&nbsp;if&nbsp;no&nbsp;elements&nbsp;in&nbsp;heap.</tt></dd>
<a NAME="CCutil_dheap_insert"></a>
<h2>CCutil_dheap_insert</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dheap_insert&nbsp;(CCdheap&nbsp;*h,&nbsp;int&nbsp;i)</tt></dd>
<dt>Description:</dt>
<dd><tt>-inserts&nbsp;the&nbsp;element&nbsp;with&nbsp;index&nbsp;i&nbsp;(so&nbsp;its&nbsp;key&nbsp;should&nbsp;be&nbsp;loaded</tt></dd>
<dd><tt>&nbsp;beforehand&nbsp;in&nbsp;h->key[i]).</tt></dd>
<a NAME="CCutil_dheap_delete"></a>
<h2>CCutil_dheap_delete</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_dheap_delete&nbsp;(CCdheap&nbsp;*h,&nbsp;int&nbsp;i)</tt></dd>
<dt>Description:</dt>
<dd><tt>-deletes&nbsp;the&nbsp;element&nbsp;with&nbsp;index&nbsp;i.</tt></dd>
<a NAME="CCutil_dheap_deletemin"></a>
<h2>CCutil_dheap_deletemin</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_dheap_deletemin&nbsp;(CCdheap&nbsp;*h)</tt></dd>
<dt>Description:</dt>
<dd><tt>-returns&nbsp;the&nbsp;min&nbsp;element&nbsp;in&nbsp;the&nbsp;heap,&nbsp;and&nbsp;deletes&nbsp;the&nbsp;min&nbsp;element</tt></dd>
<dd><tt>-returns&nbsp;-1&nbsp;if&nbsp;no&nbsp;elements&nbsp;in&nbsp;heap.</tt></dd>
<a NAME="CCutil_dheap_changekey"></a>
<h2>CCutil_dheap_changekey</h2>
<dt>File:</dt>
<dd><tt>UTIL/dheaps_i.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_dheap_changekey&nbsp;(CCdheap&nbsp;*h,&nbsp;int&nbsp;i,&nbsp;double&nbsp;newkey)</tt></dd>
<dt>Description:</dt>
<dd><tt>-changes&nbsp;the&nbsp;key&nbsp;of&nbsp;the&nbsp;element&nbsp;with&nbsp;index&nbsp;i&nbsp;to&nbsp;newkey.</tt></dd>
<a NAME="CCutil_bix_getopt"></a>
<h2>CCutil_bix_getopt</h2>
<dt>File:</dt>
<dd><tt>UTIL/bgetopt.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_bix_getopt&nbsp;(int&nbsp;argc,&nbsp;char&nbsp;**argv,&nbsp;const&nbsp;char&nbsp;*def,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*p_optind,&nbsp;char&nbsp;**p_optarg)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;parse&nbsp;an&nbsp;argument&nbsp;list</tt></dd>
<a NAME="CCutil_allocrus"></a>
<h2>CCutil_allocrus</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_allocrus&nbsp;(size_t&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;an&nbsp;allocated&nbsp;block&nbsp;of&nbsp;"size"&nbsp;memory.</tt></dd>
<a NAME="CCutil_freerus"></a>
<h2>CCutil_freerus</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_freerus&nbsp;(void&nbsp;*ptr)</tt></dd>
<dt>Description:</dt>
<dd><tt>FREES&nbsp;ptr.</tt></dd>
<a NAME="CCutil_reallocrus"></a>
<h2>CCutil_reallocrus</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;*CCutil_reallocrus&nbsp;(void&nbsp;*ptr,&nbsp;size_t&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>REALLOCS&nbsp;ptr&nbsp;to&nbsp;size&nbsp;bytes.</tt></dd>
<a NAME="CCutil_reallocrus_scale"></a>
<h2>CCutil_reallocrus_scale</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_reallocrus_scale&nbsp;(void&nbsp;**pptr,&nbsp;int&nbsp;*pnnum,&nbsp;int&nbsp;count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;scale,&nbsp;size_t&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>void&nbsp;**pptr&nbsp;(a&nbsp;reference&nbsp;to&nbsp;the&nbsp;pointer&nbsp;to&nbsp;the&nbsp;allocated&nbsp;space)</tt></dd>
<dd><tt>int&nbsp;*pnnum&nbsp;(a&nbsp;reference&nbsp;to&nbsp;the&nbsp;number&nbsp;of&nbsp;objects&nbsp;in&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocated&nbsp;space)</tt></dd>
<dd><tt>int&nbsp;count&nbsp;(a&nbsp;minimum&nbsp;value&nbsp;for&nbsp;the&nbsp;new&nbsp;nnum)</tt></dd>
<dd><tt>double&nbsp;scale&nbsp;(a&nbsp;scale&nbsp;factor&nbsp;to&nbsp;apply&nbsp;to&nbsp;nnum)</tt></dd>
<dd><tt>int&nbsp;size&nbsp;(the&nbsp;size&nbsp;of&nbsp;objects&nbsp;to&nbsp;be&nbsp;realloced)</tt></dd>
<dd><tt>RETURNS&nbsp;0&nbsp;if&nbsp;*pptr&nbsp;was&nbsp;successfully&nbsp;changed&nbsp;to&nbsp;point&nbsp;to&nbsp;at</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;least&nbsp;max(*pnnum*scale,&nbsp;*pnnum+1000,&nbsp;count)&nbsp;objects.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pnnum&nbsp;is&nbsp;changed&nbsp;to&nbsp;the&nbsp;new&nbsp;object&nbsp;count.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Otherwise,&nbsp;prints&nbsp;an&nbsp;error&nbsp;message,&nbsp;leaves&nbsp;*pptr&nbsp;and</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pnnum&nbsp;alone,&nbsp;and&nbsp;returns&nbsp;nonzero.</tt></dd>
<a NAME="CCutil_reallocrus_count"></a>
<h2>CCutil_reallocrus_count</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_reallocrus_count&nbsp;(void&nbsp;**pptr,&nbsp;int&nbsp;count,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>void&nbsp;**pptr&nbsp;(a&nbsp;reference&nbsp;to&nbsp;the&nbsp;pointer&nbsp;to&nbsp;the&nbsp;allocated&nbsp;space)</tt></dd>
<dd><tt>int&nbsp;count&nbsp;(number&nbsp;of&nbsp;objects&nbsp;to&nbsp;be&nbsp;realloced)</tt></dd>
<dd><tt>int&nbsp;size&nbsp;(the&nbsp;size&nbsp;of&nbsp;the&nbsp;objects&nbsp;to&nbsp;be&nbsp;realloced)</tt></dd>
<dd><tt>RETURNS&nbsp;0&nbsp;is&nbsp;successful,&nbsp;and&nbsp;1&nbsp;if&nbsp;the&nbsp;realloc&nbsp;failed.</tt></dd>
<a NAME="CCutil_bigchunkalloc"></a>
<h2>CCutil_bigchunkalloc</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CCbigchunkptr&nbsp;*CCutil_bigchunkalloc&nbsp;(void)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURNS&nbsp;a&nbsp;CCbigchunkptr&nbsp;with&nbsp;the&nbsp;"this_one"&nbsp;field&nbsp;loaded&nbsp;with&nbsp;a</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;bigchunk&nbsp;of&nbsp;memory.</tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;The&nbsp;idea&nbsp;is&nbsp;to&nbsp;use&nbsp;bigchunks&nbsp;(the&nbsp;size&nbsp;of&nbsp;a&nbsp;bigchunk&nbsp;is&nbsp;defined</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;by&nbsp;CC_BIGCHUNK&nbsp;in&nbsp;util.h)&nbsp;to&nbsp;supply&nbsp;local&nbsp;routines&nbsp;with&nbsp;memory</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;for&nbsp;ptrs,&nbsp;so&nbsp;the&nbsp;memory&nbsp;can&nbsp;be&nbsp;shared&nbsp;with&nbsp;other</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;local&nbsp;routines.</tt></dd>
<a NAME="CCutil_bigchunkfree"></a>
<h2>CCutil_bigchunkfree</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CCutil_bigchunkfree&nbsp;(CCbigchunkptr&nbsp;*bp)</tt></dd>
<dt>Description:</dt>
<dd><tt>ACTION:&nbsp;Frees&nbsp;a&nbsp;CCbigchunkptr.</tt></dd>
<a NAME="CCptrworld_init"></a>
<h2>CCptrworld_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCptrworld_init&nbsp;(CCptrworld&nbsp;*world)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;initialize&nbsp;a&nbsp;CCptrworld&nbsp;with&nbsp;1&nbsp;reference</tt></dd>
<a NAME="CCptrworld_add"></a>
<h2>CCptrworld_add</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCptrworld_add&nbsp;(CCptrworld&nbsp;*world)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;add&nbsp;a&nbsp;reference&nbsp;to&nbsp;a&nbsp;CCptrworld</tt></dd>
<a NAME="CCptrworld_delete"></a>
<h2>CCptrworld_delete</h2>
<dt>File:</dt>
<dd><tt>UTIL/allocrus.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCptrworld_delete&nbsp;(CCptrworld&nbsp;*world)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;delete&nbsp;a&nbsp;reference&nbsp;to&nbsp;a&nbsp;ptrworld,&nbsp;and&nbsp;free&nbsp;if&nbsp;no&nbsp;more&nbsp;references</tt></dd>
<a NAME="CCutil_edgehash_init"></a>
<h2>CCutil_edgehash_init</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_init&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;size)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_add"></a>
<h2>CCutil_edgehash_add</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_add&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;end1,&nbsp;int&nbsp;end2,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;val)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_set"></a>
<h2>CCutil_edgehash_set</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_set&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;end1,&nbsp;int&nbsp;end2,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;val)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_del"></a>
<h2>CCutil_edgehash_del</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_del&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;end1,&nbsp;int&nbsp;end2)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_find"></a>
<h2>CCutil_edgehash_find</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_find&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;end1,&nbsp;int&nbsp;end2,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*val)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_getall"></a>
<h2>CCutil_edgehash_getall</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>int&nbsp;CCutil_edgehash_getall&nbsp;(CCutil_edgehash&nbsp;*h,&nbsp;int&nbsp;*ecount,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;**elist,&nbsp;int&nbsp;**elen);</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_delall"></a>
<h2>CCutil_edgehash_delall</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_edgehash_delall&nbsp;(CCutil_edgehash&nbsp;*h)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CCutil_edgehash_free"></a>
<h2>CCutil_edgehash_free</h2>
<dt>File:</dt>
<dd><tt>UTIL/edgemap.c</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>void&nbsp;CCutil_edgehash_free&nbsp;(CCutil_edgehash&nbsp;*h)</tt></dd>
<dt>Description:</dt>
<dd><tt>MISSING</tt></dd>
<a NAME="CC_SAFE_MALLOC"></a>
<h2>CC_SAFE_MALLOC</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_SAFE_MALLOC(nnum,type)</tt></dd>
<dt>Description:</dt>
<dd><tt>int&nbsp;nnum&nbsp;(the&nbsp;number&nbsp;of&nbsp;objects&nbsp;to&nbsp;be&nbsp;malloced)</tt></dd>
<dd><tt>data&nbsp;type&nbsp;(the&nbsp;sort&nbsp;of&nbsp;objects&nbsp;to&nbsp;be&nbsp;malloced)</tt></dd>
<dd><tt>RETURNS&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;allocated&nbsp;space.&nbsp;If&nbsp;out&nbsp;of&nbsp;memory,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;prints&nbsp;an&nbsp;error&nbsp;message&nbsp;and&nbsp;returns&nbsp;NULL.</tt></dd>
<a NAME="CC_FREE"></a>
<h2>CC_FREE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_FREE(object,type)</tt></dd>
<dt>Description:</dt>
<dd><tt>type&nbsp;*object&nbsp;(pointer&nbsp;to&nbsp;previously&nbsp;allocated&nbsp;space)</tt></dd>
<dd><tt>data&nbsp;type&nbsp;(the&nbsp;sort&nbsp;of&nbsp;object)</tt></dd>
<dd><tt>ACTION:&nbsp;frees&nbsp;the&nbsp;memory&nbsp;and&nbsp;sets&nbsp;the&nbsp;object&nbsp;to&nbsp;NULL.</tt></dd>
<a NAME="CC_IFFREE"></a>
<h2>CC_IFFREE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_IFFREE(object,type)</tt></dd>
<dt>Description:</dt>
<dd><tt>type&nbsp;*object&nbsp;(pointer&nbsp;to&nbsp;previously&nbsp;allocated&nbsp;space)</tt></dd>
<dd><tt>data&nbsp;type&nbsp;(the&nbsp;sort&nbsp;of&nbsp;object)</tt></dd>
<dd><tt>ACTION:&nbsp;if&nbsp;*object&nbsp;is&nbsp;not&nbsp;NULL,&nbsp;frees&nbsp;the&nbsp;memory&nbsp;and&nbsp;sets</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;object&nbsp;to&nbsp;NULL.</tt></dd>
<a NAME="CC_PTR_ALLOC_ROUTINE"></a>
<h2>CC_PTR_ALLOC_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_ALLOC_ROUTINE&nbsp;(type,&nbsp;functionname,&nbsp;chunklist,&nbsp;freelist)</tt></dd>
<dt>Description:</dt>
<dd><tt>data&nbsp;type&nbsp;(the&nbsp;sort&nbsp;of&nbsp;objects)</tt></dd>
<dd><tt>string&nbsp;functionname&nbsp;(the&nbsp;generated&nbsp;function)</tt></dd>
<dd><tt>CCbigchunkptr&nbsp;*chunklist&nbsp;(used&nbsp;to&nbsp;accumulate&nbsp;bigchunks)</tt></dd>
<dd><tt>type&nbsp;*freelist&nbsp;(used&nbsp;for&nbsp;the&nbsp;linked&nbsp;list&nbsp;of&nbsp;objects)</tt></dd>
<dd><tt>ACTION:&nbsp;Generates&nbsp;a&nbsp;function&nbsp;("functionname")&nbsp;that&nbsp;returns</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type&nbsp;*)&nbsp;objects,&nbsp;keeping&nbsp;the&nbsp;free&nbsp;ones&nbsp;on&nbsp;freelist</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;getting&nbsp;its&nbsp;space&nbsp;from&nbsp;calls&nbsp;to</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCutil_bigchunkalloc.</tt></dd>
<a NAME="CC_PTR_FREE_ROUTINE"></a>
<h2>CC_PTR_FREE_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_FREE_ROUTINE&nbsp;(type,&nbsp;functionname,&nbsp;freelist)</tt></dd>
<dt>Description:</dt>
<dd><tt>Parameters&nbsp;as&nbsp;above.</tt></dd>
<dd><tt>ACTION:&nbsp;Generates&nbsp;a&nbsp;function&nbsp;that&nbsp;adds&nbsp;an&nbsp;object&nbsp;to&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freelist.</tt></dd>
<a NAME="CC_PTR_FREE_LIST_ROUTINE"></a>
<h2>CC_PTR_FREE_LIST_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_FREE_LIST_ROUTINE&nbsp;(type,&nbsp;functionname,&nbsp;freefunction)</tt></dd>
<dt>Description:</dt>
<dd><tt>Parameters&nbsp;defined&nbsp;as&nbsp;above,&nbsp;with&nbsp;freefunction&nbsp;the&nbsp;function</tt></dd>
<dd><tt>generated&nbsp;by&nbsp;CC_PTR_FREE_ROUTINE.</tt></dd>
<dd><tt>ACTION:&nbsp;Generates&nbsp;a&nbsp;function&nbsp;to&nbsp;free&nbsp;a&nbsp;linked&nbsp;list&nbsp;of</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects&nbsp;using&nbsp;calls&nbsp;to&nbsp;freefunction.</tt></dd>
<a NAME="CC_PTR_FREE_WORLD_ROUTINE"></a>
<h2>CC_PTR_FREE_WORLD_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_FREE_WORLD_ROUTINE&nbsp;(type,&nbsp;functionname,&nbsp;chunklist,&nbsp;freelist)</tt></dd>
<dt>Description:</dt>
<dd><tt>Parameters&nbsp;defined&nbsp;as&nbsp;above.</tt></dd>
<dd><tt>ACTION:&nbsp;Generates&nbsp;a&nbsp;function&nbsp;that&nbsp;returns&nbsp;all&nbsp;of&nbsp;the</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory&nbsp;used&nbsp;in&nbsp;the&nbsp;CC_PTR_ALLOC_ROUTINE&nbsp;allocations</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;back&nbsp;to&nbsp;the&nbsp;global&nbsp;supply&nbsp;of&nbsp;CCbigchunkptrs.</tt></dd>
<a NAME="CC_PTR_LEAKS_ROUTINE"></a>
<h2>CC_PTR_LEAKS_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_LEAKS_ROUTINE&nbsp;(type,&nbsp;name,&nbsp;chunklist,&nbsp;freelist,&nbsp;field,</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;fieldtype)</tt></dd>
<dt>Description:</dt>
<dd><tt>As&nbsp;above,&nbsp;with&nbsp;"field"&nbsp;the&nbsp;name&nbsp;of&nbsp;a&nbsp;"fieldtype"&nbsp;field&nbsp;in&nbsp;the</tt></dd>
<dd><tt>object&nbsp;type&nbsp;that&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;0&nbsp;or&nbsp;to&nbsp;1.</tt></dd>
<dd><tt>ACTION:&nbsp;Generates&nbsp;a&nbsp;function&nbsp;that&nbsp;checks&nbsp;to&nbsp;see&nbsp;that&nbsp;we&nbsp;have</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;leaked&nbsp;any&nbsp;of&nbsp;the&nbsp;objects.</tt></dd>
<a NAME="CC_PTR_STATUS_ROUTINE"></a>
<h2>CC_PTR_STATUS_ROUTINE</h2>
<dt>File:</dt>
<dd><tt>INCLUDE/util.h</tt></dd>
<dt>Header:</dt>
<dd><tt>util.h</tt></dd>
<dt>Prototype:</dt>
<dd><tt>CC_PTR_STATUS_ROUTINE&nbsp;(type,&nbsp;name,&nbsp;chunklist,&nbsp;freelist)</tt></dd>
<dt>Description:</dt>
<dd><tt>&nbsp;&nbsp;&nbsp;ACTION:&nbsp;Like&nbsp;LEAKS,&nbsp;but&nbsp;does&nbsp;not&nbsp;check&nbsp;for&nbsp;duplicates&nbsp;(and&nbsp;so</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;does&nbsp;not&nbsp;corrupt&nbsp;the&nbsp;objects).</tt></dd>
<dd><tt></tt></dd>
<dd><tt>NOTES:</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;These&nbsp;routines&nbsp;use&nbsp;the&nbsp;functions&nbsp;in&nbsp;allocrus.c.&nbsp;&nbsp;The&nbsp;PTR&nbsp;macros</tt></dd>
<dd><tt>generate&nbsp;the&nbsp;functions&nbsp;for&nbsp;allocating&nbsp;objects&nbsp;for&nbsp;linked&nbsp;lists.&nbsp;They</tt></dd>
<dd><tt>get&nbsp;their&nbsp;raw&nbsp;memory&nbsp;from&nbsp;the&nbsp;bigchunk&nbsp;supply,&nbsp;so&nbsp;foo_free_world</tt></dd>
<dd><tt>(generated&nbsp;by&nbsp;CC_PTR_FREE_WORLD_ROUTINE)&nbsp;should&nbsp;be&nbsp;called&nbsp;for&nbsp;each</tt></dd>
<dd><tt>type&nbsp;of&nbsp;linked&nbsp;object&nbsp;"foo"&nbsp;when&nbsp;closing&nbsp;down&nbsp;the&nbsp;local&nbsp;memory.</tt></dd>
<dd><tt>&nbsp;&nbsp;&nbsp;To&nbsp;use&nbsp;these&nbsp;functions,&nbsp;put&nbsp;the&nbsp;macros&nbsp;near&nbsp;the&nbsp;top&nbsp;of&nbsp;the&nbsp;file</tt></dd>
<dd><tt>before&nbsp;any&nbsp;calls&nbsp;to&nbsp;the&nbsp;functions&nbsp;(since&nbsp;the&nbsp;macros&nbsp;also&nbsp;write&nbsp;the</tt></dd>
<dd><tt>function&nbsp;prototypes).&nbsp;If&nbsp;you&nbsp;use&nbsp;CC_PTR_FREE_LIST_ROUTINE&nbsp;for&nbsp;foo,</tt></dd>
<dd><tt>you&nbsp;must&nbsp;also&nbsp;use&nbsp;CC_PTR_FREE_ROUTINE,&nbsp;and</tt></dd>
<dd><tt>CC_PTR_FREE_LIST_ROUTINE&nbsp;must&nbsp;be&nbsp;listed&nbsp;after&nbsp;CC_PTR_FREE_ROUTINE</tt></dd>
<dd><tt>(to&nbsp;get&nbsp;the&nbsp;prototype).&nbsp;</tt></dd>
</body>
</html>
